# Выпуск №1

1 февраля 2016: Chrome 48, Firefox 44, Sass вместе с PostCSS, минимально необходимые шрифты, HTTPS, коты во фронтенде.

- Ольга Алексашенко
- Вадим Макеев
- Алексей Симоненко

**Вадим.**
Привет, меня зовут Вадим, мы записываем пилотный выпуск подкаста «Веб-стандарты». Будем обсуждать новости и просто общаться с вами на темы фронтенда. Представлю наших гостей.

**Оля.**
Добрый день, меня зовут Ольга Алексашенко, я верстаю руками в течение 10 лет и в этом подкасте я буду представлять практическую сторону разработки.

**Лёша.**
Привет, меня зовут Лёша Симоненко, я большую часть времени общаюсь с сообществом и занимаюсь образованием в HTML Академии.

**Вадим.**
Ок, да. А я Вадим, я работаю на браузерную компанию Opera, тоже занимаюсь образованием, организовываю конференции и прочее, прочее, прочее.

**Лёша.**
Ну что, к темам?

## Новинки браузеров (00:50)

**Вадим.**
Давайте начнем с самого такого дежурного. Когда готовились к передаче, мы обсуждали релиз [Chrome 48](https://youtu.be/TebeVxw95RI) и никто не смог вспомнить, что же там нового. Действительно, вот эта версионность новая, которая появилась в Chrome, в Opera, в Firefox и во многих других, она, конечно, немножко до сих пор смущает людей — все такие «Ой, Firefox 44, я помню десятка выходила, и что там нового, по сравнению с 43-м Firefox?», еще что-то такое…

**Лёша.**
Но знаешь, кстати, с другой стороны я бы очень хотел, чтобы то же самое произошло со всеми браузерами, и, например, от Safari хочется такого ожидать, и тогда было бы пофиг, что они называются 48, 49, 67, главное — что они просто релизится часто и поддерживают больше штук быстрее.

**Вадим.**
У Safari сейчас начинает такое происходить. Они раньше только в мажорных версиях добавляли или исправляли что-то новое, меняли UI WebKit, встроенный браузер тоже обновлялся мажорными версиями. А сейчас в минорных версиях уже начинают появляться какие-то изменения. Сейчас уже разработчикам доступны беты следующих версий macOS и iOS. И там уже серьёзные обновления, типа поддержка `<picture>` всяких…

**Лёша.**
Да, да, да… Например, переменные CSS будут. Это Safari 9.1 будет. Вот, ждем его.

**Вадим.**
Например, в упомянутом [Firefox 44](http://tanalin.com/blog/2016/01/firefox-44/) большая вещь, которую наконец-то вынули из флагов, это сервис-воркеры и пуш-уведомления. Вещь более важная, наверное, для мобильных браузеров. Firefox на мобильных не особо силен, но у них все-таки есть версия Firefox для андроида с собственным движком. Альтернативная поддержка какой-то спецификации и технологий — это всегда очень важный шаг. До этого сервис-воркеры работали только в движке Chromium, соответственно Chrome, Opera, Yandex.Browser и так далее. Сейчас у нас появилась альтернативная реализация, то же самое было с pointer-events, то же самое было с элементом `<picture>`, и так далее. Альтернативная реализация как-бы говорит разработчикам: всё, это в серьёз, давайте использовать, вот точно давайте использовать. И самые простые примеры, которые сейчас появляются с поддержкой сервис воркеров — это оффлайновые страницы, опять же, мало кто понимает зачем это делается. У вас есть какой-нибудь опыт, вы хоть раз трогали сервис-воркеры и вообще, понимаете как это работает, как это делается?

**Оля.**
Нет, мне не приходилось работать с сервис-воркерами, потому что я все-таки больше верстальщик, чем JS-программист. Но выход новых фич в Firefox — это очень хорошо, потому что сейчас для меня Firefox — это такой новый IE: везде все хорошо — в Firefox обязательно что-нибудь не работает или что-нибудь поехало. В общем — удивительный браузер, раньше я очень-очень его любила и пользовалась только им, но вот уже года два — увы… Так что я рада выходу новых фич.

**Лёша.**
Я самими сервис-воркерами не пользовался, но я пользовался предыдущей реинкарнацией — это Application Cache, это было очень давно… Ну как, три года, наверное, да?

**Вадим.**
Это очень давно, три года во фронтенде. Я уж не помню…

**Лёша.**
Ну да, я тогда делал какой-то калькулятор подсчёта стоимости разработки сайтов, такой развесистый весь, со всякими разными шутками и хотелось чтобы он работал всегда: есть интернет, нет интернета, и так далее. И Application Cache это все тогда очень радовались: «Круто, круто, и правда — в оффлайне! Смотри, я выключаю интернет, выключаю WiFi, а оно работает.» Это здорово, но проблем мы огребли, конечно, огромное количество: это и невозможность что-то обновить, и… Да вообще, работа с Application Cache была ужасной… Кстати, я заметил, что в 44-м Firefox Application Cache-то еще поддерживается, но уже выводит предупреждение о том, что это устаревший метод и его, наверное, уже использовать нельзя. Но это ладно, это о старом. А вот о сервис-воркерах — я пока себе вижу использование его не совсем по прямому назначению. То есть, не для оффлайновых страниц, а скорее для кэша. И вот эта идея мне понравилась.

**Вадим.**
Ну,  сервис-воркер настолько низкоуровневый, что прямого назначения у него, как такового, нет. Это просто API, который позволяет решать ваши задачи. А одна из задач, которую очень просто сделать, — сделать так, чтобы ваш сайт «застревал» в браузере, даже когда сайт закрыт, и имел возможность показать что-нибудь когда интернета нет. Не просто голую страницу с динозавриком, или какой у вас там браузер, а именно что-то полезное. На сайте Guardian кроссворд сделали. Мы с коллегами на Dev.Opera думаем сделать архив последних пяти статей, чтобы можно было даже в оффлайне почитать их со всеми ресурсами. И так далее. Естественно, нужно думать о кэше, особенно на мобильных устройствах, чтобы не занять слишком много. Но, опять же, можно картинки не класть, можно с помощью сервис-воркеров подменять картинки на какие-нибудь заглушки, прямо на лету, именно их класть в кэш. То есть штука слишком мощная, чтобы не знать и не пользоваться. Опять же, это скорее не для верстальщиков, но переломить у себя в голове идею того, что оффлайн — это тоже место, где мы можем что-то делать — это очень интересная вещь, которой точно стоит заниматься.

**Лёша.**
Ну, кстати, это не совсем всем понятно. На этой неделе были тоже статьи про работу сервис-воркеров. Как раз то, что ты рассказал на веб-стандартах про оффлайновую страницу — во ВКонтакте были очень показательные комментарии, вроде «А вообще нафига это надо?»

**Оля.**
Очень хороший пример — это почта. У тебя нет интернета, но ты хочешь в Google Mail посмотреть свой архив писем — это очень, очень нужная фича и мне её очень не хватает.

**Вадим.**
Ну, насколько я понимаю, до сих пор ни Google Inbox, ни Google Mail не могут показать тебе список писем, если у тебя нет интернета. Даже Google, который изо всех сил продвигает использование оффлайна, сервис-воркеров, кэша, и так далее — даже они ещё не перевели свои крупные приложения на полноценную работу.

## PhantomJS 2.1 (08:06)

**Лёша.**
На этой неделе еще знаете что вышло? [PhantomJS наконец-то разродился версией 2.1](https://raw.githubusercontent.com/ariya/phantomJS/master/ChangeLog). Это не совсем браузер, но что-то близкое, это оторванный движок от браузера. И, честно говоря, у нас для Phantom альтернативы нет. Вы же пользуетесь Phantom?

**Вадим.**
Я пользуюсь Phantom для тестирования, то есть я прогоняю какие-то функциональные тесты для парочки своих проектов. Пользуюсь в автоматическом режиме, естественно.

**Лёша.**
А мы вот Phantom очень сильно используем. У нас нет альтернативы и я с радостью принял бы, если бы ребята из Google для Blink выпустили что-то похожее, или даже пускай Microsoft выпустит движок свой в таком виде. Потому что эта безальтернативность не очень хороша и я поясню почему. Дело в том, что год назад зарелизилась версия 2.0, ровно двадцать третьего января 2015 года. И сейчас версия 2.1. Минорная версия зарелизилась спустя год. При этом при релизе 2.0 у них было огромное количество багов, которые никуда не девались в течение всего года. Это очень печально, если вы используете его постоянно.

**Вадим.**
Одно дело, когда тебе всего лишь нужно прогнать тест, какой-то там джаваскриптик, особенно какой-нибудь простой джаваскриптовый юнит-тест выполнить — это понятно. Но когда тебе нужно отрендерить картинку, чтобы оно работало ещё и так же, как работает в других браузерах, в живых браузерах, и так далее — это, конечно, большая проблема. А не пробовали ли вы использовать Electron для этого? Есть, дай бог памяти, как он называется, то ли Nightmare, то ли ещё как-то…

**Лёша.**
Nightmare — это да, это тестовый фреймворк

**Вадим.**
Да, да, это тестовый фреймворк, вроде Phantom, который использует Electron, на котором написаны Atom, Slack, и так далее. Грубо говоря, обёртка вокруг Chromium, который позволяет через API обращаться к браузеру и запускать его «безголовым».

**Лёша.**
Ага, потому что я что-то раньше его видел, но тогда он каким-то API сверху отличался, конечно, но это был тот же самый Phantom, как мне кажется, поэтому мы его никогда и не использовали, но если он работает с Electron — это хорошая идея, и я думаю мы посмотрим. Ну, хорошо, я думаю мы достаточно обсудили релизы, которые вышли на этой неделе. Давайте может быть тогда обсудим статьи по препроцессорам?

## Переменные в CSS (11:04)

**Лёша.**
На этой неделе были хорошие статьи. Например, был [перевод на Прогрессоре](http://prgssr.ru/development/peremennye-osnova-arhitektury-css.html "Переменные как основа архитектуры CSS при работе с препроцессорами"). Я считаю, что то, как используют препроцессоры это не очень хорошо, потому что препроцессоры — это такая штука, которая была добавлена для людей, которые пишут CSS. Чаще всего они не программисты, но при этом препроцессоры — это немножко внос какого-то «мира программирования» в CSS. И, как мне кажется, основная проблема с препроцессорами в том, что добавили некое программирование в CSS для людей, которые с программированием вообще никак не связаны. И из-за этого почти все проблемы. Ну например, знаешь, есть в каждом препроцессоре такая штука, как вложенность. Они делают кусочек слова и через амперсанд ставят слово-родитель, название класса, например, `.page`, а там следующий класс через амперсанд.

**Вадим.**
Конструируют селектор.

**Лёша.**
Да, и это, я считаю, ужасно. Когда ты работаешь в одном проекте — это, наверное, замечательно, ты бог этого проекта и ты всё знаешь, но как только ты отдаёшь его другому человеку, он находит этот класс у себя там где-то в верстке и пытается его найти, конечно же, в громадном CSS. Ну как мы ищем в редакторе — поиском, наверное, да? И эту штуку найти невозможно…

**Вадим.**
Нет, ну если мы используем компонентный подход, и если у нас один модуль на один файл, соответственно, мы всё быстро сможем найти.

**Лёша.**
Ну, подожди, это в идеале, когда у тебя совсем маленький файл, очень маленькие модули. Но чаще в практике встречается другое. Мы, когда обучаем ребят и видим, как наши наставники, например, пишут код и предлагают писать код, это всё разбивается. На практике всё происходит по-другому. Там просто ужас происходит. Ты ничего найти не можешь. Да, там бьётся всё на файлы, но эти файлы тоже большие, в них тоже ничего не найти. А главное — в чём преимущество-то? В том, что ты быстрее набираешь текст?

**Вадим.**
Можно переименовывать блоки быстрее таким образом, не ковыряясь, можно скопировать внутренности одного блока в другой блок без переименования всех селекторов, и так далее. Плюсы есть. Я иногда легко копирую внутренности какого-то блока с медиа-выражениями, с какими-то миксинами, ещё с чем-то — в другой блок. Конечно, стоит абстрагировать такие вещи, но иногда удобнее и проще скопировать, и тебе не нужно переименовывать вещи. То есть, код более реиспользуемый становится из-за этого, как минимум для меня.

**Лёша.**
Ну, а Оля, кстати, ты используешь препроцессоры?

**Оля.**
Да, использую.

**Лёша.**
А ты там прямо всё-всё используешь?

**Оля.**
Ну, я не уверена, что я знаю о них всё, потому что в моей голове нет справочника, но пользуюсь достаточно широким набором возможностей: миксинами, амперсандами. Но немножко не так, как вы тут обсудили: переменными, всякими калькуляциями, экстендами, в общем, это очень удобно, на мой вкус.

**Лёша.**
Я считаю, что препроцессоры — в целом это хорошо, это даёт толчок развитию самой спецификации CSS, потому что многое она заимствует оттуда. Но то, как их используют — это не очень хорошо. Мне кажется, самое хорошее, что есть в препроцессорах, следует использовать всегда. Это, конечно, импорты — разделение на много файлов, это замечательная штука. Это вложенность — если у тебя нет никаких холиваров на проектах по поводу вложенности. Есть люди, которые неистово за то, чтобы вложенности и вообще каскада никакого не было. Если таких людей нет на проекте, то тут тоже все удобно. В какой-то мере это вычисления — хотя сейчас `calc()` уже поддерживается, по-моему, достаточно хорошо. И, в какой-то мере, переменные.

Как раз в большей части эта статья на прогрессоре о переменных. Я тут с автором немного не согласен, потому что автор выступает за то, чтобы у тебя все переменные были в одном глобальном файле. Он, конечно, говорит, что «Не надо создавать много переменных, делайте по уму». Но это тоже не очень хороший подход. Потому что это больше похоже не на переменные, а константы, если мы берём какие-то классические языки программирования. Вот тогда да, это похоже, когда мы выносим их в какой-то конфиг. Константы в конфиге. А переменные — это всё-таки штука локального назначения. То есть, у тебя есть какой-то модуль и ему для его работы, было бы удобнее иметь какую-то переменную. Вот в этом смысле это удобно. Например, у нас слайдер есть какой-нибудь, мы его описываем. И он у нас не динамический, а мы меняем количество слайдов в CSS. И тут, конечно, удобно через переменную задать количество этих слайдов, и делить ширину, высоту, всё что нужно, в зависимости от этой переменной. Мы заходим, у нас количество слайдов поменялось, мы меняем эту переменную — всё замечательно. Но, если вы, конечно, не пишете фреймворк, зачем задавать цвета, размеры шрифтов в переменные — вот для меня это загадка.

**Оля.**
Ну, это как раз использование переменных в качестве констант. Ты очень правильно сказал про файл с константами, это действительно очень полезно. Например, я пользуюсь такими вещами для создания цветовых схем. У меня есть приложение, в котором есть дневная схема и ночная схема, и я все цвета храню в переменных, это очень-очень удобно, а так же там хранятся всякие константы типа семейств шрифтов. Удобно не прописывать огромную строчку десять тысяч раз со всем перечислением шрифтов: например, тебе тут нужен Sans, тут тебе нужен Serif, Serif Caption. Удобно пользоваться глобальными переменными. То же самое про line-height. В общем, по-моему это очень удобно.

**Вадим.**
Ну, лично у меня тоже на всех проектах, которые я делаю, есть файл defaults.scss в моём случае, где я храню базовые вещи, включая маленькие функции, которые я использую, всякие миксины. Но он обычно, не больше сотни строк, включая комментарии и прочее, и прочее. Твой праведный гнев скорее относится к тому, что это действительно константы, а не переменные как таковые. Не думаю, что на уровне языка и препроцессоров стоит разделять константы от переменных, но поговорить с разработчиком и понять разработчикам, что такие вещи стоит разделять — да, пожалуй, стоит.

Есть пример совершенно из другой области: я свой gulpfile.JS в какой-то момент начал разделять на отдельные вещи, складывать в папочку таски и так далее.В руководстве, которое помогало мне это делать, было написано: «выносите все пути в config.JS и используйте пути». И я, конечно, как молодец, пошёл по инструкции и вынес всё в конфиг. И я понял, что некоторые вещи у меня упомянуты в конфиге и использованы один раз. Такая переменная, которая используется один раз — это не переменная, как мы все знаем, это так, на будущее скорее. Поэтому, я настолько «законфигал» весь свой Gulp, разбитый по файлам, что мне стало не удобно в нём ориентироваться. Такой же ерунды можно наделать в своём CSS, так что да.

**Лёша.**
Тут хочется какой-то видимости всего. Всё-таки с этой штукой должны работать, а не для кого-то она должна быть удобной. А чтобы с ней работать — всё должны быть в контексте, но если человек приходит в проект — это очень тяжело.

**Оля.**
Ну смотрите, здесь есть плюс ещё и в том, что подобные возможности условного языка приучают людей к абстрагированию. Для верстальщиков это очень важно как переход к модульности, переход к абстрагированию каких-то вещей — это все очень сильно облегчает код и это полезно.

**Лёша.**
Я не уверен в этом, мне кажется, с препроцессорами, и с любовью всех перетаскивать в конкретные простые проекты подходов написания фреймворков — это всё добавляет слишком большую абстракцию в конкретный проект. В конкретном проекте должен быть минимум абстракций, он же конкретный. Вот у тебя дизайн и он должен быть таким. Ты же не фреймворк пишешь. И когда он конкретный, в моём понимании, то вся эта абстракция нафиг никому не нужна. Почему так происходит? Потому что ни у кого нет в голове мысли о том, как правильно. Где посмотреть то, как правильно? Давайте возьмём bootstrap, или foundation, еще какой-нибудь фреймворк и посмотрим. Но у них-то задача абсолютно другая.

## Sass с PostCSS (21:17)

**Вадим.**
Давайте тогда ещё буквально последнюю вещь про препроцессоры и прочее. Просто чтобы сделать этот выпуск моднее. Кто-нибудь PostCSS использует у себя в продакшене как таковой? Оля?

**Оля.**
Да, мы пользуемся PostCSS и мы заговорили об этом к слову о статье [Extending Sass with PostCSS](http://ashleynolan.co.uk/blog/extend-sass-with-postcss). Здесь у нас автору, видимо, задавали много раз вопрос, зачем он использует одновременно и Sass и PostCSS и почему это надо. Потому что это всё, якобы, дублирует друг друга. Но нет. У PostCSS есть прекрасные модули, которые могут ваш уже готовый код сделать ещё лучше, например, инлайнеры, минификаторы, всякая оптимизация SVG, конечно, автопрефиксер. Если кто-то ещё не вынес автопрефиксер в модуль PostCSS, то уже очень пора сделать. В общем очень-очень полезная вещь. И в этой статье, в частности, есть много ссылок как можно улучшить свою разработку на Sass и SCSS при помощи PostCSS.

**Вадим.**
Мой личный опыт показывает, что автопрефиксер — must have, они заставили меня перейти на PostCSS плагины — привет, Андрей! — вместо того, чтобы использовать gulp- или grunt-плагины с автопрефиксером непосредственно, но это ладно, имеют право, видимо. Но вот из такого, из полезного, мне больше всего нравится SVG-инлайнеры, которые знают, как нужно вставить SVG прямо в исходник, вернее, прямо в CSS файл, не конвертируя в base64, а экранируя всякие кавычечки, угловые скобки и так далее, чтобы один файл подгрузился — и весь SVG у тебя на месте, а не по запросу на каждый. Вот один из самых полезных плагинов, которые существуют лично для меня.

**Лёша.**
Я тут вам, наверное, буду ортогонален, но вот у нас сейчас последнее время новые страницы в академии верстают полностью на PostCSS. То есть там вообще нет никакого препроцессора. Это, наверное, погреет душу Андрею, но нам это понравилось и мы вообще никак не чувствуем себя обделёнными препроцессором. Потому что всё необходимое, что мы хотим, есть в PostCSS.

**Вадим.**
А ты можешь перечислить фичи, которые вы используете? Те необходимые фичи, которые вы используете из препроцессоров? Которые вы набрали с помощью PostCSS плагинов?

**Лёша.**
Ну, мы используем переменные, конечно.

**Вадим.**
То есть, вот такие, с долларом, да? CSS-переменные?

**Лёша.**
Моя любовь в этих всех технологиях в том, что я хочу, чтобы всё было в итоге по спецификации, вот очень хочу, поэтому, например, Babel.JS для JS мне нравится. Мне нравятся инструменты, которые делают в итоге то, к чему всё придёт. Мы уже пишем и учимся так, как скоро будет у всех по умолчанию.

**Вадим.**
Ну то есть вы просто подключили PostCSS, точнее, cssnext, в виде плагина, да?

**Лёша.**
Ну, у нас, конечно, не всё так просто. Там cssnext не полностью. Некоторые вещи вырезаны из cssnext. А некоторые, которых нет просто в CSS, но которые нашему верстальщику очень-очень-очень понадобились, добавлены. Это, например, вложенность с амперсандами верхними уровнями, и так далее.

**Вадим.**
Ок, то есть вы набрали нужный комплект и, в общем-то, рады и багов особо не было, да?

**Лёша.**
Нет, вообще не видим никаких багов. Нет, конечно, когда мы весь этот процесс собирали, там багов было огромное количество, потому что в PostCSS есть некая дурацкая штука — там нужен определенный порядок всех плагинов. Причем иначе они будут как-то криво работать или не работать. Если вы используете какой-то набор плагинов, типа cssnext, но используете не только его, а ещё ряд плагинов, которые нужно воткнуть где-то в середину.

**Вадим.**
Ага.

**Лёша.**
Вот это тоже рождает проблемы и приходится из cssnext выключать какие-то плагины, брать их отдельно, кусками, подключать перед. Ну, в общем, настроить себе окружение для работы PostCSS — это то еще дело. Но это вполне возможно и мы это сделали, закончили конфигурирование полгода назад и с тех пор вообще эту штуку не трогаем и она нас полностью устраивает.

**Вадим.**
То есть, после того, как намучились — мучиться перестали?

**Лёша.**
Ну, как-то так, да.

## Загрузка шрифтов (26:54)

**Вадим.**
Ладно, я предлагаю перейти к техникам. У нас есть несколько статей на тему шрифтов, SVG, элемента `<picture>` и прочее, что нового и интересного, какие техники предлагают. Вот я слышал, Оля, что тебе понравилась [статья про минимально необходимые шрифты](http://css-live.ru/articles/minimalno-neobxodimye-shrifty.html "Минимально необходимые шрифты") Зака Лезермана?

**Оля.**
Да, это довольно интересная и полезная статья. Он описывает все четыре основных способа подключения веб-шрифтов с их недостатками, мы лично сейчас используем на своём главном проекте второй способ — это встраивание шрифтов с помощью data URI и подгрузки таблицы стилей асинхронно. Но у него есть такой минус — это техника «засовывать шрифты в Local Storage», и, соответственно, браузер уже потом проверяет, нет ли шрифтов в Local Storage. И если вдруг вам в Local Storage попал какой-то побитый шрифт, вызывает много проблем у конечного пользователя. Собственно, способ, который описан в этой статье, предполагает уменьшение файла шрифта. Его предлагается сохранить в формате WOFF2 и потом сконвертить в base64, насколько я поняла. В общем, суть этого метода в том, чтобы взять из нужного шрифта самые используемые глифы и на первом этапе загрузить только их, чтобы страница показалась как можно быстрее при минимальной загрузке, а потом уже в процессе догрузить всё остальное. Шрифт мелькнёт при этом, но уже будет красивее всё.

**Лёша.**
Наверное, стоит сказать и о других способах, потому что их всего было пять, ты сказала про второй и самый последний, пятый. Первый способ — это ничего не делать. Это когда мы просто используем директиву `@font-face` и ждем милости от браузера, чтобы он все сам сделал. И это, по мнению автора, считается анти-паттерном уже, из всех возможных способов самый худший способ. Третий способ — это когда мы работаем с «динамическим классом». То есть, у нас изначально шрифт в CSS не используется. Мы его подгружаем с помощью какой-нибудь JS API для подгрузки шрифта, или встроенного в браузер, или отдельной библиотекой подгружаем этот шрифт. И только когда мы уверены, что он подгрузился, мы добавляем класс к `<body>`, который добавляет этот шрифт в CSS. И четвертый принцип — это когда мы эту же технику делим на несколько маленьких шрифтов. В предыдущей технике мы грузили всё семейство шрифтов: и жирный, и наклонный, и так далее. А в четвертой технике нам предлагают разделить шрифты на каждый кусочек и загружать отдельно каждое начертание с помощью JS и добавлять соответствующий класс для `<body>`. Как по-вашему? Вадим, тебе какой способ нравится?

**Вадим.**
Я делал в конце прошлого года редизайн [конференции Web Standards Days](https://wsd.events/), и там я использовал следующий подход. Прямое начертание инлайнил в основной CSS, там используется, по-моему, шрифт Roboto. Естественно, и латиница, и кириллица, но получается не так тяжело. В формате WOFF, не WOFF2, потому что WOFF2 менее совместимый, а в формате WOFF — всё равно получилось, по-моему, порядка 60 килобайтов, но зато в одном файле всё проскакивает… Прямое начертание инлайнится, а остальные начертания в «голове» на странице подгружаются уже асинхронно, тоже в виде CSS файлов. Подобный способ не является в чистом виде ни одним из описанных. И, наверное, стоило бы добавить в это дело еще Local Storage и прочее, прочее, прочее. Но вот подобный способ — самый простой: прямое начертание, а потом, асинхронно, все остальные. По-моему, он лучше всего подходит, скажем так, для базовой оптимизации подгрузки шрифтов.

**Лёша.**
Если спросить меня, как мы использовали шрифт, то мы делали примерно то же самое, что делала Оля у себя на проекте. Мы запихивали в CSS-файл шрифт в base64 и этот CSS-файл подгружали асинхронно с помощью JS. И, когда он подгружался, кидали его в Local Storage. Но, честно вам скажу, это не очень хороший способ, потому что доходит до таких простых вещей, что Local Storage — если у вас нормальный шрифт, с нормальным количеством килобайт — у вас просто Local Storage может зависнуть и крашнуть ваш браузер легко. Он просто не может открыть такое количество текста, не знаю почему. Вот даже сегодня я ставил новый Firefox 44, пытался открыть его — та же самая история, всё падает. Техника хорошая, быстро работает, но вот за счёт того, что идёт работа с Local Storage, это не очень прикольно. Ну, и плюс нужно помнить, какое количество информации в Local Storage, и когда вы в следующий раз достаёте её из Local Storage, она, во-первых, на мобильных очень сильно потребляет батарейку, а во-вторых очень сильно задерживает процессор. Поэтому это не самая хорошая техника. И вот сейчас, буквально на прошлой неделе, мы переделали всё на вот этот способ с подгрузкой шрифта через JS API. То есть, у нас этот FontFaceOnLoad. Хотелось бы использовать встроенный в браузере API, но там поддержка не очень хорошая — мы сейчас подгружаем шрифты через JS. Причём, каждое начертание отдельным потоком, что позволяет браузеру, например, в четыре потока их грузить одновременно.

**Вадим.**
А вы кодируете файл шрифта во что-нибудь, или он как есть?

**Лёша.**
Нет, шрифт лежит как есть. Это WOFF и WOFF2 форматы. В CSS из `<body>` выносится этот шрифт. У нас Muller используется, он выносится, там Arial только. И в классе `.muller`, который будет на `<body>`, меняется `font-family`. И, когда в JS, например, промисом, все четыре начертания к нам приходят, мы просто добавляем этот класс. Ну а дальше есть хитрая техника. Это, когда мы первый раз их загрузили, мы кидаем в session storage какую-нибудь переменную, что шрифты были первый раз загружены у пользователя. И когда он заходит второй раз, мы уже вообще ничего не трогаем. Мы смотрим, что эта переменная у нас есть, значит браузер эти шрифты трогал, значит, если ваш сервер правильно настроен, они закэшированы браузером, и мы просто в этот момент добавляем класс к `<body>` и всё происходит очень быстро.

**Вадим.**
Возвращаясь к первой технике, которую Зак называет анти-паттерном, что не стоит сейчас браузеру просто отдавать с помощью `font-face` вообще все шрифты, что у вас есть на проекте, чтобы он их кэшировал, и так далее. На мой взгляд, так должно быть — подключаете, и оно работает. Так должны работать все технологии в браузерах. А то, что мы сейчас делаем — мы пытаемся станцевать с бубном, чтобы оно заработало лучше, но на самом деле лучше оно должно работать с помощью API браузерных, с помощью просто встроенной браузерной магии.

**Лёша.**
Ну да. В общем, ждем `font-display`. Мне тоже кажется, что этим должны заниматься браузеры. Вообще странно, что изначально, когда добавили шрифты, никто не подумал про это.

**Вадим.**
А их никто не использовал, потому что они слишком тяжелые были.

**Лёша.**
Ну да, как обычно и получается: практика применения показала все проблемы — и вот оно решение.

## Спрайты (35:22)

**Вадим.**
И немножечко еще про хаки. У нас, пожалуй, всё ещё нет нормальной системы использования иконок в браузерах, мы всё ещё пытаемся выяснить нормальный способ. Мне кажется, что ещё куча людей сидит на иконочных шрифтах. Какой у вас опыт в этом смысле?

**Лёша.**
Иконочными шрифтами мы почти сразу перестали пользоваться, как только поняли все его проблемы: то что не загружается, загружается криво, Opera Mini их вообще вырезает, и все остальное, с этим связанное. И я бы считал, что по сути у нас всего две техники: это спрайт с растровыми изображениями, и спрайт с SVG-изображениями. И спрайт с SVG-изображениями — это по-моему то, что нужно, само лучшее. Единственное — у нас, так же как и со шрифтами, огромная проблема, как их правильно использовать, потому что браузеры до сих пор не дают возможность использовать символьный SVG-файл отдельным файлом. Оля, а вы как используете?

**Оля.**
У нас тоже есть растровые спрайты, которые склеиваются при помощи Gulp-таска, и SVG-спрайты. Как раз перед нами [статья](https://una.im/svg-icons/ "A Gulp-Based External SVG Symbol Sprite Icon System"), в которой Юна предлагает свой бойлерплейт для создания библиотек SVG-иконок. Это действительно очень полезная техника, которой пользуемся и мы. Я не знаю, как конкретно вот этот работает, но у нас работает так: все SVG, которые лежат у нас в модулях проекта, склеиваются в одну библиотеку, эта библиотека подключается, и при помощи специальных миксинов в нашем шаблонизаторе, мы выводим SVG-иконки.

**Лёша.**
Мы как раз недавно определялись с SVG-спрайтами у нас на проекте. Тоже перебрали несколько техник, в том числе инлайн этих всех SVG-иконок прямо в html-документы, и реиспользование их, и так далее. Опять же говорю, что у меня любимая штука — это использовать, как задумано, как должно быть, просто ещё не реализовано в браузерах. Понятно, мы не говорим сейчас про сборку, сборкой занимаются какие-то автоматизаторы. У нас есть в итоге какой-то SVG-файл с кучей иконок, или много файлов SVG. И мне нравится идея использовать загрузку символов с внешних источников. Есть библиотека svg4everybody, которая позволяет решить проблему External-символов, загрузки символов, которые лежат на внешнем ресурсе. И мне кажется, ведь такое должно появиться в браузерах, правильно? Ведь оно должно работать. Это по стечению каких-то обстоятельств оно не работает. Скорее всего мы будем использовать именно такую технику, когда мы используем SVG-символ на странице через `<use>`, мы пишем `sybols.svg` — путь к нему, и через решёточку айдишник этой иконки. И вот такой способ мне кажется наиболее правильным во временном периоде.

**Вадим.**
Самый правильный способ на мой взгляд — это когда ты для того чтобы вставить иконку на страницу, HTML не трогаешь вообще. И ты делаешь что — ты в `background-image` задаёшь svg-спрайт, а когда пишешь путь к иконке, указываешь `icons.svg#symbol_id`. Это называется Fragment identifier, и это пока не поддерживается практически нигде. По-моему в Firefox оно сейчас поддерживается, если не ошибаюсь. Эта [спецификация](https://www.w3.org/TR/SVG11/linking.html#SVGFragmentIdentifiers) есть очень давно, но браузеры не торопятся почему-то. Я слежу за багами в разных трекерах, но движения особо нет.

## Адаптивные картинки (36:25)

**Оля.**
Давайте перейдём к вопросу `srcset`. И у нас следующая статья — [Responsive Image Breakpoints Generator](http://www.responsivebreakpoints.com/).

**Вадим.**
Да, я делал доклад про элемент `<picture>` «Сколько верстальщиков нужно, чтобы вставить картинку?» Доклад у меня строился по схеме: сейчас я вам расскажу про самый простой способ использования элемента `<picture>` — там вообще элемент `<picture>` даже не нужен. А к концу я показывал слайд, на котором использованы все способы подключения, учитывающие разные форматы картинок и получалась огроменная-огроменная-огроменная батарея внутри элемента `<picture>` с фолбэком на `<img>` и с кучей всяких `srcset`, `media`, и прочего. Выглядело это устрашающе, и многих скорее всего отпугнуло.

А сейчас ребята создали генератор брейкпоинтов — самой сложной части адаптивных картинок, того, что нужно вручную сообразить и написать. Вы просто загружаете свою картинку и указываете бюджет, который вам нужен: сколько вы килобайтов хотите, какие вам размеры нужны. И оно для вас генерируется разметку. В общем, есть большая надежда на то, что этот генератор поможет вам начать использовать `<picture>`, или хотя бы попробовать, как оно работает. Потому что есть некоторая проблема со спецификацией в том, что она позволяет легко стартовать для простых вещей — подгрузить ретиновую картинку, допустим — но, как только вам нужно делать какое-то кадрирование, вы сразу начинаете закапываться.

## HTTPS (38:01)

**Лёша.**
Оля, все ваши сайты, которые вы делаете, уже работают на HTTPS?

**Оля.**
Те, которые связаны с финансами, — да, они работают на HTTPS.

**Лёша.**
Мне кажется, что [использование HTTPS](https://habrahabr.ru/post/275539/ "Почему до сих пор повсеместно не используется HTTPS?") — это, конечно, очень важная штука, и по большому счёту, она должна быть везде. И нас в последнее время к ней очень ощутимо толкают. Многие API, те же самые Service Workers, начинают в браузерах работать только по HTTPS. То есть, не будут работать по HTTP. Я ведь прав, Вадим?

**Вадим.**
Да, это собственно одна из главных проблем. Давай сейчас мы сыграем в такую пантомиму: я прикинусь человеком, который задал вопрос во ВКонтакте. Скажи, Алексей, а зачем мне HTTPS? Если у меня просто статическая страница, на которой я не принимаю никакие данные от пользователя, не отправляю ничего, там нет никаких денег, вообще ничего — просто статическая HTML-страница. Зачем мне HTTPS? Зачем мне платить за сертификат? Зачем мне мучиться с настройкой сервера, если у меня там просто «вот», м?

**Лёша.**
Ну, это и правда сложный вопрос. Возможно ему то и не нужно, если он вообще ничего не хочет с ней делать, может даже и не хочет, чтобы на неё заходили. Но HTTPS — это точно важная штука, не только для тебя, как владельца сайта, но и для пользователей, которые туда заходят. Сейчас очень много каких-то мифов-полумифов рассказывается людям о том, что интернет — это опасно, ваши данные могут украсть на каждом сайте. Доверие у пользователей начинает подрываться. И браузеры для этого многое делают — они выводят вам всякие красивые зелёненькие иконочки у сайта, что это сайт безопасный. В общем, все друг с другом начинают заигрывать, и это заигрывание приводит к тому, что HTTPS вроде как начинает выглядеть более выгодным.

Другая проблема в том, что за это же деньги надо платить, причём каждый год, сертификат стоит не маленьких денег, нужны какие-то знания, чтобы всё это настроить. Обычному верстальщику конечно же этого всего не хочется. Но вот у нас совсем недавно появилась инициатива, кажется от Mozilla — Let’s Encrypt.

**Вадим.**
Ну, точнее инициатива не от Mozilla как таковой, просто собрались люди, в частности Mozilla, которые решили помочь главной проблеме сертификатов — а это обычно очень дорого и очень муторно. Let’s Encrypt предложили простые установщики для различных конфигураций: Apache, NginX, и так далее. Которые позволяют вам легко поднять сертификат, ничего за него не платить, продлять раз в 90 дней и иметь HTTPS у себя легко и просто. Они принимают спонсорскую поддержку, для того, чтобы поддерживать техническую инфраструктуру, потому что всё-таки за это кто-то должен в итоге платить. Поэтому в какой-то момент проблема с тем, что сертификаты дорогие и сложные, решится. Просто мы сейчас на первом этапе.

**Лёша.**
Вот в последней бете Chrome GeoLocation API работает только через HTTPS.

**Вадим.**
Есть две вещи, которыми разработчиков стали в эту сторону толкать.

Первый — один из кнутов скорее, чем пряников — это запрещение API, которые могут передавать какие-то данные: getUserMedia(), GeoLocation API, Service Workers, более серьёзные API, и так далее. Часть из них появилась до того, как началась эта масштабная кампания по внедрению HTTPS, и все они работали раньше без проблем по HTTP. Сейчас они в браузерах начинают уводиться под HTTPS, и браузеры будут требовать от вас безопасного соединения вашего домена, для того, чтобы эти API заработали. Они естественно будут работать локально, на localhost, и вам не нужно будет поднимать сертификаты для этого. Но для живых сайтов это нужно будет делать. Поэтому если вы встраиваете на свой сайт карту, в которой можно нажать на кнопочку и спросить «а где я?» в каких-нибудь Яндекс.Карты или Google.Maps, и для этого используется GeoLocation API, — вам нужен HTTPS-домен.

А есть ещё второй способ, которым толкают более широкое внедрение HTTPS — через пользователей. Раньше было два состояния: страница безопасная, если она подписана каким-то сертификатом и идёт по HTTPS; более нормальные страницы просто открывались в браузере, была адресная строка, был значок HTTP и всё, а HTTPS помечали зелёным. А сейчас браузеры начинают экспериментировать с тем, что сайты по HTTP начинают помечаться как опасные, если на них, допустим, вы вводите пароль, или передаёте какие-то данные, используются какие-то API. То есть, браузеры от умолчания, что все сайты безопасные, переходят к тому, что все сайты опасные, если они не на HTTPS. И в какой-то момент браузер, открыв ваш сайт, над которым вы работаете, может сказать, что он опасен. Он не только в выдаче Google будет ниже, или каким-то образом помечаться, но ещё и сам браузер покажет вам не просто серенький замочек, и уж понятно не зелёненький — н  покажет вам замочек с крестиком. И пользователь посмотрев на него скажет: «Ой, это плохой сайт, там мои данные передаются в открытом виде и их можно легко перехватить». Так что это всё не просто игрушки, типа «хотите переходите, хотите нет». В какой-то момент это всё может больно ущипнуть вас.

## Парадоксы HTML и CSS (43:38)

**Вадим.**
Среди ссылок на этой неделе был забавный список [WTF, HTML & CSS?](http://wtfhtmlcss.com/), в котором автор привёл вещи, которые кажутся парадоксальными, необычными и абсолютно непонятными. Как наш один из главных практиков в нашей передаче, Оля, задам тебе вопрос: что-нибудь новое, интересное нашла ты в этом списке, или он бледный и слабый?

**Оля.**
Этот список в первую очередь забавный. Он не очень однородный, потому что тут есть как особенности каких-то конкретных браузеров, так и вообще особенности HTML и CSS. И действительно, для тех, кто впервые берётся изучать HTML и CSS, некоторые вещи вызывают взрыв мозга. Это, например, Box Model. Или схлопывающиеся `margin` — почему это всё происходит. Clearing — мне стоило большого труда объяснить многим людям, что это, зачем это нужно, и почему это вообще так работает. Тут есть очень полезная вещь, которую я не знала — `transform` позволяет `fixed` фиксировать относительно родителя, а не относительно вьюпорта. Прикольно! Это может быть полезно. Не знаю, сколько это проживёт, и вообще почему оно так работает. Тут есть какая-то [ссылка на пост Эрика Мейера](http://meyerweb.com/eric/thoughts/2011/09/12/un-fixing-fixed-elements-with-css-transforms/). Надо наверное её изучить, там всё объясняется. Ну вот, полезная штука.

А вообще, мне кажется эту статью надо прокомментировать Лёше, потому что обучение, новички, странные вещи HTML и CSS — я думаю, что это его область.

**Лёша.**
Хорошо, давай. На самом деле, на большинство из этих вещей мы стараемся обращать внимание, и они все по делу. Единственный момент, в котором очень многие ошибаются. Понятное дело, вы уже читали статью, вам задавать вопрос бессмысленно. Но я задал этот вопрос ребятам на неделе. Вопрос простой: как вы считаете, у тега `<button>` какой тип по умолчанию? Ведь многие тег `<button>` используют без типа вообще. Эта статья рекомендует ставить тип всегда. И как оказалось многие не знают этого. Почему не знают — потому что раз тег `<button>`, то видимо у него дефолтный тип `button`. Это же `<button>`! Не знаю, откуда пришло такое мнение, но я вот у кого бы не спрашивал, всем кажется, что у `<button>` по умолчанию `type="button"`, а на самом деле `type="submit"`. То есть, если вы не пропишите какой-то тип, ваша кнопка — как бы вы её не назвали, Cansel или не Cansel — она будет сабмитить вашу форму. И вот эта особенность — это какая-то нестыковка спецификаций, как мне кажется. В моём понимании — это странно.

**Вадим.**
Я совершенно чётко вижу, почему и как это случилось. Потому что был период, когда спецификации были чётко разделены: были описаны отдельно формы, отдельно инлайн-элементы, отдельно таблицы. Соответственно все кнопки были интерактивными элементами, и они все должны были что делать — отправлять формы. И кнопок, которые просто как кнопки открывают какие-то модальные окна, закрывают их, и ещё что-то такое — особо не было. Речь была о том, что если ты вставляешь просто `<button>` и `type="submit"`, чтобы эта штука сабмитила. А если тебе нужно дополнительное поведение, ты ставишь другой тип этой кнопки.

## Коты JS-фреймворки (47:18)

**Вадим.**
Ну и последняя вещь на сегодня. Немножко веселья. Самый любимый спор, самая любимая тема для конференций и вообще общения. Если раньше это было «Mac — Windos», «табы — пробелы» — разработчики пытались спорить как могли, то сегодня из-за огромного обилия фреймворков и всяких библиотек, конечно, все начинают бодаться, у кого лучше фреймворк. Интересный сайт — «[Каким котом был бы ваш JavaScript фреймворк?](http://whichcatisyourjavascriptframework.com/ "Which cat is your JavaScript framework?")» — запустили ребята. Это не первая попытка сделать что-то в духе «давай-ка мы нарисуем ваш браузер или вашу технологию в виде живого персонажа». Но у ребят по-моему получилось. Тут виден лёгкий перекос в сторону Angular — он самый лучший, он самый «Криштиану Роналду» среди котов. Но попытки показать свойства фреймворков в виде разных персонажей, в виде свойств котов — довольно интересными получаются. Обязательно посмотрите.

Вы, ребята, ещё помните какие-нибудь подобные вещи из жизни? Я помню, что долгое время браузеры рисовали в разных стилях. Одно из самых ярких воспоминаний на эту тему — как Internet Explorer сидит в углу, жуёт клей и у него рука застряла во рту.

**Лёша.**
Ну да, чаще всего именно браузеры рисовали. Что-то даже не припомню ничего другого. Но причём браузеры рисовали абсолютно в разных стилистиках. Это любимая тема была.

**Оля.**
Ну, помимо браузеров ещё операционные системы. Эти картинки зачастую даже включали какие-то сюжеты про взаимоотношения между ними. Это такая забавная типизация. И этот сайт с фреймворками очень приятно сделан. Очень симпатичные котятки нарисованы. Так что обязательно посмотрите. И выберите своего кота.

**Вадим.**
Если у вас проблемы с выбором фреймворка по их особенностям — вы можете просто выбрать самого симпатичного кота.

**Лёша.**
Жирненький там очень смешной. А знаешь, если наведёшься на него ещё и отвёртка появится.

**Вадим.**
О, господи, да!

---

**Вадим.**
Ладно, на этом будем заканчивать. Ещё раз напомню, что это был пилотный выпуск подкаста «Веб-стандарты». Мы хотим попробовать общаться с вами в новом формате, обсуждать новости, которые мы пишем за неделю, обсуждать какие-то события из нашего собственного опыта, приглашать гостей, пытаться делать какие-то эфиры с конференций, а не просто сидеть дома и записывать это всё.

Ещё раз напомню, кто был с нами: Алексей Симоненко из HtmlAcademy, Ольга Алексашенко — практик, и Вадим Макеев из Opera Software. Мы все из Петербурга. И в этом месте я сломался…

Услышимся в следующих выпусках через неделю или когда-нибудь ещё.

**Лёша.**
Да, давайте через неделю.

**Оля.**
Чао-чао!

**Лёша.**
Пока!
