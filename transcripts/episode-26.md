# Выпуск №26

25 июля 2016: Chrome 52, Safari и MathML, `font-display`, WebP и WebM, HyperTerm, книги, путь фронтендера.

- Ольга Алексашенко
- Вадим Макеев
- Алексей Симоненко

**Вадим.**
Привет, с вами 26-й выпуск подкаста «Веб-стандарты» и его постоянные ведущие: Алексей Симоненко из HTML Academy, Ольга Алексашенко — верстальщик руками из Exante.

**Оля.**
И Вадим Макеев из Opera.

## События

**Вадим.**
На этой неделе снова подвалило событий. Видимо, осень близко, зима близко. В общем, неожиданно появилась CSS-конференция. Мы все очень удивились, и наверное, это хороший знак, что, мол, JS, это не всё, что у нас есть, раз уж мы фулстек, ребята.
В Харькове будет [KharkivCSS](http://kharkivcss.org/) 17 сентября. Стоит это всё дело 250 ₴, ну это примерно 10 €. Можно, в принципе, смело ехать, темы там интересные, ребята постарались в программе рассмотреть все области CSS, хотя вряд ли им удалось охватить прямо всё, но там есть Flexbox, Grid, по-моему, анимации, ещё что-то такое, в общем, программа выглядит довольно интересно, посмотрим, что из этого получится.

[LvivJS](http://lvivjs.org.ua/), мы говорили, будет 27 августа, в тот же самый день, когда будет [Frontend Union Conf](http://frontend-union.co/) в Вильнюсе, поэтому у вас тяжёлый выбор. LvivJS стоит 450 ₴ — это где-то 17 €, в общем, тоже не дорого и довольно интересно. Я в прошлом году был на LvivJS, выступал, было хорошо, и все ребята с опасениями по поводу, ехать во Львов или нет — там всё в порядке: отличный город, и меня классно приняли.

Ну и [HolyJS](http://holyjs.ru/). Ребята только зачехлили свою петербуржскую конференцию, чтобы вернуться в следующем году, как все думали. И тут раз, Москва. И HolyJS собираются провести конференцию по JavaScript. Уж не знаю, сколько там дней будет, скорее всего один — 10 декабря в Москве. По опыту петербуржской конференции, которая стоила около 5000 ₽, видимо, они столько же сделают и в Москве, может чуть дороже, но это было где-то около 70 €, всем, кому проще считать в европейской валюте.

Ну и мы всё ближе к тому, чтобы анонсировать [WSD осенью](https://wsd.events/#calendar). Мы уже начинаем потихоньку определяться с Питером, а скорее всего будет 1 октября, но я пока не хочу бежать впереди поезда.

**Лёша.**
Хотел сказать, что это между нами, никому не говорите.

**Вадим.**
Да, никому.

## Браузеры

**Вадим.**
На этой неделе было немного новостей про браузеры. Самое интересное, пожалуй — Пит Лепаж в видео [Chrome 52: Contain Property, the PerfObserver API & SW Stream](https://youtu.be/Pii-LaWOyuo) рассказал, какие новые вещи появились в Chrome 52, в стабильном, для разработчиков. Среди них, это [CSS Containment](https://developers.google.com/web/updates/2016/06/css-containment) позволяющая вам в CSS определять, как браузер будет рендерить определённые элементы. У нас до этого было свойство `will-change`, которое подсказывало браузеру, что этот элемент уж точно изменится, и вы могли указать как именно он изменится. Сейчас у нас есть возможность указать с помощью спецификации CSS Containment, какая часть элемента будет изменяться, какие особенности элемента будут изменяться. Там есть значения `layout`, есть `size`, есть `style`. В общем, там есть группа элементов. К этому видео есть три статьи, которые описывают каждую основную фичу. В частности, там есть про CSS-свойство `contain`. Можете почитать. Ну грубо говоря, если вы поняли, что какая-нибудь ваша бесконечная прокрутка с аккордеоном и плавающими снежинками поверх плохо работают, вы можете взять свойство `will-change`, которое поможет вам решить одни проблемы, вы можете взять ещё и CSS Containment, которое позволит улучшить в браузерах на основе Chromium ваши анимации, рендеринг, и так далее. То есть, полезно знать, если вы занимаетесь оптимизацией. Но, по-хорошему, этим должны заниматься все.

**Лёша.**
А я хотел спросить. На это свойство есть какая-та спецификация? Потому что как-то она прошла мимо, или ребята добавили это в W3C и нам можно ожидать её скорого появления и в других браузерах?

**Вадим.**
Ну, тут ведь как: W3C не W3C, а ребята хотят улучшать рендеринг в браузерах, давать разработчикам больше возможностей. Соответственно, есть всякие черновики, которые внедряются смело, даже если нет нормального статуса, как спецификация. Поэтому у CSS Containment есть спецификация, но ещё, как и десятки других спецификаций, рабочий черновик, который пока в других браузерах не собираются применять. Но, у свойств `will-change`, у CSS Containment есть особенность — это штука не просто добавляет что-то на страницу, она улучшает страницу. То есть можно рассматривать её, как прогрессивное улучшение, например, если есть этот Containment, то браузер может вести себя чуть умнее и рендерить страницу лучше, а если его нет, ну значит браузер будет вести себя, как обычно. И на самом деле, если спросить меня, спросите-спросите, браузер должен всё делать самостоятельно. И эти свойства, это такие костыли, пожалуй, которые позволяют улучшать рендеринг прямо здесь и сейчас, но по-хорошему, я надеюсь, что в будущем они будут бесполезны. Конечно, если мы не придумаем очередной способ замедлить наш рендеринг.

Ещё к слову о быстродействии. Ещё одна из возможностей, которая появилась в стабильном Chrome 52 — это [Performance Observer API](https://developers.google.com/web/updates/2016/06/performance-observer). Это такая штука, которая позволяет вам не писать самостоятельно какие-то штуки, которые определяют быстродействие вашего приложения на основе [Performance measurements through `requestAnimationFrame`](http://www.quirksmode.org/blog/archives/2016/03/rafp_a_proposal.html) (что-нибудь такое), а которое прямо говорит браузеру, мол, вы берёте API и, грубо говоря, следите за вашей страницей, и как только какие-то данные собираются, браузер через какой-нибудь промис отдаёт и говорит: «Вот данные». По идее, это можно использовать для профилирования ваших страниц, чтобы понять, что вообще у вас там медленно-быстро, собирать какие-то метрики и анализировать. Я тут подумал, что ведь можно прогрессивно включать и выключать какие-то части вашего интерфейса, которые, допустим, прямо в рантайме приводят к тому, что браузер замедляется. Была статья, не так давно, про то, что на основе `requestAnimationFrame` можно анализировать, как ведёт себя страница. И тут же пришла критика, мол не всегда работает. И может Performance Observer позволит в рантайме определять, если страница работает медленно, можно, видимо, отключить какой-нибудь полупрозрачный `background-blending-mode`, который там всё жутко замедляет в одних браузерах, а в других работает нормально. Ну то есть прогрессивно оптимизировать страницу с помощью него, наверное, можно будет.

**Лёша.**
Знаешь, когда мы и в прошлый раз обсуждали хак с `requestAnimationFrame`, я всё время вспоминал, что у нас есть ведь классный [Battery Status API](https://developer.mozilla.org/en/docs/Web/API/Battery_Status_API), который рассказывает о том, в каком состоянии наша батарейка. Оно даже работает и на ноутбуках. И в этот момент хочется всегда реализовать такую штуку, чтобы когда у тебя совсем мало батарейки, совсем уже садится, берёшь и отключаешь всё самое жрущие эту батарейку на своём сайте. И тогда тебе не придётся, например, закрывать Opera и открывать Safari, чтобы как-то получше было. Хотя, ты наверное уже так не делаешь, у вас же там новый режим появился. Веб-технологии на таком стыке, они мне кажутся очень интересными, когда ты прямо до железки дотягиваешься.

**Вадим.**
_Фулстык_-разработчик. Ладно, давайте дальше, там есть ещё [Service Worker Streamed Responses](https://developers.google.com/web/updates/2016/06/sw-readablestreams). Грубо говоря, это такая штука, которая позволяет не дожидаться конца передачи данных, которые вы запросили в вашем Service Worker, и начинать обрабатывать их тут же. Мы привыкли к тому, что HTML-страницы начинают рендериться, даже пока длиннющая портянка не загрузилась целиком, браузер пытается рендерить с самого начала, тоже самое хорошо бы было делать с данными, потому что тот же самый Fetch, которым все пользуются, дожидается получения всех данных и только тогда начинает их обрабатывать. С этими потоками в Chrome 52 можно будет начинать обрабатывать данные заранее. В общем, как я уже говорил, там есть три статьи на эту тему: в каждой более подробно объясняется, что там нового.

## Safari и MathML

**Лёша.**
И на этой неделе как обычно, как и две недели назад, показали следующую версию [Release Notes for Safari Technology Preview Release 9](https://webkit.org/blog/6800/release-notes-for-safari-technology-preview-release-9/), в котором, как и в предыдущем, не так много интересного. Они, конечно, фиксят большое количество багов. Но чтобы сказать, как прошлые разы: «Теперь в Safari поддержка ES6 или, там, Grid», нет, ничего такого взрывающего, но тем не менее они шлифуют свой браузер, они его улучшают. Не знаю, что из этого всего перейдёт в релиз Safari, который будет где-то в сентябре или в октябре. Хотелось бы конечно всё, но есть ощущение, что перейдёт не всё.

И есть такая испанская компания Igalia, и как-то так получается, что она для Safari делает крутые штуки. До этого они законтрибьютили поддержку Grid в Safari. Это не сама компания Apple сделала, а эту поддержку предложила отдельная компания, которая занимается консалтингом. И тут они решили продолжит свой путь, и переписать [Improvements in MathML Rendering](https://webkit.org/blog/6803/improvements-in-mathml-rendering/) в Safari. И вот мне немножко странно, потому что я вот эти штуки в вебе вижу на всём протяжении моей работы, и никогда не понимал, зачем они нужны. Ребята, вы же тоже наверняка часто слышали про такую штуку, как MathML, и что там можно делать какие-то формулы математические, но вы применяли это когда-нибудь в своей жизни, на практике?

**Оля.**
Но это очень важная вещь, если ты набираешь какие-нибудь учебники или пособия, что угодно обучающее. Кстати, Лёша, тебе должно быть это очень близко по математике. Набрать формулы в вебе, а не в PDF, это очень трудно. Поэтому я только рада, что эти технологии как-то развиваются.

**Вадим.**
Мы ещё сегодня будем говорить про образование, и что должен знать верстальщик и разработчик, и в частности там упоминается математика. Но это ближе к концу выпуска. А так все случаи, когда я вижу формулы в вебе, в 90% это какой-нибудь растр, скриншот из какого-нибудь математического софта, или в лучшем случае это SVG, когда кто-то просто экспортировал ту же самую графику, но в удобный векторный формат, чтобы нормально выглядел. MathML предлагает нам специальный XML-подобный язык, как HTML и SVG, который позволяет описывать формулы. И, на самом деле, все среды, в которых можно писать, конструировать эти формулы, позволяют экспортировать в нормальный MathML.

И совсем недавно был на эту тему пост [MathML is a failed web standard](https://www.peterkrautzberger.org/0186/), про то, как рабочая группа, которая занималась MathML, а точнее, человек, который принимал в этом участие, сказал, что как-то у нас ничего не получается и мы провалились с MathML. И тут раз, видимо, по мотивам всего этого Igalia и WebKit объединились и получилась у нас обновлённая реализация MathML.

Объясню, в чём вообще фишка. В HTML мы всё рендерим 16-пиксельным Times, синие ссылки, и как бы всё просто. Базовый дефолтный рендеринг страницы довольно простой. И мы все видели, что дефолтные браузерные стили, это конечно длиннющие портянки, но ничего сложного в этом нет. С MathML всё немножко сложнее. С самого начала в браузере есть определённые конструкции, которые описывают, как рендерить MathML. Математически язык довольно сложный, я имею ввиду язык записи формул. Там очень много вещей, которые могут испортить читабельность, если отрендерить неправильно. И в текущем виде формулы рендерить довольно плохо: элементы наезжают друг на друга. Довольно-таки сложные комбинации. Вы посмотрите на картинке, там всё очень не просто. Это не просто какие-нибудь несколько линий, набранные Times. Очень сложная комбинаторика элементов. Её нужно по умному рендерить. И там десятки-сотни случаев сочетания этих элементов. Так вот, одно из главных улучшений поддержки MathML в WebKit сейчас — это именно эта комбинаторика, когда элементы выглядят по-человечески, читабельно, и эти формулы можно просто анализировать, а не пытаться разобраться, мол, господи, что там написано.

Ещё внутри MathML появились ссылки, это довольно интересно, потому что до сих пор, по-моему, атрибута `href` не было, и отдельным элементам нельзя было задать ссылки. Я не уверен, зачем они внутри формул, наверное это полезно, но сама возможность, что в одной из веб-технологий наконец-то появилась возможность добавлять ссылки (в SVG их тоже можно добавлять) — это очень хорошо. То есть, если математика вам близка, почитайте про то, как Apple рассказывает об этом в своём блоге. В общем, ситуация налаживается, и мне кажется, с точки зрения образования, с точки зрения нашей отрасли, знание математики важно, и поддержка правильного отображения формул, это тоже поможет в образовательном смысле, потому что веб — самая главная мировая издательская платформа. И если там не поддерживается математика, значит это удар по математике, который нельзя допустить.

**Лёша.**
Это точно крутая спецификация, очень здорово, что она наконец-то как-то возрождается. Просто, я ещё раз повторюсь, я до этого применения для MathML в интернете не видел вообще. Когда были сайты с формулами, ты абсолютно правильно сказал, это всегда были картинки.

**Оля.**
Ну, значит будущее наступит рано или поздно.

**Вадим.**
Ну да, это правильное движение, даже несмотря на то, что есть какой-то кризис в этом MathML-сообществе и в спецификации, всё равно правильный рендеринг всё поможет выпрямить.

## `font-display` в Firefox

**Лёша.**
Оля сейчас замечательную фразу сказала, что: «Будущее скоро наступит». И вот тут как раз про `font-display` неутомимый наш Зак продолжает свои исследования со шрифтами. И когда он написал свой пост, про который мы говорили в прошлом выпуске, он начал дальше исследовать и играться со свойством `font-display` и абсолютно случайно наткнулся на то, что… Точнее, к нему ребята из Mozilla пришли и сказали, что вообще-то у них [это свойство поддерживается](https://github.com/zachleat/zachleat.com/issues/9). Он такой: «Да ладно?» Потому что ни на каких сайтах о поддержке не было написано, что это свойство поддерживается где-либо кроме Chrome за флагом. И как оказалось в Firefox действительно уже сделали реализацию, в Firefox 46, в Firefox 48 Beta, т.е. они её наверняка улучшают, но эта реализация до сих пор находится за флагом. Вы её можете найти там по словам _font-display_, включить и начать играться. По крайней мере тестировать то поведение работы со шрифтами, которое у вас будет через какое-то время. В принципе, если сейчас эта поддержка начала появляться, у нас уже есть Chrome, Opera, вот и Firefox есть. Было бы круто, чтобы и в Safari появилось, хотя я очень сомневаюсь, что этой осенью мы её увидим. Тем не менее, как вариант такого прогрессивного улучшения, мы сможем использовать `font-display` и на большинстве сайтов в большинстве браузеров, мы не будем писать какие-то костыли для загрузки шрифтов. Это очень круто, но забавен тут ещё тот факт, что у Mozilla есть сайт [Firefox Platform Status](https://platform-status.mozilla.org/), где они рассказывают над чем они сейчас работают, над чем думают, что практически сделано, и так далее, где можно было бы посмотреть статус `font-display`, если бы этот сайт не лежал. К сожалению, не работает.

**Вадим.**
Ну, мало того, что он лежит, так там ещё и нет этого `font-display`. И об этом собственно не говорят в этом тредике на GitHub. Так что, когда они его поднимут, они наверняка его добавят, потому что уже речь пошла.

**Лёша.**
Так наверняка упал сайтик то из-за этого.

**Вадим.**
А, то есть, такой деплой длиной в сутки?

**Лёша.**
Конечно.

**Вадим.**
Что интересно, этот `font-display` по-моему даже не найти по слову `font-display` в настройках About Config в Firefox. Они его там спрятали за двумя подушками и нужно ещё догадаться как его включить.

**Лёша.**
Они в Firefox 48 Beta уже поправились, там уже можно найти. Раньше нельзя было, да.

**Вадим.**
И если говорить про `font-display` в других браузерах, в Safari уже внедрили Font Loading API, поэтому виден интерес со стороны разработчиков WebKit, чтобы шрифты правильно грузились и обрабатывались. Возможно они пойдут дальше и сделают не только JS-реализацию, которая улучшает загрузку шрифтов и помогает нам, но и ещё нативно в CSS.

А ещё эта реализация в Firefox важна тем, что это независимая реализация, т.е. мы можем говорить про Chrome, Opera и Яндекс.Браузер, что у нас есть 3 браузера, которые поддерживают, но по-хорошему, это реализация в движке Chromium. На самом деле какой-то код может быть скопипастен из Chromium в WebKit, это нормально, и так многие реализации на самом деле и были сделаны, например `<picture>`, Grid Layout по-моему всего одна реализация, только с нюансами внедрения. С независимыми реализациями другой платформы, это всегда очень интересно, потому что начинают всплывать нюансы, т.к. это совсем другой код и он может вести себя иначе, и благодаря этому спецификация может уточняться. Статусы спецификации W3C: кандидат в рекомендации, черновики, и вот это всё — они зависят от независимых реализаций в браузерах. Поэтому эта хорошая новость, что в Firefox нашёлся `font-display`.

## Будущее WebP и WebM

**Вадим.**
На этой неделе CNet рассказал про то, что [Apple тестирует формат графики Google](http://www.cnet.com/news/apple-ios-macos-tests-googles-webp-graphics-to-speed-up-web/). Естественно, они рассказали это в терминах, которые будут понятны какому-нибудь бизнес-сообществу или людям незнакомым с веб-технологиями. Но для нас это звучит так: в WebKit будет скорее всего поддерживаться формат WebP. WebP — это такой контейнер, в котором нет привычных нам разделений, например, между GIF, PNG, JPEG, поскольку у них всех разные модели. Внутри этого контейнера есть всё. Там можно сделать анимацию. Там можно сделать полупрозрачность. Туда можно засовывать фотки, иконки, всё что угодно. Вы сами можете сказать ему сохранять с потерями или без потерь, с каким уровнем потерь и т.д. Но если говорить про что-то вроде JPEG, то WebP эффективнее, чем JPEG на 20-30% при том же визуальном качестве. В WebP используются другие алгоритмы, потому что JPEG уже дедушка и есть более прогрессивные и интересные вещи. Вот такой формат. Сейчас он работает исключительно в браузерах на основе Chromium. Новость про то, что Apple, большая шишка в мобильных браузерах, собирается внедрить его в Safari — это очень хорошая новость. Настолько хорошая, что на эту тему даже высказался Firefox.

**Лёша.**
Ну, как Firefox — Mozilla. И сказали они, что это очень здорово, они следят за прогрессом, и что если вдруг в Safari появится поддержка WebP, то они такие «хэй-хэй» сделают её тоже. И вот этот момент достаточно странный, потому что ребята из Mozilla говорят ровно следующее: мы вроде как можем сделать поддержку, но мы не будем её делать, пока кто-нибудь ещё помимо Google не сделает её в своём браузере, мы не хотим быть вторым браузером, который реализует поддержку этого формата. Мне кажется, что это какая-то странная политика. Откуда это вдруг в такой замечательной компании как Mozilla?

**Вадим.**
Ну тут сложно сказать, наверное это исторические причины. Потому что, насколько я помню, Mozilla всё время предлагает свои супер-открытые форматы. Хотя WebP и WebM открытые, там вполне себе адекватная лицензия, чтобы все могли внедрить их у себя. Но Mozilla в какой-то момент, года 3 назад пробовала внедрить у себя WebP, точнее смотрела — да-нет, нет-да. И решила вместо этого улучшать JPEG. Они работают с разными форматами графики. Там ещё был APNG — анимированный PNG. В общем они немножко упоролись по открытым форматам и почему-то им показалось, что идти вместе с крупной корпарацией Google было плохой идеей. В итоге мы все придём к тому, что формат нормальный, и все браузеры его внедрят.

Кстати, очень интересная ситуация, что Safari экспериментирует с WebP — Web Picture, то есть, для картинок. Edge экспериментально добавляет поддержку WebM — Web Media, именно для видео. Firefox вообще ничего не делает (на самом деле [Firefox поддерживает WebM с 28 версии](http://caniuse.com/#search=webm), _прим. редактора_). А браузеры на основе Chromium — и в WebP, и в WebM. Суть в том, что внутри каждого формата работает один и тот же механизм. Для кодирования WebM используется кодек VP9, тот же самый кодек используется для картинок. По сути, если в вашем браузере уже внедрили WebP или WebM, то сделать недостающий формат не составляет сложностей. Поэтому глядя на Edge и Safari думаешь: наверное им нужно сделать ещё один рывочек и тогда у всех будут новые форматы.

**Лёша.**
Знаешь, мне кажется, что с браузерами этого совсем недостаточно для поддержки этих форматов. Во-первых, это нужно каким-то образом продать разработчикам. Я уверен, что Оля не заморачивается никакими новыми форматами графики. Да, Оля?

**Оля.**
К сожалению, не заморачиваюсь. Хотя недавно встала такая задача: давайте оптимизируем нашу графику, она какая-то тяжёлая. Но у всех этих новых веяний очень слабая поддержка, именно для продуктовой разработки. Потому что 3 современных браузера — это конечно хорошо, а все остальные? Сейчас много кто не обновляет свои Safari и другие браузеры, поэтому приходиться поддерживать какие-то предыдущие версии. Я всё время думаю об этом и когда мне надо внедрять одновременно и новую технологию, и какую-то старую для того, чтобы поддерживались предыдущие версии браузеров, я понимаю, что это вообще не рационально с точки зрения времени разработки и моих усилий, поэтому просто всё оставляю как есть.

**Лёша**. Вот! По сути нужно, во-первых, разработчикам это продать, им нужно объяснить, почему хорошо использовать `<picture>` — потому что по другому же никак. Им и правда нужно много разных форматов поддерживать. Но, во-вторых, помимо браузеров есть ещё одна проблема: у нас графические редакторы не готовы. Где экспорт из Photoshop или из Sketch в WebP? Как с этой графикой работать? Только этими странными инструментами конвертации из JPEG в этот формат? Это же странный путь. Нам не только браузеров не хватает, нам в принципе инфраструктуры не хватает для этого нового формата.

**Вадим.**
Это правда. Хотя есть плагины для Photoshop. По-моему Sketch сам по себе не умеет, но наверняка для него тоже можно написать какой-то плагин. Да, отрасль не восприняла до конца, что нам это нужно. И возможно движения со стороны Apple, со стороны Mozilla и кого-нибудь ещё помогут нам в этом.

**Лёша.**
Но все точно видят, что с тяжёлой графикой нужно что-то делать, а она есть у всех на больших сайтах. Представяете, если у вас гигантский сайт, то у вас идёт огромное количество трафика, который хочется оптимизировать.

И этим занялись ребята из Dropbox. Они сделали свой собственный [движок для компрессии изображений Lepton](https://blogs.dropbox.com/tech/2016/07/lepton-image-compression-saving-22-losslessly-from-images-at-15mbs/), который позволяет сжимать их JPEG на 22%, при этом формат вроде остаётся JPEG. Я ведь правильно понял? У них там такая сложная, инженерная статья, в которой они рассказывают, как они это делают.

**Вадим.**
По-моему, принцип такой, что они проанализировали имеющийся JPEG и пытаются предсказывать какой следующий сектор этой матрицы JPEG будет, и благодаря этому сохранять дополнительные данные и уменьшать размер JPEG. Там используются какие-то очень сложные математические модели, но суть в том, что они просто пытаются сохранить место на серверах. Они экономят петабайты жестких дисков, трафика и всего остального. В общем это их внутреннее решение и мы написали новость не потому что это какой-то супер-фронтенд, а потому что это одна из областей, о которых стоит думать. И даже если вы работаете простым верстальщиком, вы всегда можете прийти к своим сисадминам и сказать: «А вот ребята из Dropbox сэкономили кучу трафика с помощью этого Lepton. Давайте мы тоже так сделаем.» Наверное такие решения нужно приносить своим дизайнерам, сисадминам и менеджерам.

**Лёша.**
Дизайнерам наверное страшно будет. Ты сказал, что это их внутреннее решение, только нужно сказать, что они выложили его в опенсорс. И в принципе вы его тоже можете использовать у себя.

**Вадим.**
Да, если для вас это действительно стоит того, то это может быть хорошим решением. Но говоря про форматы графики хочется заметить, что как и в случае со многими вещами веба, в принципе это всё можно прогрессивно улучшать довольно удобно. Допустим, когда я готовлю какие-то видео для статей в Opera, я всегда конвертирую их в H.264, поскольку в этом формате работают все видео-редакторы, которые я использую. А потом быстренько прогоняю через ffmpeg и делаю из него WebM, а потом вставляю на страницу элемент `<video>` с двумя `<source>`: первый — WebM, второй — H.264. В итоге получается, что браузеры, которые могут прочитать WebM, они получают его. То же самое можно ведь делать с элементом `<picture>` — вы можете указать его, а там положить два `<source>`, первый из которых — WebP. И в итоге браузеры, которые умеют WebP — прочитаю, а которые нет — получат свой JPEG. Эта сложность приводит к тому, что это всё-таки немножко инфраструктурная задача и простой верстальщик скорее всего не сможет её решить, потому что JPEG — главный трафик на сайтах. И скорее всего, это User Generated Content, который верстальщик не контролирует, он через него не проходит.

Если вы делаете какой-нибудь большой `hero banner` для вашей страницы, вы скорее всего действительно можете закодировать его в WebP, потом подложить там JPEG, и сфолбэчить ещё на что-нибудь, если хотите. Например, какой-нибудь JPEG 2000 подсунуть для браузера, который знает, что это такое. Но с контентными нужно конечно серьёзное решение техлидов и сисадминов, которые будут генерировать 2 версии картинок. Но если посчитать, то действительно можно сэкономить. 20-30% — это серьёзно.

**Оля.**
Ну, на самом деле, чаще всего речь идёт о 22 версиях картинок, потому что у нас есть ретина, у нас есть разные размеры. Например, для одной и той же статьи есть разные форматы размеров фотографий (их кадрирования под разные вьюпорты, _прим. редактора_). Их тысячи! И это проблема, что в продуктовой разработке бывает очень сложно принимать какие-то новые решения.

**Вадим.**
Да, наверное, всё-таки стоит дождаться задачи или понимания, что мы хотим сэкономить трафик. И, поскольку у вас уже есть система генерации разных версий картинок, наверное туда ещё воткнуть генерацию WebP не так сложно.

**Лёша.**
Даже так: когда у вас сервис уровня YouTube и вы понимаете, что 10% трафика выходят вам в огромные деньги, то эти деньги вообще-то можно потратить на то, чтобы заставить разработчиков делать графику в 2 раза дольше. Ничего страшного, зато экономия денег будет просто гигантская.

**Оля.**
А хранение? Место ведь нужно, чтобы хранить все эти 22 фотографии.

**Лёша.**
Смотри, одно дело хранить 22 фотографии, а другое — эти фотографии раздавать миллионам пользователей. Ты представляешь сколько раз их нужно будет отдать? Мне кажется совсем ничего страшного, тем более диски дешёвые.

**Вадим.**
Ладно, мы потихоньку заползаем на территорию, в которой мы все немножко не разбираемся, поэтому давайте сделаем вид, что всё так и надо и перейдём к следующей теме.

## Зачем HyperTerm?

**Лёша.**
Да. Следующая тема шикарная, она ведь про терминал, в котором мы вроде как не разбираемся. Но этот терминал написан на веб-технологиях. Поэтому теперь у нас будет ещё одно умение. Мы уже умеем писать редакторы, потому что в Atom можно залезть с помощью наших любимых веб-технологий. Теперь у нас появился замечательный терминал, который называется [HyperTerm](https://hyperterm.org/), в который мы тоже можем воткнуть наш CSS и HTML-код, с помощью JS можем сделать этот терминал таким, как нам хочется. Разве не об этом вы мечтали, ребята?

**Вадим.**
Кстати, в Facebook предложили назвать его HypeTerm, а не HyperTerm. Потому что самое модное теперь и в терминале.

**Лёша.**
Конечно, там ведь React тоже. Всё нормально.

**Вадим.**
Господи, там ещё и React!

**Лёша.**
Да! Ты не знал?

**Вадим.**
Окей, точно HypeTerm.

Меня всегда немножко доставало, что редакторы, которыми я пользуюсь, они используют какие-то свои адские форматы для настроек. Я помню в TextMate были огромные эксэмэлины в эппловском формате `.plist`. И для того, чтобы настроить какой-нибудь свой плагин, или когда вы только начинали писать zen-coding (он был только для TextMate) — приходилось творить страшные вещи, изучать неизвестные форматы, неэффективные и неудачные. Вот когда начали появляться все эти штуки на веб-технологиях, я вдруг начал понимать, что тему для подсветки можно написать на обычном CSS. Кстати, был такой редактор Espresso, для него тему можно было написать на CSS. Автор предлагал специальный набор селекторов, которые выбирали определённые части кода и можно было писать свою тему на CSS. Это довольно удобно. То же самое с Atom. То же самое с этим HyperTerm. Мы получаем лёгкую настраиваемость. Чем проще настраивать что-то, тем больше вариаций будет, и тем удобнее сообществу поддерживать какой-то продукт. Тем более, если раньше нужно было отрастить свитер и бороду, чтобы пользоваться терминалом, то теперь я видел дизайнеров, которые пользуются терминалом. Такая эпоха, что HyperTerm — это то, что нам нужно сейчас.

**Лёша.**
Оля, а ты видела его? Красивенький ведь?

**Оля.**
Нет, не видела, потому что не вижу смысла использовать какие-то сторонние решения. Есть же встроенный в macOS терминал, и мне его вполне хватает.

**Вадим.**
Вот, я тоже так думал. Я всю жизнь прожил на встроенном в Mac OS терминале. А потом в какой-то момент подумал: ну, все же пользуются iTerm, чем я хуже? Я стал пользоваться iTerm, а потом вернулся в Terminal, потому что понял, что там всё примерно то же самое. Но по одной фиче я скучал — это возможность с зажатым `Cmd` кликнуть на ссылку, на файловый путь, который отображается где-либо — и он открывается прямо в Finder. Вот это слишком круто, чтобы без этого жить. Потому что очень часто приходится с файлами взаимодействовать не только из командной строки. В итоге я снова вернулся на iTerm. И это на самом деле единственная фича, которой я пользуюсь из тех, которых нет в обычном системном терминале.

**Лёша.**
Оля, ты сказала: зачем, есть же системный. Но ведь у тебя же в твоей macOS есть системный редактор, какой-нибудь Vim или Nano. Почему ты им не пользуешься? Почему ты взяла красивый редактор себе и наверняка настроила его как-нибудь так, как хочется?

**Оля.**
Потому что у редактора есть какие-то очевидные плюсы и возможности, которых нет во встроенных редакторах. Извини, пожалуйста, я не знаю, какого размера бороду и свитер надо отрастить, чтобы использовать Vim! Просто мне это не дано. А встроенный, который в Xcode — он какой-то бесчеловечный совершенно.

А все эти терминалы. Я тоже пользовалась iTerm, и как-то я не поняла, зачем он нужен, потому что видимо мне не нужны какие-то дополнительные функции. Я не знаю, может я просто ленивая. Мне лень изучать, а что там есть хорошего, а вдруг мне это пригодится. Мне и так нормально.

**Лёша.**
Знаете, в HyperTerm, как это не странно, нет ничего сверх-естественного. Там просто идея новая. Точнее не новая, старая. Она такая же как в Atom. Идея в том, что мы делаем программу с помощью веб-технологий. И ты с помощью веб-технологий можешь делать, что угодно с этой программой. Если бы у тебя было время и желание сделать терминал таким, как тебе хочется, таким, как ты представляешь себе его, то ты его можешь кастомизировать очень просто. Ведь кастомизация терминала обычного — это такой, знаете, небольшой ад. Это нужно обладать большими знаниями, то есть большой бородой. Тут же тебе нужно знать те же самые HTML, CSS и JS. И всё. Вообще, когда этот проект зарелизился, вокруг него собрался на самом деле большой хайп. Не такой большой, как в Pokémon GO, но тоже большой. И ребята все кинулись, начали разрабатывать разные плагины, темы. Даже успели разработать свой собственный Package Manager. Ну, а как всеми этими плагинами управлять, если не с помощью Package Manager. Напридумывали темы как в «Матрице», что у тебя всё зелёненькое. Плагины придумывали такие, что, когда ты пишешь, твой курсор как будто взрывается, то есть впечатывает код прямо в терминал.

Но это конечно веб-технологии, они жрут память, это да. Но мы же живём как-то с Atom. Мне кажется, что и с этим терминалом многие будут жить и радоваться.

**Оля.**
Знаете, у меня, честно говоря, эта последняя тенденция «напишем всё на веб-технологиях» вызывает в голове присказку: «Почему кот хвост лижет? Потому что может.» То есть, никакого смысла особого в этом по-моему нет, просто люди могут и люди делают. Ну окей. Не знаю, сейчас я не вижу, чтобы это могло бы быть полезным.

**Вадим.**
Веб-разработчики создают инструменты для самих себя. А на чём мы можем создавать инструменты для самих себя? На веб-технологиях. Поэтому такие штуки и появляются. Когда какие-нибудь сишники или джависты создают инструменты для себя — они пишут их на C и на Java. А мы можем писать на другом. Кто лучше нас знает, какие нам нужны инструменты? Мы сами. Поэтому давайте делать их на веб-технологиях и не стесняться.

**Лёша.**
Вспомните, кстати, про инструменты автоматизации. Ведь до Grunt и Gulp, до того как мы их начали писать на JavaScript, вообще-то инструменты автоматизации были. Я понимаю, что не все этим занимались, но я этим занимался. Мы писали автоматизационные вещи для нашего фронтенда на абсолютно других языках. На чём угодно. С помощью make-файлов на Ruby, на Java. Использовали их механизмы для создания таск-раннеров. Кололись. Было тяжело. Нам приходилось знать какие-то параллельные языки для того, чтобы просто сжать код, объединить его, и так далее. А потом появились Grunt и Gulp — и взрывной рост автоматизации. Потому что дали людям инструмент тот, который им привычен. Им не нужно ничего учить нового. Тут, мне кажется, вполне может сыграть такая же штука.

## Книги

**Вадим.**
У «Веб-стандартов» кроме новостей и того, что вы все видите, есть ещё сайт. Немножко старенький, но мы над этим работаем. И на этом сайте есть [раздел где мы рекомендуем книги](http://web-standards.ru/books/). Когда-то мы за ним следили, но сейчас он немножечко покрылся пылью, но в принципе его можно освежить, если вам интересно. Так вот, книги до сих пор издаются и существуют. И в принципе даже хорошие. И если раньше выходили всякие библии, которые домой было тяжело из книжного магазина вынести, то сейчас пришла пора книг не таких монолитных, не таких тяжелых. И в частности, одна из самых любимых мною серий называется A Book Apart, её сделали ребята из A List Apart — одного из самых старейших и уважаемых издательств и вообще сайтов в интернете на которых мы все учились, у меня даже пара футболок есть. Они уже давно издают серию A Book Apart и сейчас выходит очередная [книга про SVG](https://abookapart.com/products/practical-svg), её написал Крис Койер, довольно известный персонаж по CSS-Tricks и CodePen. Думаю он написал хорошую книгу. Внимательно следите когда она будет выпущена, A Book Apart обычно выпускает бумажную версию за 15 $ и электронную — за 9 $, вместе дешевле, но в общем я очень рекомендую вам скачать ePub-версию как минимум, потому что это хорошо оформленные книжки с примерами, с ссылками, и от авторитетных авторов.

А ещё на этой неделе [Akamai](https://content.akamai.com/pg6293-high-performance-images-ebook.html) упомянутый сегодня с O’Reilly выложили [черновик книги про High Performance Images](https://www.akamai.com/us/en/multimedia/documents/content/e-book/akamai-oreilly-high-performance-images-e-book.pdf) от известных авторов, включая Йоава Вейсса, который собственно написал реализацию `<picture>` и лучше всех в нём разбирается. На самом деле оригинальная новость ведёт на форум, где нужно заполнить: где ты работаешь, что ты делаешь, что ты ел на завтрак, и так далее. Но сразу после этого вам на почту приходит ссылка на PDF, и вот её мы выложили прямо в новости, чтобы не тратить ваше время. «Веб-стандарты» — экономим ваше время, ха-ха. Так вот скачайте книжку, посмотрите, там не просто пара страница-превьюшечка, а там вполне себе чуть ли не целая книга, но видимо просто в черновом статусе.

## Путь фронтендера

**Оля.**
На этой неделе у нас в топе замечательная статья из трёх частей автора Ильи Климова — «Frontend Dev: [хороший](https://medium.com/p/865b640d5d18), [плохой](https://medium.com/p/aa99f3ce376), [злой](https://medium.com/p/5a4ec66fd457)». Интересная трилогия, если можно так выразиться. О пути разработчика, грубо говоря. О хорошем пути, о не очень хорошем, и о совсем плохом. На самом деле третья часть меня очень расстроила. Я потом расскажу почему.

Так вот. В первой части, как можно догадаться, речь идёт о хорошем пути развития для разработчика. Он предполагает, что ты учишься в техническом вузе, изучаешь серьёзные языки программирования, ну и потом как-то переходишь в разработку. Во второй части статьи рассматривается якобы плохой путь, который направлен в первую очередь на заработок. Если ты хочешь заработать, но ничего не знаешь — что тебе нужно изучить и сделать в первую очередь, чтобы как-то войти в мир веб-разработки. Посыл забавный — настоящие программисты только хорошим путём получаются. А все остальные — не очень настоящие. Тем не менее, там достаточно много хороших рекомендаций, что именно изучать, как изучать, в каком порядке. Опять же там затрагивается тема менторства, о которой мы уже много говорили. Забавно и интересно. В общем, рекомендую ознакомиться.

А вот третья часть… Она такая, грустная. Потому что это практически моя история. И наверное эта история довольно многих людей, которые начинали в веб-разработке в те же времена, когда начинала я. Что делать, если ты пришёл в веб из совсем других отраслей, если ты экономист, филолог или кто-то ещё, или не дай Бог тебе 30+ лет. Автор как-то так не очень позитивно отзывается о том, что это путь не закончится ничем особенно хорошим. Тем не менее, опять же, там даны неплохие рекомендации, как начать с нуля и прийти к чему-то. Там ссылка на статью, про которую мы тоже рассказывали — [From Zero to Front-end Hero](https://medium.com/p/7d4f7f0bff02). Короче, не знаю. Вот Вадик например тоже ведь с образованием журналиста. Я по образованию издатель и редактор. Но тем не менее как-то пришли в веб, чего-то добились, как-то работаем. Поэтому не надо воспринимать негативный посыл. Надо воспринимать советы, которые там даются. И я думаю, что у вас всё тоже получится.

Но грустно мне стало ещё и по той причине, что в этой трилогии статей подтверждаются какие-то мои собственные ощущения, что программистом можно стать, если подходить всё-таки к делу серьёзно и фундаментально. Ну либо если у тебя есть действительно какая-то склонность к техническим делам. Потому что я вот гуманитарий. Такой прямо совсем гуманитарий. И сколько я уже в вебе работаю? 11 лет. Я до сих пор не научилась программировать. Ну то есть я чего-то там могу на jQuery или даже на чистом JavaScript туда-сюда наваять, но это не программирование. И меня каждый раз убивает, что у меня нет какого-то системного фундаментального технического мышления, которое позволяло бы мне научиться нормальному программированию. И я боюсь, что в мои 30 лет уже поздно с этим что-то делать, если не идти учиться. Ну вот не знаю. Ребята, вот что вы думаете?

**Лёша.**
Я думаю, что учиться никогда не поздно.

**Вадим.**
Ну это всё понятно. Да, учиться никогда не поздно. И мы каждый день немножко учимся. Вопрос наверное в другом. Вопрос в том, что читая такие статьи или подобные высказывания про JS, про эти серьёзные бэкграунды в C, про то, что конечно нужно регулярно изучать новые языки, то возникает ощущение, что веб-разработка и фронтенд — это то, где нет места тем, кто не знает вообще ничего о хардкорном программировании, основах и алгоритмах. Мы все понемножку знаем, и все что-то делаем в этой профессии. Мы наверно не можем быть какими-то там Senior jQuery Plugin Архитекторами, мы не можем быть какими-то серьёзными разработчиками, которые консультируют. Но мы можем выполнять свои роли. Наверно лучше, чем другие. Потому что мы можем видеть не только один мир. Мы видим не только алгоритмы. Мы видим ещё мир интерфейсов. Мы можем говорить про типографику. Мы можем создавать интерфейсы, которые удобны. И это тоже фронтенд, и это тоже веб-разработка. Эта третья часть трилогии очень честно и очень хорошо написана. Это такое откровение. Мне очень понравилось. Но не стоит воспринимать это, как единственный источник правды. Во фронтенде можно заниматься разными делами. И если у вас душа не лежит к математике и алгоритмам, но вам интересно заниматься веб-технологиями — вам есть, что ловить.

**Оля.**
Я уже который год мучаюсь опасениями, что вёрстка в чистом виде изживёт себя. Потому что появляются какие-то такие разработчики, которые вроде как и JS, и вёрстка, и на React чего-то налабать могут, где мало чего надо знать про вёрстку. Но я периодически сталкиваюсь с такими разработчиками и вижу, что они не в состоянии сверстать какие-то действительно сложные вещи, интерфейсы или даже лэндинги. Понимаете? Поэтому пока что мне кажется, что как минимум какое-то время ещё профессия чистого верстальщика, она будет востребована. Ну, я на это надеюсь.

**Лёша.**
Она точно будет востребована. Потому что либо у нас веб сильно изменится и у нас будут супер-JavaScript-приложения, построенные все на Bootstrap. Потому что ребята же не хотят учиться верстать. Кто будет верстать? Никто! Значит мы будем делать из готовых компонентов. То есть у нас будут либо сайты на Bootstrap, либо сайты на bem-components.

**Вадим.**
А кто будет делать готовые компоненты?

**Лёша.**
Понимаешь, они уже готовы.

**Вадим.**
Ах, ну да, сразу.

**Лёша.**
Можно использовать старый второй Bootstrap. Чего, какая разница? Он же работает. И всё. То есть, это вот такой мир, идеализированный JavaScript-разработчиками, как мне кажется. И мне кажется, что он очень далёк от правды. Потому что никто никогда не захочет делать типовые сайты. Самое важное в сайтах, в интернете — это визуальная составляющая, то, что мы видим. И это, простите, не JavaScript. JavaScript добавляет интерактивную составляющую, а визуальную составляющую добавляет CSS. Если мы вдруг все дружно забудем, как его писать, то это не будет хорошо. Заказчики хотят, чтобы их сайт выглядел хорошо, лучше, так, как им кажется. Дизайнеры хотят рисовать сайты, как у них там мысль пойдёт и так далее. Они не хотят его рисовать в рамках какого-то компонентного подхода, или Bootstrap и так далее. Все хотят придумать, что-то новое. Это же творческая профессия, всё это IT в вебе. Поэтому мне кажется, что верстальщики никогда не умрут. Другой вопрос, на сколько нужен чисто верстальщик без JS-знаний. Вот тут можно дискутировать. Мне кажется, что JS-знания конечно же нужны всегда, обязательно всем, хотя бы на базовом каком-то уровне. Но мне кажется, чисто JavaScript-разработчики не вытеснят всех остальных.

**Вадим.**
Ещё была мысль в этой серии статей. Убедите всех на собеседовании, что вы крутой. Поразрабатывайте немножко какие-то типовые проекты. Узнайте как делать Drag-and-Drop. Узнайте как сделать какую-нибудь бесконечную прокрутку и кастомный `<select>`. И тогда вы естественно сможете решать какие-то задачи конкретные. Моё предостережение: узнав это — не останавливайтесь. Я очень много вижу разработчиков, которые узнав, как работают типовые компоненты и получив хорошую зарплату и хорошую должность в компании считают, что они на вершине веб-разработки. И они называют себя Full Stack, они знают как собирать из кубиков конструктор и они получают свою большую зарплату, за то, что они решают типовые задачи типовых проектов. Но когда вам нужно создать саму эту систему, из которой вы собираете, когда вам нужно разобраться, почему ваш сайт медленно работает или как сделать что-то оригинальное и что не вписывается в контекст ваших типовых задач — в этом месте вы поймёте, что вы чего-то не знаете, чего-то не умеете. Поэтому быстро стартовав и получив хорошие деньги (в этом нет ничего плохого, на самом деле), не забывайте, что вы многого не знаете. И попробуйте пореже называть себя Full Stack разработчиком если вы не знаете, как написать селектор в CSS, если вы не знаете, как работают градиенты, если вы не знаете как работает Flexbox, чёрт побери.

**Оля.**
Ничего ты не знаешь, Джон Сноу!

**Лёша.**
Подождите, я хочу понять. Мы Full Stack разработчиками называем теперь не тех, кто умеет Frontend и Backend?

**Вадим.**
Понимаешь, в чём дело: full — значит full. В моё время таких людей называли эникейщиками. Это когда ты мог сделать вообще всё, запустить сайт и настроить сервер, поднять MySQL и убедиться, что PHP не древний и ещё шаблоны, простите, наговнякать на HTML и CSS. Сейчас такие ребята называют себя Full Stack разработчиками. Это значит, что они могут завести Node.js, они могут построить деплой, они могут написать на фреймворке какое-нибудь приложение, а как оно будет выглядеть — это тоже их забота, поэтому они берут либо готовые компоненты, либо что-то пишут на примитивном CSS и HTML. Поэтому да, Full Stack — это оно. Я когда делал доклад на OdessaJS, я открывал конференцию и в зале сидели вообще все, потому что один из докладчиков заблудился. И это была JavaScript-конференция все доклады были жутко джаваскриптовые, и я немножко нервничал. Первым делом я сказал: «Ребят, короче, я тут с вёрсткой пришёл, и мне вот интересно, кто из вас каждый день верстает на CSS?» Зал, забитый JavaScript-разработчиками — подняли руку больше, чем ⅔. Все эти Full Stack разработчики, гордые птицы, — пишут на CSS, в том или ином виде. Поэтому да, мало знать, как работает Bootstrap, мало знать, как работает ваш фреймворк, нужно разбираться в том, как работает CSS. А CSS, знаете ли, развития своего не сбавляет, мчится на полном ходу.

**Лёша.**
Я, кстати, в тему полного хода тоже хотел сказать, что вообще нет какой-то такой точки в развитии особенно в веб-технологиях, в которую можно прийти и сказать: «Ну всё, я справился с задачей. Я прочитал 3 учебника, я прошёл столько практических заданий. Всё, я готов.» Нет, тут такого нет. В вебе это поезд, который мчится далеко, он не собирается вообще останавливаться. Он мчится с каждым годом по-моему только прибавляя в скорости. И это не только в JavaScript. Это не только в браузерных API. Это и в CSS, и в HTML. Это во всём, во всех подходах. Постоянно всё меняется, добавляется новое, постоянно-постоянно-постоянно. Поэтому нельзя сказать, что вы наконец-то чему-то научились. Можно сказать только так, что вы продолжаете обучаться постоянно, постоянно развиваетесь. Потому что веб-технологии убегают очень вперёд, поэтому всё время нужно развиваться. Но при этом, если вы новичок — не нужно этого бояться. Может показаться, что этот поезд, он же уже проехал такое громадное расстояние, и как я на него успею на своей-то каталке, как я успею на своём велосипеде догнать его. Это же тяжело, но этого не стоит бояться, потому что на самом деле, большинство этого пути уже никому не нужно. Уже никто не помнит, как было, как мы разрабатывали несколько лет назад. Это были замечательные знания, которые определяли очень крутых специалистов, и которые сейчас можно так скомкать руками и выкинуть в окно, потому что они никому не нужны больше. Поэтому это не страшно. Новички могут успеть влезть на этот поезд, но опять же помните, что если вы влезли в этот поезд, это не значит, что всё, вы закончили.

**Вадим.**
Внутри этого поезда едет другой поезд и на него тоже нужно успеть.

**Оля.**
Слушайте, ну это Пелевин уже какой-то. Всё, перестаньте!

**Вадим.**
Ещё в этой статье был интересный момент про цинизм, про такую расчётливость, что мол вам не нужно знать HTML и CSS, возьмите фреймворк. Вам нужно решать конкретные задачи, поэтому возьмите и решите конкретную задачу, и убедите вашего работодателя, что вы сможете решать их на работе. И вот у нас в Слаке «Веб-стандартов» прозвучал вброс о том, что ну если я могу вместо кнопки сделать спанчик и не долбаться с оформлением этого спанчика со сбросом всех браузерных умолчаний, этих внутренних паддингов, внешних каких-то там рамочек, то мне же будет проще. У меня ведь интерфейс, который закрыт за админкой, куда попадают только люди, которые на десктопе, которых я знаю, и которые решают конкретные задачи. Зачем мне семантика?

**Лёша.**
Хороший вопрос, я считаю. Зачем, Вадим?

**Оля.**
На самом деле всегда есть какая-то точка выбора между твоей производительностью как разработчика и между правильным путём что-то делать. Ну действительно мне лично кажется, что надо соизмерять, что ты можешь, что ты хочешь и находить какие-то компромисы. Потому что даже семантика не должна быть самоцелью, прости меня Вадим.

**Вадим.**
Ну, у нас самоцель одна — чтобы то, что мы делаем работало хорошо и было удобно для пользователей. Мы в отрасли, которая занимается сервисом. Мы предоставляем сервис нашим пользователям. И если вы пришли в ресторан например, то вам естественно многие вещи сделают так, как удобно ресторану, как удобно официанту, как удобно заведению, чтобы не потратить слишком много денег. Но есть очень много вещей, которые сделаны для того, чтобы вам как гостю, вам как пользователю было удобно. Мы возвращаемся в заведение, где нам рады, где вещи расположены удобно, где нам удобно сидеть, удобно есть, удобно находиться. Вот наша задача сервисная. Мы должны больше думать о пользователях, чтобы они к нам возвращались.

**Лёша.**
Но ведь в вопросе, которым ты начал это обсуждение, он не противоречит тому, что ты сейчас сказал. Ребята занимаются сервисом. Тут ведь дело не в `<button>` и `<span>`. `<span>` точно так же работал бы как и `<button>`, то есть он бы предоставлял ровно ту же сервисную часть, что и `<button>`. Я напомню: это закрытая система, там скорее всего определили, что все эти пользователи могут работать с этим `<span>`, ну то есть — сервис предоставлен. Почему например разработчик вместо того, чтобы делать новые фичи и фиксить баги, должен заниматься доступностью ради доступности.

**Вадим.**
Смотрите. Есть такая логическая ловушка, в которую очень часто люди попадают. Представим, что у нас есть форма логина в закрытую часть. Где мы контролируем наших пользователей и всех знаем. Но эта форма логина не работает без JavaScript, в неё не попасть с клавиатуры и она ещё и не контрастная абсолютно. И люди абсолютно честно и справедливо говорят: «У нас нет пользователей, которые с клавиатуры, у нас нет слепых пользователей, у нас нет людей, которые плохо видят. Ну нет.» А знаете почему нет? Потому что они не смогли залогиниться.

**Лёша.**
Хорошо. Давай пойдём дальше. Давай представим, что на этой форме логина, ребята сделали всё хорошо. Но тем не менее у них не появились пользователи, потому что это узкий сервис, где ты знаешь каждого твоего пользователя. Там всё равно не появилось тех людей, у которых могут быть проблемы с кнопкой как `<span>`, или кнопкой как кнопкой. Ну то есть, по сути какая проблема кнопки как `<span>` — то, что по ней нельзя перейти табом и то, что её читалка не прочитает, верно?

**Вадим.**
Да.

**Лёша.**
Ну и допустим, что у нас нет людей, которые читают читалками сайт, потому что это вообще не сайт, там нет контента, это просто формочки — раз. А второе — то, что нельзя перейти табом. Ну допустим, что табом они и не пользуются, клавиатурой не пользуются. Давай предположим просто. Ну вот почему нужно тратить на это время, если ты знаешь, что твой пользователь не пользуется клавиатурой?

**Вадим.**
Ну, как мы сказали немножко раньше сегодня — ничего ты не знаешь, Джон Сноу. Мы предполагаем очень многие вещи на основе собственного поведения. Мы не пользуемся интерфейсами с клавиатуры и считаем, что наши пользователи — это мы. И как бы мы не копались в Google Analytics или в Яндекс Метрике, мы никогда не поймём до конца наших пользователей. Нужно предполагать, что мы не знаем нашего пользователя (и это будет максимально приближенно к правде), делать вещи, которые готовы ко всему.

Сейчас вот поднялся скандал небольшой на тему доступности интерфейсов ВКонтакте. Была [петиция](https://goo.gl/D79NWj) на Change.org, мол я пользователь, который не может нормально пользоваться ВКонтакте, я не вижу интрефейсов и я пытаюсь ими пользоваться с помощью экранной читалки, с помощью браузера. И я не могу, допустим, перейти на плеер, я не могу остановить воспроизведение. Лейблы какие-то не подписывают, какой это контрол. И так далее. То есть человек описал свою проблему. Представьте, что сейчас вы — обычный человек с руками и ногами, головой и глазами, нормальный — по какой-то причине не сможете попасть во ВКонтакте. Уйма вещей происходят прямо сейчас в соцсетях. Некоторые не заводят сайты, а просто делают событие во ВКонтакте. Некоторые магазины работают во ВКонтакте. То есть огромная часть жизни современного интернета и современного общества происходит в соцсетях. Будучи выключенным из этой соцсети, вы выключены из огромной части жизни. Потому что все предполагают: «Ну, у всех есть логин во ВКонтакте!» А ещё и такая проблема есть. Так вот, человек сказал: «Я не могу пользоваться важной частью нашей социальной жизни сегодня.» И была петиция, поднялся скандал. И [Слава Шебанов](https://vk.com/bysoul), который занимается интерфейсами ВКонтакте, не рассказывая особых подробностей, сказал: «Знаете, ребята, вот то, что мы не вложились в HTML-семантику, то, что мы использовали некоторые элементы не по назначению, и там какие-нибудь «диватоз» и «спанянка», — привело к тому, что наши интерфейсы недоступны. Если бы мы использовали элементы правильно — всё было бы лучше.»

**Лёша.**
Ну хорошо. Окей. Мы определились, что это в всё-таки важно, и этим нужно заниматься. Но есть другая проблема. Ты делаешь внутренний маленький сервис, не для всех. И давай представим, что ты тимлид-руководитель этой группы и тебе нужно, с одной стороны, выкатывать новые фичи, потому что тебе нужно вообще оправдывать свой бизнес, тебе нужно оправдывать своё существование вообще, почему ты тут есть. Тебе нужно выкатывать новые фичи. С другой стороны тебе нужно фиксить баги, потому что то, что ты выкатил раньше работает не так, как хотят пользователи, или просто есть фактические ошибки. Но ресурсов у тебя ограниченное количество. Ты и так-то не можешь выбрать между этими двумя вещами, чтобы сделать их все сразу же. А ты хочешь вставить сюда ещё отдельно доступность и семантику. Я правильно понимаю?

**Вадим.**
Я хочу вставить сюда здравый смысл разработчиков. Понимаешь в чём дело. Оформить кнопку так, чтобы она выглядела как `<span>` — это один сниппет. Ты можешь вынести его в какой-нибудь миксин, ты можешь его просто копипастить, ты можешь просто класс завести `button_off`и использовать его каждый день. И тогда никакого `<span>` у тебя не будет. Вы просто глобально оформите или просто добавите в ваши компоненты нужные стили. То есть, проблемы решить можно один раз. Мы разработчики, мы умеем оптимизировать, умеем избавляться от копипаста. Просто нужно больше в образование вкладываться, чтобы люди не приходили с неправильными концепциями в голове, чтобы люди не думали что «всё равно». Нет, не всё равно. Кнопка — это очень важно, для доступности вашего сайта. Причём доступность — это не автоматически какая-нибудь физиологическая травма. Доступность — это особенность чьего-то поведения. Доступность — это доступность с клавиатуры для людей, которые являются профессионалами и пользуются сайтами быстрее, потому что быстрее с клавиатуры пользоваться, чем натыкивать мышкой. Вы просто делаете свой интерфейс лучше и не тратите на это много времени, просто используя чёртовы кнопки.

**Оля.**
Мне тоже кажется, что на самом деле надо разработчикам стараться соблюдать общие соглашения. Семантика является таким общим соглашением. И там где это возможно — надо это делать. Даже если по началу это действительно будет отбирать больше времени. Потом это действительно можно оптимизировать. Просто, велик риск, что вы, как в случае с ВКонтакте, столкнётесь потом с тем, что вам это вдруг понадобится, а очень сложно будет уже переделать.

**Лёша.**
Ну, я тут чуть-чуть побыл противоположной стороной, чтобы мы втроём не сидели и не соглашались друг с другом: «Да, да, как это важно» и так далее. Чтобы хоть дискуссия появилась. Я-то конечно тоже считаю, что это всё важно. Но вот что про время и про то, как выбрать ресурсы между починкой багов и новыми фичами, а тут ещё и доступность с семантикой. У меня вот уже давно сложилось такое мнение, и мне кажется (ну, конечно, это же моё мнение), что оно правильное. Я считаю, что когда вы делаете интерфейсы доступными и семантически верными сразу же, вообще-то вы не тратите лишнего времени. То, что это отдельная работа — это огромное заблуждение. Это не отдельная работа, это просто перестройка вашей работы изначально.

Это как, вот вы умели раньше верстать таблицами. Потом нам рассказывали, что `inline-block` — это круто. А потом рассказывали, что Flexbox — это круто. И каждый раз нам казалось, что вот, я не буду делать сайты на Flexbox, потому что мне нужно потратить огромное количество времени на изучение. Это просто дольше. Я не буду этим заниматься. И многие люди откладывают это очень-очень на долго. Но потом, они один раз разберутся. Ну потратят они один лишний час и разберутся в этом. Но потом они скорее всего будут делать сайты или с такой же скоростью, или чуть быстрее, но уже на Flexbox. То есть просто поменялась базовая модель. Мы не увеличиваем сроки в изготовлении сайтов. То же самое с доступностью и семантикой, если вы разобрались один раз, у вас не встаёт вопрос потом: ставить сюда `<button>` или `<span>`. Вы знаете, что вы сюда вставите `<button>`. У вас просто не возникает этой мысли. Вы не тратите время на это. То же самое с доступностью. Если вы разобрались как, например, сделать кастомный toggle-элемент, или кастомный чекбокс доступным, один раз разобрались, — вы потом будете всегда это делать по умолчанию. Это будет ваша база. Мне кажется, что нужно заниматься улучшением своей базы. Тогда вы не будете тратить время. Тогда вы не будете говорить о том, что семантика и доступность — это дополнительное время разработки. Нет, оно может быть тем же самым временем. Просто нужно сразу делать нормально.

**Вадим.**
Есть ещё момент. Можно подняться на уровень выше. Если вы тимлид или какой-нибудь технический директор, вы просто спросите на собеседовании у человека: «Ты знаешь, что такое доступность? Ты можешь объяснить, чем `<button>` отличается от `<span>`? Что такое ARIA-атрибут и куда его воткнуть?» Фильтруйте людей, которые готовы сделать ваши интерфейсы доступными. И тогда вам не придётся тратить ни минуты лишнего времени, потому что они уже будут знать, как это делать. Вот и всё.

Это был двадцать шестой выпуск подкаста «Веб-стандарты» и его постоянные ведущие: Алексей Симоненко из HTML Academy, Ольга Алексашенко из Exante…

**Оля.**
И Вадим Макеев из Opera.

**Вадим.**
Услышимся на следующей неделе. На улице лето. И мы продолжаем записывать выпуски хотя новостей чуть меньше, но… Но мы с вами. Пока.

**Оля.**
Чао.

**Лёша.**
Пока. Держитесь.
