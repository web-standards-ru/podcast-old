# Выпуск №27

1 августа 2016: Видео в iOS, ChakraCore конкурент V8, доступные модальные окна, таблицы и формы, чехарда с цветовыми функциями CSS.

- Вадим Макеев
- Алексей Симоненко

**Вадим.**
Привет, с вами 27-й выпуск подкаста «Веб-стандарты» и его постоянные ведущие: Алексей Симоненко из HTML Academy.

**Лёша.**
И Вадим Макеев из Opera.

**Вадим.**
А Оли нет, Оля в лесу, поэтому мы записываемся вдвоём.
Мы никого не нашли на MoscowJS, и вообще, по сусекам поскребли, как-то никто не смог в эту субботу с нами записаться.
Ой, чёрт, проговорился.
Так вот, будем вдвоём сегодня.

## События

**Вадим.**
Ну как я и говорил, что вернулся с [MoscowJS №32](https://events.yandex.ru/events/yagosti/28-july-2016/) в Москве.
Что-то я зачастил: третий раз подряд, было интересно.
В этот раз проходил MoscowJS №32, по-моему, в офисе Яндекса, и были доклады яндексоидов и не яндексоидов, даже рассказали про IoT (Internet of Things) — довольно интересный доклад про то, что, мол, пишите на JS, платформа готова.
Кроме прочего, они грозились на этом MoscowJS следующий сделать конференцией.
Давно уже от MoscowJS возникает впечатление, что это конференция.
Там 200 человек набивается, если зал позволяет, а могут больше набить, наверное.
Куча JavaScript-разработчиков в Москве, востребованность всего этого дела очень высокая, и у ребят, в общем-то, и доклады на уровне.
Поэтому, когда на митапе, на встрече, чем на самом деле и является MoscowJS, звучат такие базовые доклады, или доклады людей, которые выступают первый раз, публика начинает как-то так кукситься, мол, да что это вы, на такой крутой конференции.
И тут врубаются, что это на самом деле не конференция.
По-моему, было бы неплохо сделать MoscowJS площадкой, где может выступить любой, даже без опыта.
Но вот ребята решили всё-таки пойти больше в сторону конференции, видимо, потому что им предложили большой зал и что-то большее сделать.
Короче, в сентябре будет MoscowJS в Badoo, где будет пять докладов, каждый доклад будет получасовой, а не 20-и минутный, и, в общем, что-то будет большое и интересное.
Ну, посмотрим.

Яндекс, который провёл MoscowJS в этот раз, помогает и нам в этом году.
Мы раньше [делали WSD силами Яндекса](https://events.yandex.ru/events/yagosti/wsd-msk-nov-2012/ "Первый WSD в Яндексе") в Москве несколько раз, и, в общем-то, были одними из первых, кто открыл эту программу «Я.Гости», так называемую, когда Яндекс принимает сообщество у себя на площадке в Москве.
И в этом году мы тоже будет делать с помощью Яндекса конференцию WSD в Минске, Москве и может быть даже в Киеве.
Так что, в ближайшее время будем анонсировать даты, а вы помните, да, присылайте ваши доклады.

Ну и кроме городов, которые мы уже сказали: Питер, Минск, Киев и Москва, то, что мы планируем на эту осень, к нам ещё приходили ребята из Томска и Нижнего Новгорода, мол, давайте сделаем у нас конференции.
Но так получается, что что-то многовато у нас всего, а делать больше одной конференции в месяц тяжело, на самом деле, и для вас и для нас, поэтому мы подумали и решили, что, наверное, сделаем их весной.
То есть, мне сказали, что зимой в Томске лучше не делать конференцию, потому что у всех уши отмёрзнут, а вот весной будет нормально.
Так что, вот мы планируем на апрель-май что-нибудь в Томске и Нижнем Новгороде.
В общем, будем готовиться, будем [держать вас в курсе](https://wsd.events/#calendar "Черновик расписания WSD").

Если вы слушаете этот подкаст, и ещё не купили билет на [FrontTalks](http://fronttalks.ru/) в Екатеринбурге, значит вы опоздали.
Опоздали, потому что до этого они продавали за 2000 рублей, а с понедельника, 1 августа, когда мы выпустим этот выпуск, они будут стоять 3000 рублей.
Но! Тут как раз цены поднялись и начали анонсировать звёзд.
Рассказали про Илью Бирмана, и кого там ещё, Лёша?

**Лёша.**
Про Алексея Любимова, ну не то, чтобы это звезда, но это очень крутой специалист про доступность, как раз.
Он работает в институте коррекционной педагогики Российской академии образования, и это человек, который, в принципе, занимается тестированием доступности сервисов Яндекса, если я не ошибаюсь, если что, меня ребята поправят.
И он в своём докладе будет очень много рассказывать о доступности не в теоретическом плане, а прямо в практическом плане.
То есть он будет показывать сервисы Яндекса, видимо, как они плохо дружат с доступностью, и что они делали, чтобы исправить, чтобы было хорошо.
По-моему, это очень круто, это можно именно поговорить с человеком по-русски, во-первых, а во-вторых, с человеком, который практически всё это делает.
Мне кажется, это здорово.
Я вот точно собираюсь ехать на [FrontTalks](http://fronttalks.ru/), даже не я один, а мы с Игорем поедем, который будет выступать.
И может ещё кто-то с нами поедет.
И наверняка и ты, Вадим, собираешься?

**Вадим.**
Да, на самом деле я обещал Олегу прислать в понедельник, 1 августа, тезисы к своему докладу.
В общем, как обычно, никому не говорите.

**Лёша.**
Тсс.

## Инлайновое видео в iOS

**Вадим.**
На этой неделе всех удивили разработчики Webkit.
Не тем, что они [написали очередной пост](https://webkit.org/blog/6784/new-video-policies-for-ios/ "New `<video>` Policies for iOS"), они последнее время довольно открытые, а тем, что они начали пост со смешной гифки, и вообще, шутки, там была шутка из Стар Трек.
В общем, все гики оценили.
Но главное было не это, а то, что они решили немножечко смягчить суровые правила по вставке видео на iOS.
В новой версии iOS 10, они разрешат воспроизводить видео без участия пользователя.
То есть, если у вашего видео допустим не будет звуковой дорожки, или там будет стоять атрибут `muted`, то вы сможете запустить его с помощью метода `play` или с помощью атрибута `autoplay`.
Грубо говоря, можно, наконец-то, забить на гифки и пользоваться нормальными `<video>`.
Они рассказывают историю появления гифок в интернете, почему они вообще появились, и насколько они не эффективны.
Они по весу в два раза тяжелее, по энергоэффективности в десятки раз хуже.
И наверное пришла пора нам снова те самые гифки сконвертированные из видео сконвертировать обратно в видео и вставлять на страницу с фолбэком на гиф.
Они предлагают несколько хороших сниппетов в посте, поэтому посмотрите внимательно и попробуйте сэкономить батарейку и трафик ваших пользователей, хватит уже гифки вставлять.

**Лёша.**
Ну, и помимо этого, они ещё один атрибут добавили: они, наконец-то, разрешили проигрывать видео не в Full Screen, а прям инлайново на странице.
Потому что сейчас, если вы на мобильном откроете страничку, где будет видео, и нажмёте на `play` этого видео, оно обязательно откроется у вас в режиме Full Screen.
Понятно, почему это было сделано, но это было совсем неудобно, особенно вот сейчас, когда любят делать сайты, когда на фон, который называется hero-картинка, куда иногда картинку кладут, а иногда туда видео запихивают.
И `autoplay` у нас уже есть, но было бы круто, если бы оно прямо инлайново играло на странице.
И они это сделали, добавили новый атрибут `playsinline`.
То есть, по умолчанию, поведение видео останется, оно будет в Full Screen открываться, но если вы вставите этот атрибут, то видео будет играться хорошо, как вы и ожидаете, прямо на странице.
По сути, так же, как и на десктопах.

**Вадим.**
Ну, на айпадах видео уже играется инлайн, по-моему, по умолчанию, если вы сами не пустили его Full Screen.
Но мы понимаем, что основной юзкейс — это мобильные, поэтому, да, очень классно, что, наконец, можно использовать видео инлайном.
Потому что видео, это ведь не просто видео, которое вот только так можно смотреть.
В видео можно закинуть, не знаю, какую-нибудь маленькую иконочку, которая лучше всего анимируется, как видео, и чтобы она инлайном в странице торчала.
Ну как угодно, спиннер можно сделать видео, понимаете.
Без сжатия какое-нибудь видео будет лучше и эффективнее играться, чем любая гифка.

## ChakraCore на Mac и Linux

**Лёша.**
Наверно самой большой новостью этой недели было [анонсирование](https://blogs.windows.com/msedgedev/2016/07/27/chakracore-on-linux-osx/) Майкрософтом на конференции Node Summit то, что они сделали свой открытый движок ChakraCore не только для Windows, но и для Linux и OS X.
Ну, с Linux они пока тестируют, у них есть версия, а с OS X вроде уже более-менее всё хорошо.
Это достаточно интересный ход, потому что всё-таки у нас появляются в Node.js несколько движков.
Ну прямо как в браузерах.
В прошлый раз, когда ChakraCore только появлялась, и мы рассказывали об этом, я и тогда говорил о том, что это как-то звучит стрёмно.
Потому что ведь придётся думать не о кроссбраузерности, а… кроссдвижковости?
Как это назвать?
Должно быть новое слово для этого.

**Вадим.**
Наверняка есть это слово.
Мы просто фронтендеры, мы как-то не думали про альтернативные джаваскриптовые движки раньше.
Хорошо в этом то, что наконец-то появится конкуренция.
Потому что на V8 молятся, его исходники читают, и пытаются оптимизировать свой код, чтобы из-за особенностей работы V8 или даже каких-то багов V8 ваш код исполнялся быстрее.
Сейчас придётся вам копаться в исходниках сразу двух движков, когда наконец-то ChakraCore станет реальностью.
Потому что сейчас они Node-ChakraCore, этот специальный форк Node.js, заставили работать только на 64-битном Linux.
Для Mac пока сборок нет, на сколько я знаю.
Для Mac есть только непосредственно джаваскриптовый движок.
А вот Node-ChakraCore пока с Mac не подружили.
Ну и вообще, с самого начала этот проект был нацелен на Windows, чтобы люди могли использовать джаваскриптовый движок в своих приложениях.
Потому что сейчас на JavaScript пишут все и всё.
Этот закон — «всё, что не было написано на JavaScript, будет написано на JavaScript» — является правдой.
Поэтому для того, чтобы сделать разработчикам приложений для Windows возможность писать на JavaScript, они собственно эту штуку и начали.
Но потом видимо пошло всё достаточно хорошо и они решили сделать всё кроссплатформенно.
Потому что там ведь у Windows и Unix-подобных платформ немножко разные подходы.
На Windows используется UTF-16, для строк на Unix — UTF-8.
В общем много разностей есть, они сейчас работают над этим.
На самом деле, портировать много чего нужно.
У них есть хороший Road-map.
И в общем-то это вопрос не завтрашнего дня, а скорее этого года.
Но мне очень нравится, что они взялись за это.

И на эту тему [высказался](https://www.christianheilmann.com/2016/07/27/why-chakracore-matters/) Крис Хайльман.
Крис, как никто другой наверно, знает, что такое Open Source, что такое открытость.
Когда-то совсем давным-давно он работал в Yahoo, а потом он устроился в Mozilla, и в Mozilla он проработал довольно долго, и благодаря своей шевелюре прекрасно дополнял логотип Firefox.
Но не об этом речь.

Он прекрасно понимал, что открытый браузер когда-то вернул нам веб в том состоянии, в котором в общем-то сейчас мы им радостно пользуемся.
А до этого у нас была монополия движков, которые были закрытые, и разработчики писали всё под IE.
Когда у нас на рынке появилось много движков, у нас рынок расцвёл.
Мы наконец-то начали развиваться, мы наконец-то начали прогрессировать и с точки зрения внедрения спецификаций, и с точки зрения самих спецификаций, и многого-многого другого.
У движка, который один сам по себе, есть причины развиваться, но только в рамках того, что уже существует.
А новые браузеры, даже не смотря на свою маленькую долю, могут принести очень много нового и интересного в веб-платформу.
То есть не нужно быть Chromium сегодня, чтобы повлиять на то, как браузеры и движки работают.
Какая-нибудь Opera, у которой всю историю в мире на десктопе были 2−4%, предложила элементы `<video>` и `<picture>` и много новых вещей, начала одной из первых сжимать трафик, и думать об этом всём, встроила блокировщик рекламы и VPN.
То есть, не нужно иметь большую долю, чтобы прелагать фичи.
Поэтому разнообразие — это то, что нам нужно.

Не факт, что ChakraCore сразу станет мэйнстримом, хотя ребята хвастаются скоростью и вообще всем этим.
Естественно, они не претендуют на то, чтобы занять приличную долю на платформах.
Но совершенно точно они принесут что-то свежее.
Это очень хорошая новость для всего сообщества.
Так что, если вы Node.js-разработчик и вы страшно расстроены тем, что придётся поддерживать две платформы — на самом деле вам стоило всегда поддерживать несколько платформ.

**Лёша.**
Я бы хотел подискутировать немножко на эту тему.
Потому что конечно идея, которую сказал Крис — она хорошая.
Он вспомнил слова Зельдмана, про многообразие браузеров, обязательно все должны толкать друг друга, конкуренция, всё хорошо и так далее.
Но, когда он говорит про спецификацию, про то, что если у нас один движок, он может тормозить как-то развитие и так далее — это к Node.js очень сильно притянуто за уши.
Потому что, ну смотри, это же движок от браузера, а не какая-то новая сущность.
В браузерах конкуренция отличная.
Про какую мы спецификацию говорим?
Мы не говорим про что-то Node.js-специфичное.
Мы говорим конкретно про спецификацию ECMAscript, JavaScript как языка.
И он вообще-то в браузерах развивается очень хорошо, и конкуренция там шикарная.
То есть даже если не будет этой ChakraCore, всё равно из-за того, что Chrome конкурирует со всеми остальными браузерами, из-за того, что они бегут вместе со всеми остальными за 100% поддержкой ES6 — всё это будет попадать в Node.js по умолчанию.
Что принесёт ChakraCore?
В плане языка и работы со спецификациями — я не вижу, где они здесь будут толкать друг друга.
Они и так всё поддерживают почти на 100%.
В плане API Node.js — ну это не вопрос движка, не вопрос виртуальной машины, это не к ChakraCore относится и не к V8, это совсем другой уровень.
Это как раз таки Node.js.
И я не вижу движения, чтобы, во-первых, это стандартизировать, именно API Node.js, а во-вторых, как-то пушить их куда-то.
Они очень медленно двигаются.
Почти всё что там есть — это такой низкоуровневый доступ к сети, к файловой системе и так далее.
Не знаю, мне почему-то кажется, что это очень сильно притянуто за уши, по крайней мере они не оторвут движки от браузеров.

**Вадим.**
V8 стал популярен и в какой-то момент стало возможным написать Node.js как систему, потому что V8 был быстрый.
Они за несколько лет проделали огромную работу по ускорению движка.
Они написали его сначала быстрым, потом ещё продолжали ускорять.
Скорость JavaScript растёт постоянно.
Но можно ведь конкурировать с этим.
У движка Chakra есть тоже свой JIT-компилятор, над которым они экспериментируют.
Возможно конкуренция за скорость тоже станет чем-то интересным.
Или конкуренция за поддержку каких-то сложных API из JavaScript, которые пока ещё не внедрены.
Или конкуренция за то, чтобы принимать решения внутри этих комитетов.
Если ты разрабатываешь крупный джаваскриптовый движок, который используется отраслью, у тебя есть слово во всех этих комитетах, у тебя есть вес какой-то, как у компании.
Поэтому, наверное, да действительно всё не так супер-радужно, как в конкуренции врутри браузеров, но всё равно стоит давать альтернативы разработчикам.
Совершенно точно Chakra будет по умолчанию лучше работать на Windows.
И разработчики, которые видят, что V8 в каких-то местах на Windows хуже работает — будут выбирать Chakra.
Соответственно кроссплатформенность в этом случае тоже будет местом для конкуренции.

**Лёша.**
Ты в начале говорил про скорость и про какие-то сложные API JavaScript.
Но я всё равно свой поинт хочу донести: они что, как-то отдельно от браузера будут делать?
Ведь нет.
V8 и Chakra будут конкурировать по скорости выполнения JavaScript внутри браузеров.
Потому что для них это важно.
Node.js тут просто довеском идёт к конкуренции в браузерах.
Да там скорость увеличивается и увеличивается в Node.js, но это потому что ребята сражаются в рынке браузеров.
У меня вот для тебя конспирологическая теория: может всё дело не в Node.js?
Ведь если они делают очень большую вещь — движок работы с JavaScript — пишут его, чтобы он работал на Linux и Mac.
Может они могут целить и в браузер для этих операционных систем?
Может быть мы увидим Edge когда-нибудь для Linux и OS X?

**Вадим.**
Ну, мы уже однажды видели Internet Explorer на Mac, и это было на столько давно, что я даже не буду сравнивать.
Мы даже Safari видели на Windows, и это тоже было не очень хорошо.
Сложно сказать.
Мне кажется, что момент, когда V8 разрабатывали прежде всего для браузера, и просто портировали его для Node.js — немножко прошёл.
Я уверен, что сейчас движок, естественно, разрабатывается для браузера, и все эти интеграции в браузер, нормальная работа именно с браузерными API — это важная штука.
Но направление по оптимизации V8 и той же самой Chakra именно для работы с Node.js — это одно из направлений, которое сейчас всё больше и больше растёт.
Это очень популярная в мире платформа.
Поэтому в этом месте тоже возможна какая-то конкуренция по лучшей интеграции, по оптимальной работе с Node.js.

**Лёша.**
Да, возможно.
У меня к тебе ещё такой вопрос.
Мне просто интересно, как это всё будет выглядеть?
Ведь в браузерах, когда всё только начиналось, когда появлялись разные движки, нам приходилось из-за того, что рынок был ещё не совсем зрелый, и все всё-таки тянули в разные стороны, приходилось вставлять всякие костыли, хаки, определять User-Agent, определять движок, и именно для этого движка как-то что-то делать, потому что там у них это лучше работает.
Интересно, мы получим такой же опыт на первом этапе в Node.js?
Я просто думаю, как разработчик, для которого нужно написать приложение для Node.js, и его будут использовать очень много разных пользователей.
То есть, мне сейчас говорят о том, что у пользователей может быть не только разная версия Node.js, а их куча, а ещё и разные движки.
И мне придётся в своём приложении закладываться ещё и на эту проблему, и возможно в моём приложении появится теги определения движка, функций и так далее, всего того, что нам так было ненавистно в браузерах и в сайтах.
Стандарта-то нет.
У языка есть стандарт, но это больше про браузерный API, и просто про стандарт языка JavaScript.
Но стандарта API к Node.js вроде как нет.
И легко можно взять это вот расширение Node-ChakraCore и запилить что-то не только на уровне движка, на уровне языка JavaScript, а может быть и на уровне Node.js API, чтобы, например, в Windows была поддержка лучше.
Конечно, это всё будет исключительно из благих целей.
Да, мы хотим, чтобы в Windows поддержка была лучше, поэтому мы добавим ещё 10 методов, которые будут работать с файловой системой лучше.
И что мне, как разработчику делать — опять втыкать эти костыли, думать об этом?
Это же не очень хороший путь.
Я не уверен, что они сразу смогут сделать всё хорошо.

**Вадим.**
Ты сейчас приводишь в пример те годы, когда у нас в общем-то «воровали-убивали», и разработчики браузеров и вообще крупные компании поступали, как хотели.
Если посмотреть на то, как сейчас всё это сделала Microsoft — они вежливо пришли в Node.js, засунули свой пулреквест, который предлагает немножко изменений в Node.js, чтобы можно было их с Chakra поженить, и сказали: «Здравствуйте, мы хотим сделать такую вот штуку, как вы считаете?»
Сообщество в принципе всё это восприняло с энтузиазмом, большей частью.
Наверно всё так вот дико не будет.
Вряд ли они будут выпускать какие-то совсем сырые версии, которые не совместимые или плохо совместимые или недостаточно совместимые с V8 пока они эту совместимость не подпилят.
Я думаю, что всё будет достаточно интеллигентно и нормально, и у разработчиков будет минимальный стресс в этом смысле, с точки зрения новых API.
Я думаю конкуренция будет происходить скорее в ночных сборках, каких-то бета-версиях.
То же самое со многими другими спецификациями.
Сейчас у нас от префиксов отказываются, какие-то фичи прячут за флагами.
В той же самой Node.js ведь тоже есть всякие флаги, и сейчас по-моему какие-то фичи ECMAscript прячутся за флагами.
То есть, я думаю, что в стабильной работе мы научились разработчиков обезопашивать от всяких проблем.
Но, даже если эти проблемы будут, это будут даже не проблемы, а различия.
И на основе этих различий вы можете выбирать, какие системные требования вы будете прилагать к своему веб-приложению.
Чтобы это была Node.js с V8, но предпочтительно Node.js с Chakra, потому что будет работать быстрее.
Вы же можете какие-то системные требования прилагать к своему приложению.

**Лёша.**
Звучит разумно.
Конечно всё это звучит разумно.
Но просто есть какая-то опаска в этом всём.
Ну, ладно, посмотрим.
Тут конечно нужно сказать ещё вот какую вещь.
ChakraCore и Microsoft, когда предложили свой движок, они немножко сдвинули сообщество Node.js дальше.
Например, в Node.js появился отдельный репозиторий [nodejs/vm](https://github.com/nodejs/vm) — это такой репозиторий для условно открытой дискуссии о том, как должна измениться Node.js в условиях множества разных виртуальных машин JavaScript.
То есть они рассматривают не только V8 и Chakra, а оказывается есть и другие предложения.
Есть ребята, которые пилят виртуальные машины чисто под себя.
Они не хотят их никуда выкладывать.
Они просто хотят, чтобы у них Node.js была особая.
Например, для тех же самых Internet of Things есть предложения о том, чтобы немножко поменять движок и использовать особенную Node.js там.
Другой вопрос, что точно так же Mozilla пришла со своим [SpiderNode](https://github.com/mozilla/spidernode) — ведь это их движок SpiderMonkey — и тоже начинает обсуждать.
В общем ChakraCore точно запустила большое обсуждение в Node.js о том, что делать со множеством этих виртуальных машин, как Node.js должна себя вести.
Это в принципе хорошо наверно.
Наверняка это даст какие-то плюсы в будущем.
Но вот когда это всё начинается — немножечко нервно.

**Вадим.**
Ну, глядя из 2016 года назад, мы же всё-таки рады, что мы не вынуждены пользоваться браузером Mosaic и что отрасль несколько раз сменила лидеров за последние годы и это принесло нам только хорошее.
Видимо Node.js ждёт то же самое.

**Лёша.**
Будем надеяться.

## Модальные окна

**Вадим.**
У нас на этой неделе много тем про доступность.
Кто-то уже стонет, что мол сколько можно.
Ну, до тех пор пока вы не поймёте, и я не буду видеть в интернете доступные сайты.
Ладно, шучу.
Просто действительно совпало много хороших статей на эту тему.
И мне кажется, что это довольно важно.

Погранично с доступностью и вообще удобством был [хороший перевод](http://prgssr.ru/development/oformlenie-modalnyh-okon.html "Оформление модальных окон").
Крис Койер недавно на CSS-Tricks описал собственный опыт по работе с модальными окнами на страницах.
Описал немного очевидные вещи, но которые на самом деле не очень-то очевидны рядовому разработчику: что модальные окна нужно фиксировать с `position: fixed`, что нужно делать их `max-width`, чтобы они не обрезались на экранах, и так далее.

Мой собственный опыт как пользователя интернета показывает, что регулярно я сталкиваюсь с тем, что я захожу на какой-нибудь сайт, он предлагает мне форму регистрации, и я не могу нормально проскроллить — оно зафиксировано и у `body` отключен какой-нибудь `overflow`, и в итоге оно ещё позиционируется c помощью JavaScript частенько.
Получается очень плохо и очень страшно.
И поскольку подобные вещи редко предусматриваются дизайнерами, ну то есть они вам рисуют модальное окно и говорят «поехали», — то вам приходится принимать очень много интерфейсных решений.
Мне всегда казалось, что работа верстальщика довольно-таки интересная, потому что мы принимаем много интерфейсных решений.

Так вот Крис Койер советует, какие интерфейсные решения вам стоит принимать, когда вы работаете с модальными окнами.
Он особо не притрагивается к теме доступности модальных окон, потому что там есть собственные какие-то нюансы, что фокус Таба должен быть пойман внутри этого модального окна, чтобы он не гулял по странице, что кнопку нужно всегда показывать видимой, чтобы из модального окна можно было выйти с клавиатуры.
В общем, много есть нюансов.
И если вы делаете модальные окна, или если у вас уже есть модальные окна, проверьте их по этому чеклисту, который предлагает Крис Койер, и возможно у вас найдётся повод что-то поправить в ваших модальных окнах.

**Лёша.**
Я знаешь чего не обнаружил здесь.
С одной стороны, это про доступность, но с другой стороны, мне всегда казалось, что это просто обязательная вещь.
Я считаю, что нажимая клавишу Escape, ты должен закрывать то, что открывается.
И для модальных окон это просто обязательная вещь в моём понимании.
Мы привыкли в операционных системах, что всё, что у нас открывается, мы можем закрыть клавишей Escape, у нас есть всегда быстрая клавиша, которая нафиг всё закрывает, что всплыло.

И жалко, что в этой статье этого пункта нет, потому что я даже на «Базовом интенсиве» ребятам, когда рассказываю про JavaScript, я рассказываю, например, про этот элемент обязательно: ребята, мы закрыли по крестику, закрыли по вот этому оверлею кликом — это всё хорошо, но не забываем ещё закрыть по клавише Escape.
Вроде такая банальная вещь, но делают её очень редко.
А она ведь вносит такой положительный опыт работы с интерфейсами.
То, что всплывает, оно чаще всего бесит, потому что чаще всего… Ну нет, не чаще всего конечно.
Когда ты кликаешь на какой-то элемент, и у тебя всплывает формочка с вводом — это окей.
Но иногда ведь модальные окна используют не так хорошо: в них открывают баннеры всплывающие и всё остальное.
И вот в этом смысле их нужно срочно закрыть.
Обязательно нужно, чтобы клавиша Escape работала.

**Вадим.**
У меня с клавишей Escape связанна собственная боль.
Кстати, escape — это убежать, escape — это выход.
Поэтому не забывайте, что на этой клавише написано _то_, _что_ ваш пользователь скорее всего сделает, когда увидит ваше ненужное модальное окно.

Так вот личная боль связана с тем, что в браузерах Opera клавиша Escape выводит из полноэкранного режима.
В какой-то момент это работало так и в Chrome, они потом это убрали.
Но вот в Opera это поведение сохранилось.
У меня частенько на ноутбуках маленькие экраны, потому что я их с собой вожу и так удобнее.
И когда я пытаюсь закрыть модальное окно на сайте, а разработчики слушают Escape — всё происходит прекрасно, Escape закрывает окно.
Но браузер ещё выходит из полноэкранного режима.
А почему? Потому что вы, когда слушаете Escape, вы ловите его, выполняете ваш JavaScript, но не делаете `preventDefault()`.
Браузер получает событие Escape и начинает обрабатывать его дополнительно.
Вот это большая проблема, не только с Escape связанная.
Частенько разработчики ещё слушают какие-то клавиши, Alt + [стрелочки] для навигации по странице и ещё что-нибудь такое, и не делают `preventDefault()`.
Тогда это событие срабатывает и для вашего скрипта, и для браузера.
А браузеры бывают разные, операционные системы бывают разные.
Поэтому, если вы всё-таки сделали Escape — вы молодец, но не забудьте сделать `preventDefault()`, ведь Escape может использоваться самим браузером.

**Лёша.**
Слушай, это прекрасный пример! У нас на курсе я всех заставляю делать `preventDefault()`, к слову.
Но когда я рассказываю про это… То есть понятно, что мы в ссылке отменяем — действие по умолчанию, переход по ссылке — всё вроде как логично.
Но в некоторых элементах, например в `<button>`, который ничего не делает, я тоже всегда ставлю `preventDefault()`, и меня спрашивают, почему.
Вернее я у ребят спрашиваю, почему.
И все гадают: как же, почему, что же может случиться.
А я им всегда говорю: ну знаете, ребята, я параноик, я лучше лишний раз поставлю, в крайнем случае ничего не случится, вот прямо вообще ничего не случится; в другом случае, вы избежите всяких дурацких штук, потому что обычно JavaScript-разработчику должно быть пофиг на разметку.
Откуда я знаю `<button>` там на самом деле или ссылка.
Или сделал я скрипт, а прийдёт после меня какой-нибудь верстальщик и решит, что этот `<button>` нужно заменить на ссылку.
И что, мой скрипт должен сломаться от этого.
Нет конечно.
И с Escape так же.
Но вот этот пример про выход браузера из полноэкранного режима — это классный пример.
Я теперь его буду рассказывать.

Ещё знаешь что мне понравилось в этой статье.
Может быть я такой слоупок, но я до этой мысли как-то сам не дошёл, не знаю, не думал об этом.
Про то, чтобы специальный класс делать для закрытия окна, и для открытия.
По-моему гениальнейшая вещь.
Я не знаю почему вообще такая простейшая вещь не вошла в мой мозг сама.
Я совсем недавно как раз таки сталкивался с этой проблемой.
Блин, я даже не додумался до этого, я не то чтобы долго думал, но тем не менее.
Ровно та же проблема, которую он рассказывает.
У нас блоку по умолчанию какой-то `display` задан, `display: block` например.
А сейчас часто из-за того, что есть флексы, может быть `flex`, а если это например список, то у него вообще отдельный есть `list-item`.
И хорошо бы, когда вы `display: none` делаете, ставить его обратно.
Нужно вернуть же тот же самый `display`.
И когда ты делаешь универсальный скрипт, такой тоглер на всём сайте, например, с помощью `data`-атрибутов, то вам нужно как-то узнавать, про этот `display` и возвращать тот самый — и тут такие пляски с бубном получаются.
А это же по-моему гениальнейшее решение: вы просто меняете их местами и у вас просто работает CSS.
По моему это круто.

## Сложные таблицы

**Вадим.**
Ещё была одна статья про доступность, про доступность больших таблиц, даже не столько про доступность, сколько про то как их вообще сделать.
Потому что мы как-бы получаем админки с огромными наборами данных и их как-то нужно показывать пользователям.
И на десктопе мы более менее справлялись с этим, но когда приходят мобильные, нужно эти таблицы адаптировать.
И на эту тему написано много всего интересного, и статей, и много разных фреймоворков, и библиотек, которые всё это реализуют.
В общем много чего было сделано, но тут [высказался Shopify](https://medium.com/p/1e05c6924eaf) — это такая система, которая делает удобные интернет-магазины.
Допустим, A Book Apart, которая продаёт книги, использует её как интерфейс для продажи своих книг.
Так вот Shopify (естественно у них там есть свои админки, где вы всё это анализируйте, есть какие-то большие данные) поделились своим опытом в серии постов про доступность как они сделали эти большие таблицы.
Там есть очень много интересных советов, интересного опыта.
Например, один из советов: не зацикливайтесь на прототипе.
Когда вы поняли, как вы хотите, чтобы ваша таблица вела себя, сделав её на основе какой-то библиотечки, которую вы где-то откопали, не думайте, что вопрос решён, пойдём в продакшен, всё нормально.
Подумайте о доступности вашего решения, подумайте насколько оно вообще оправдано, нужно ли вам грузить библиотеку и так далее.
Shopify на своём опыте показал, что первый прототип, чтобы убедить дизайнеров и заказчиков как должен выглядеть интерфейс, был использован и успешно выброшен, а на его основе было написано компактное и доступное решение.
В итоге оно оказалось гораздо лучше, чем тот самый прототип, потому что оно использовало таблицы для табличных данных (шок), а не дивы как это было в случае с прототипом.
И более того проблему таблиц, которые становятся меньше на маленьких экранах, было решено сделать с помощью не одной таблицы, а — двух таблиц, и решение в итоге оказалось элегантным и интересным.

Вторая интересная мысль, которая озвучивается в этой статье, это то, что я уже говорил раньше — не предполагайте, если речь идёт о доступности, потому что когда мы пользуемся интерфейсами с помощью мышки и глаз, и в общем знакомых нам способов, мы не знаем как на самом деле будет работать средство доступности.
В статье подробно рассматривается VoiceOver — это такой, встроенный в Mac и платформы Apple на iOS, помощник доступности, который читает ваши страницы.
И в этот помощник, на самом деле, встроено много эвристики, которая пытается догадаться и помочь вам прочитывать ваши страницы доступным образом.
Допустим есть момент, что VoiceOver не считает таблицу таблицей, если у рядов нет рамок — об этом есть отдельная статья от тех же авторов из Shopify.
Но суть сводится к тому, что была ведь у нас эпоха, когда таблицы использовались для раскладок, и вот как наследие этой эпохи VoiceOver иногда считает вашу таблицу раскладочной.
Поэтому, если вы просто сделали вашу таблицу таблицей, то вы уже молодцы.
Но убедитесь, что VoiceOver правильно её понимает — может быть вам какие-то рамочки нужно добавить, чтобы всё было нормально.

То же самое с неожиданным моментом, что оказывается VoiceOver не считает дефис минусом.
Приводится пример, у них в таблице было −90 $ и для того, чтобы сделать проще, чтобы пользователям было легче вводить и им тоже не париться, они использовали типографику для бедных, т.е.
вместо нормального юникодного знака минуса, они взяли дефис, который совсем не предназначен для этого.
И VoiceOver не читает `-90` как минус, потому что там дефис, и им в итоге пришлось использовать нормальный юникодный символ.
В итоге, этот минус гораздо заметнее и понятнее тем, кто видит, и этот минус нормально прочитывается через VoiceOver.
Поэтому оказывается нормальная типографика ещё и доступнее, чем типографика для бедных.

В общем, если вы делаете сложные таблицы, пробегитесь по этим рекомендациям, оцените опыт Shopify — они в общем-то серьёзные ребята.
И эта не единственная статья в этой серии про доступность, очень рекомендую.

## Формы и доступность

**Вадим.**
Кроме сложного для исполнения интерфейса таблиц есть ещё сложный в исполнении интерфейс в виде форм.
Формы мы все давно горячо ненавидим, потому что они немножко странные.
Возможно из этого растёт проблема, что мы не очень знаем как формы верстать, используя семантическую разметку.
Разработчики более менее научились пользоваться новыми элементами форм, типа `type="email"`, вариациями кнопочек, всеми вариациями чекбоксов, радиокнопок и других новых интерфейсов.
Но ещё не умеют нормально пользоваться элементами `<fieldset>` и `<legend>`.
Леони Уотсон [написала статью в блоге GOV.UK](https://accessibility.blog.gov.uk/2016/07/22/using-the-fieldset-and-legend-elements/ "Using the fieldset and legend elements") — это портал разработчиков британских правительственных сайтов.
И рассказала про то, как правильно использовать `<fieldset>` и `<legend>`.
Ну, казалось бы, _fieldset_ переводится как группа полей, и html-спецификация всегда рекомендовала группировать ваши поля в `<fieldset>`.
Но в большинстве форм, которые я вижу, `<fieldset>` используют, как служебный элемент.
Не всегда одинаковые поля группируются внутри одного `<fieldset>`.
Иногда у вас одно поле, но вам по вёрстке нужна какая-то обёртка и вы используете тоже `<fieldset>`.
Это всё не правильно, на самом деле.
И Леони приводит очень хороший пример.
Представьте, что у вас есть поле, в котором написано: «У вас есть паспорт? Да.
Нет.» Если вы нормальный разработчик, если вы умеете HTML писать, вы конечно используете `<label>` для вашей радиокнопки, а в `<label>` будет написано «Да», и он будет привязан к варианту с «Да», и «Нет» — к «Нет».
И когда экранная читалка дойдёт до вашего `<label>` она увидит «Да» и «Нет», а какой вопрос — она не поймёт.
Вы можете, конечно, в каждый `<label>` засунуть вопрос и ещё ответ туда же.

Для того, чтобы сгруппировать в таких ситуациях, используется как раз `<fieldset>`.
То есть, вы заворачиваете ваши два `<input>` с `<label>` в `<fieldset>`, и этому `<fieldset>` задаёте элемент `<legend>` — легенда, описание этой группы полей.
И там вы уже задаёте собственно вопрос на который отвечают эти два `<input>`.
То же самое можно делать, когда у вас не просто два варианта, а много.
И даже, когда они не чекбоксы, а радиокнопки.
Допустим вы спрашиваете адрес пользователя, и группируете все ответы: город, страна, индекс и прочее — всё это полезно группировать в одно поле, чтобы экранные читалки могли понять, что начались вопросы про адрес, и эти поля сгруппированы.
Потому что иначе, если неожиданно откуда-то появится какое-то поле с непонятным `<label>`, не будет понятно к чему оно относится.
Можно ведь так сформулировать содержание `<label>`, что не понятно, о чём идёт речь.

Продумывайте ваши формы, группируйте поля.
Но если у вас всего одно поле, не группируйте, потому что экранные читалки специальным образом это обрабатывают и в итоге получается не удобно.
Поэтому, если нечего группировать — группы нет.

**Лёша.**
Вадим, у меня к тебе вот какой вопрос.
Она в своей статье говорит о том, что можно было бы делать группировки внутри группировок, то есть вложенные `<fieldset>`.
И нам спека ведь это не запрещает.
По спецификации мы можем это делать, на сколько я помню.
Но она при этом говорит, что лучше так не делать.
С чем это связано?

**Вадим.**
Спецификация разрешает это, потому что это кажется логичным, ведь в действительно сложной форме могут быть группы внутри групп.
И я могу представить себе такое.
Но наверно не стоит делать такие формы.
А Леони объясняет в чём дело.
В современных экранных читалках нет возможности обозначить, когда группа закончилась.
Поэтому, если у вас уже есть группа, и вы находитесь внутри неё, то следующая группа откроется, и не очень понятно, когда закроется, и когда начнётся следующая.
Экранные читалки не умеют нормально демонстрировать иерархичность.
И наверно даже её сложновато держать в уме пользователям, которые не видят интерфейс.
Поэтому да, можно просто порекомендовать выслушать рекомендацию от пользователя, который сам читает, а не видит ваши сайты, можно порекомендовать не вкладывать `<fieldset>` друг в друга, чтобы не усложнять чтение их.

**Лёша.**
Мне понравилась концовка в этой статье.
Она такая же лёгкая, как в твоём докладе «Жми сюда»: что выбрать, кнопку или ссылку.
Тут точно так же: как определить, использовать `<fieldset>` с `<legend>` или нет.
Очень простое решение — вы один раз его прочитаете и будете всегда знать, как это делать, прямо как с кнопкой и ссылкой.
Использовать `<fieldset>` и `<legend>` нужно, когда у вас есть несколько ответов на вопрос, или когда у вас несколько полей объединены одним вопросом.
Всё.
Если у вас одиночное поле, которое отвечает на вопрос самостоятельно — вам не нужно использовать `<fieldset>` и `<legend>`.
Это по-моему, простейшее правило, которое очень легко применять каждый день.
Особо, кстати говоря, помня предыдущие подкасты, не тратя на это дополнительного времени.

**Вадим.**
Если этот совет Леони касается узкой темы, то на этой неделе Эдди Османи написал ещё более расширенный пост.
Они с Мэттом Гантом записывают такой ситком, как я называю.
Называется [Totally Tooling Tips](https://youtu.be/pBJZsp5LsOE?list=PLNYkxOF6rcIB3ci6nwNyLYNU6RDOU3YyL).
Они сидят где-нибудь в кафешке калифорнийской, и разговаривают друг с другом на тему инструментов, любых инструментов.
И из одного такого выпуска про инструменты доступности Эдди Османи, [развернул целый пост на Medium](https://medium.com/p/39e727101a67 "Accessible UI Components For The Web") про то, какие важные принципы есть для того, чтобы делать ваши интерфейсы и ваши сайты доступными.
И если вы в какой-то момент решите (может быть после этого выпуска и значит моя задача выполнена) ваши интерфейсы сделать доступными не только для тех, у кого есть обе руки, мышка и глаза, а и для всех остальных людей, то эта статья — хорошее начало.
Она объясняет базовые принципы, рекомендует инструменты, и в принципе говорит об этом довольно таки понятным языком.
Я надеюсь кто-нибудь возьмётся и переведёт её, потому что это правда хорошее начало _([см.
перевод](http://prgssr.ru/development/dostupnye-komponenty-polzovatelskogo-interfejsa.html), прим.
редактора)_.

## Чехарда с цветовыми функциями

**Лёша.**
На этом, я думаю, можно заканчивать нашу постоянную рубрику «Спросите Вадима про доступность» и перейти немножко к CSS.
Потому что в CSS на этой неделе произошло невероятное.
Дело в том, что из функции `rgb()` убрали запятые.
Я немножко смеюсь, потому что это какое-то такое вроде бы минорное изменение, но под него подняли такую волну негодования или поддержки о том, что ребятам нечем заняться, с другой стороны всё правильно сделали.
Это достаточно забавно, что так реагируют.
Но с другой стороны, почему всё произошло, вообще что произошло?
Произошло следующее.
У нас есть функции `rgb()`, `rgba()` и другие похожие, и там числовые значения разделены запятыми.
Был [коммит](https://github.com/w3c/csswg-drafts/commit/a54f8b2089d16eca696690fe7ffc3c11d4db9861 "Switch all the color functions to be space-separated"), в котором убирают запятые и теперь значения в функциях `rgb()`, `rbga()` и всех остальных будут разделены просто пробелом.
В принципе так же как и во всех других функциях в CSS.

**Вадим.**
В общем да, коммит ничего особо не объяснял с самого начала.
Он просто говорил — будет так.
И всё бы ничего, но до этого был другой [коммит](http://www.xanthir.com/b4iW0 "CSS Function Syntaxes, color and otherwise"), который добавляет в `rgb()` четвёртый параметр — альфа-канал.
И вот эта штука уже всколыхнула сообщество, мол «ура, ура», или «не ура, не ура».
В общем, мы уже смирились с тем, что нам теперь `rgba()` не нужна, нужна только `rgb()`, а в неё можно засунуть альфа-канал.
Но прошла буквально неделя-полторы и снова изменения какие-то.
И люди окончательно потеряли терпение и вышли в интернет спорить с факелами и вилами.
В итоге Таб Аткинс решил объяснить, что за коммит вообще был, и в своём блоге написал — ребята, не волнуйтесь, это не у нас какие-то проблемы, что нам нечего делать, а мы на самом деле выполняем одну большую задачу, мы, как это говорят среди разработчиков, рефакторим, то есть мы пытаемся сделать так, чтобы внутри CSS была понятная система, чтобы он мог развиваться последовательно, и следующие функции, которые в языке будут придуманы, работали так же как и все остальные.

В CSS есть отдельная [страница](https://wiki.csswg.org/ideas/mistakes "Incomplete List of Mistakes in the Design of CSS"), где авторы спецификаций говорят, что мол в этом месте мы провалились.
Это такой сборник ошибок авторов спецификаций, которые уже вошли в практику, и которые особо не изменить.
Там есть всякие вещи, допустим тот же `currentColor`, который пишется в одно слово, а не через дефис — это одна из проблем, которая случилась.

То же самое с `rgb()` и `rgba()`.
Ведь сначала появилась эта штука в шестнадцатеричной hex-функции, где тоже можно альфа-канал пропихнуть, и пошла волна этих изменений.
В итоге получается такая ситуация в сухом остатке.
У нас есть цветовые функции `rgb()`, `hsl()`, `lab()` и все остальные.
Суть сводится к тому, что в названии цветовой функции ничего не будет про альфа-канал, в ней будет просто допустим `rgb()`, а внутри вы можете через пробелы указывать значения `red`, `green` и `blue`, и потом, в конце, через `/` указывать уже значение прозрачности.

И это будет основным и рекомендованным способом указания цветов.
Поэтому, если через пару лет вы будете писать цвет, то лучше вам его писать по новому синтаксису.
А какой-нибудь Autoprefixer, или что там будет, будет за вами подчищать и добавлять для совместимости старые свойства.
То есть, никто спецификацией не запрещает использовать `rgba()`, как мы раньше использовали, или разделять значения запятыми, но эти вещи остаются в спецификации для обратной совместимости, потому что они уже реализованы в браузерах, они уже используются в большом количестве кода.
В какой-то момент ведь была большая буча с переходом на `rgba()`, когда она только появился, и мы все писали сначала свойство с `rgb()`, а потом свойство с `rgba()` (например `background`), для того чтобы браузеры, которые не врубаются, применили предыдущие свойства.

И сейчас такая же история.
Если вы будете писать в новом формате, то либо используйте средства автоматизации, либо просто добавляйте другие значения, можно какие-то миксины наверно использовать.
Ну и собственно вот эти функции, как пишет Таб Аткинс, стали больше похожи на значения.
У нас значения в каком-нибудь `background` отдельные его части разделены пробелами.
И та же самая история будет и в функциях.
Нам не нужны запятые, потому запятые в CSS это немножко другое — они разделяют значения на группы, допустим `multiple-background` или `box-shadow`, — это немножко другой момент.
В конце-концов, символов меньше писать.

**Лёша.**
Да, это важно.
Кстати, они вот эти все старые варианты написания функций `rgb()` и `rgba` так вот сразу, слёту отметили как legacy-code.
Поэтом, если вы пишите значения в `rgb()` через запятые, то вы пишите legacy-code.
Знайте это.

И самое забавное, для меня по крайней мере, — ребята переписывали синтаксис туда-сюда несколько раз, то так, то сяк, разные предложения были.
Я ещё не успел, к сожалению, перед этим выпуском зайти в репозиторий PostCSS-плагина, который делает новые цветовые функции по спецификации.
Но мне было бы очень интересно, ребята успевали внедрять все эти изменения в свой плагин?
Они же быстрые такие.
Мне почему-то представляется, что каждый день они переписывали свой PostCSS-плагин для работы с цветом: так, у нас теперь запятые; так, нет, у нас нет запятых, у нас всё через пробел; так, у нас теперь слеш ещё; чёрт, блин, `rgba()`, теперь нет `rgba()`; hex с четырьмя значениями — а-а-а!
В общем вот так вот.
Кстати, это забавная история, конечно.
Но мне интересно, а ведь hex с четырьмя значениями они оставляют.

**Вадим.**
По-моему да.
Это никуда не делось.
Речь шла исключительно о том, что внутри фукнций в новых спецификациях теперь будут использоваться пробелы как разделитель вместо запятых.
И существующие функции тоже будут приведены к пробелам, как к рекомендованному синтаксису.

**Лёша.**
А зачем они функцию `rgba()` оставляют? Или она исключительно для legacy?

**Вадим.**
Я думаю, функция `rgba()` остаётся просто для обратной совместимости, просто чтобы можно было объяснить внутри спецификации как эта `rgba()` работает, на случай если разработчик в старом коде найдёт упоминание.

**Лёша.**
Да, это ж все фреймворки переписывать.

**Вадим.**
На самом деле, это хорошо.
Это может быть не так хорошо, как решение других более сложных проблем внутри CSS, которые требуют огромных и очень серьёзных архитектурных решений.
Об этом как раз писал Рома Комаров на неделе, мол ну всё, все проблемы CSS решены, расходимся домой.
Иронично писал, понятное дело.
Да у CSS есть большие проблемы, связанные с областями видимости, с какими-то конструкциями, которые есть у препроцессоров, но пока нет в CSS.
И есть много хороших идей на эту тему — всякие счётчики, псевдо-элементы — очень и очень много идей.
И по сравнению с этими большими идеями и проблемами вот это переписывание несчастной функции `rgb()` кажется какой-то совсем детской вознёй.
Но по-моему это один из важных шагов, которые нужно делать в любой сложной системе — упорядочивать, чтобы принятие следующих решений не наталкивалось на проблемы «о Господи, а какую реализацию нам предпочесть в этот раз».
Надо делать так, чтобы код был предсказуемым, чтобы и разработчикам было проще и авторам будущих спецификаций тоже.

**Лёша.**
Знаешь, вот сейчас пришло в голову, почему это ещё очень важно.
Например, у нас ведь есть кастомные свойства, и когда мы их задаём, если я правильно помню, мы там не можем использовать запятые, потому что запятая — это уже что-то следующее.
У нас значения могут быть через пробелы и заканчиваться точкой с запятой.
Запятых там не может быть.
И если я хочу использовать кастомные свойства внутри функции `rgb()`, в которой сейчас запятые, — тут CSS весь ломается.
То есть видимо это нельзя.

**Вадим.**
Ну значит это ещё упростит работу парсерам, совершенно точно.

---

С вами был 27-й выпуск подкаста «Веб-стандарты» и его постоянные ведущие Алексей Симоненко из HtmlAcademy…

**Лёша.**
Вадим Макеев из Opera…

**Лёша.**
и надеемся, что Оля к следующему выпуску выйдет из леса, и мы запишем 28-й в нашем классическом составе.
Услышимся на следующей неделе.
Счастливо!

**Лёша.**
Пока!
