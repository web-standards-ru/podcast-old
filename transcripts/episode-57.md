# Выпуск №57

27 февраля 2017: Safari TP24, браузеры в 2017, кастомные свойства, make great again, новый HTML-заголовок, нервный опенсорс, W3C против WHATWG.

- Ольга Алексашенко
- Вадим Макеев
- Алексей Симоненко

**Оля.**
Привет, с Вами 57 выпуск подкаста «Веб-стандарты» и его постоянные ведущие Вадим Макеев и Алексей Симоненко из HTML Academy.

**Вадим.**
И Ольга Алексашенко - верстальщик руками из EXANTE.

## События (00:12)

**Вадим.**
Прошлый выпуск мы записывали на [Rolling Scopes в Минске](https://youtu.be/CGfnGczxKAI?list=PLe--kalBDwjiiVq-AxoChmYbArhioKhQw).
Было очень интересно, я там посмотрел на Акселя Раушмайера, на Виталия Фридмана, в очередной раз, и мне очень понравилось.
Там было очень много зарубежных докладчиков, много русскоязычных.
Основной поток был, в основном, по-английски, но меня на него поставили докладывать по-русски.
В общем, вывод такой - это был мой первый Rolling Scopes и мне очень понравилось.
Наверно, можно назвать второй главной конференцией в Белоруссии.
Первая, конечно-же Web Standards Days, ну ладно, можем назвать Rolling Scopes местной отличной конференцией двухдневной.
Я обязательно приеду в следующий раз, мне понравилось.

Мы провели [Pitercss №10](https://pitercss.timepad.ru/event/442550/) 21 февраля в офисе Selectel, видео и слайды выложим вместе с подкастом в понедельник.
Представляете, видео смонтировали, довольно быстро даже.
Трансляция, как обычно не завелась, нам наверно надо плюнуть на это дело уже, ну ладно, будем пытаться.

Pitercss №11 пройдёт уже 21 марта, не знаю почему тоже 21-го, но вот так. Всё пройдёт в офисе SIB Russia<!-- TODO: Уточнить название локации -->.
Мы доклады на эту встречу, неверно, уже не ищем, потому что прислали нам много чего за последнее время.
Но мы продолжаем искать на следующий, потому что у нас на апрельскую, по-моему, докладов ещё нет.
Так что обязательно пишите если вы в Питере или хотите заехать посмотреть на то, какая красивая в Петербурге весна.

На этой неделе мы поедем в Москву на [Moscowcss №1](https://moscowcss.timepad.ru/event/443474/) в Москве с Лёшей и 2 марта, собственно, пройдёт конференция, ладно, конференция громко сказано - митап.
Там уже есть 2 доклада в программе.
CSS-методологии Алексея Охрименко, то что он читал на WSD в Питере, видео откуда пока...пока его нет.
И про несколько фишечек CSS, про которые вы могли не знать, расскажет Людмила Мжачих.
И третий доклад, я думаю, мы анонсируем на этой неделе, откроем еще немножко регистраций.

[Frontend Fellows №11](https://frontendfellows.timepad.ru/event/448864/) пройдёт  в Ижевске 3 марта на следующий день после московского Moscowcss №1.
Радостно, что эта идея растёт и живёт.
Там, в основном, будут говорить, конечно, про React и всякие `WebVR`, но я думаю они когда-нибудь они дойдут до полноценного фронтенда во всю ширь тематическую.

Ну и Reackt в Амстердаме, напоминаем, 21 апреля, и в прошлом выпуске, если помните, мы обещали разыграть билет и кто-же, кт-же его выиграл?

**Лёша.**
Может быть, сначала обсудим вообще что же нам прислали, насколько плохо мы сделали сайт?

**Вадим.**
Ну да.
Мы попросили в прошлом выпуске посмотреть на сайт [pitercss.com](https://pitercss.com/) - на сайт конференции, которая пройдёт 16 июня в Питере и поискать какие-то ошибки.
И прислали, по моему, 8 ошибок нам, из которых много чего мы обязательно поправим.
Большинство, в общем-то, прям ошибки найдены.
Самые большие ошибки у нас, кажется, в Internet Explore и в Edge потому что мы по <!-- TODO: Неразборчиво --> верстали плохо поглядывая на другие браузеры операционных систем.
Но в общем сайт для разработчиков, думали мы, и так сойдёт, да?

**Лёша.**
Ну да. Ну а что ты говоришь такими уловками: «плохо поглядывали». Да не поглядывали.

**Вадим.**
Я тестировал в Edge на виртуальной машине, но вот чё-то видимо не хватило.

**Лёша.**
Ну и кстати, там ведь не только 8 ишьей прислали - там их больше.
Просто именно те кто хотят поехать в Амстердам, потому что, конечно, нам прислали ещё небольшая пачечку ишьей от ребят, которые не хотят поехать в Амстердам, и им нравится там где они сейчас.

**Вадим.**
Ну да, может быть для кого-то проблемы не в стоимости билета, а в том что, не знаю, Амстердам это слишком далеко или React это не так интересно как хотелось бы.
В общем, разные штуки, где-то иконки, где-то там какие-то полосочки, где-то там атрибут `require` в Safari не работает.
Ну, разные-разные штуки, там, выравнивание кнопок.
Но, самым интересным нам показалось, баг, который не просто такая косметическая штуковина, а которая мешает смотреть сайт с самого начала, сайт неправильно загружается.
Мы забыли поставить `initial-scale` на вьюпорте, мы просто написали `width=device-width`.
Соответственно, страница загружаясь, конечно, принимает вьюпорт, но по умолчанию скейлится как минимум в мобильном Edge, мобильном IE неправильно.
Поэтому, виктория из Санкт-Петербурга предложила нам добавить initial-scale=1 и была совершенно права
И поздравляю Вас, Виктория, езжайте в Амстердам на React Amsterdam и напишите нам, мы Вам выдадим промо-код, бесплатно получите билет.

## Safari TP24 (05:04)

**Лёша.**
Safari Technology Preview 24 показали на этой неделе.
Они прям всё чётко делают каждую среду через одну среду, и в этот раз не забыли. Показали много интересного в этой версии.

Показали `Perfomance API` - это возможность прокидывать какую-то статистику, собирать её в более удобном виде.
Её можно, например, отправлять во всякую аналитику, в свою собственную статистику, или самим собирать, в общем, удобная штука, которой в Safari не было.

Добавили `<link preload>` как экспериментальную фичу, но вроде как я видел обсуждение в Twitter, что хоть это и фича экспериментальная, но вроде как она не за флагом, а включена сразу же, что-то такое было, вот.
И, конечно, самое большое, ну прости, Вадим, я понимаю, что это не для тебя самое большое, но самое большое для всех остальных - это то что добавили динамические импорты для ES6 модулей.
Это, всё-таки, важно и Safari тут, что странно на самом деле, показывается таким идущим впереди всех браузеров.

Ну и конечно же куча всего поправили, я уже даже сталь мельком читать эти чейнджлоги, потому что уже хочется чтобы они зарелизили Safari 10.1 и уже дали бы поиграть нам.
Потому что, ну сколько можно, когда они обещали - в марте?
А, они же не обещали, да, а есть только какие-то спекуляции?

**Вадим.**
Ну есть уже бета-версии Mac OS и iOS в которой этот Safari Technology Preview просто встроенный обычный браузер Safari и в общем, в принципе, есть какое то расписание у этих бет.
То есть можно примерно представить у них там релиз-кандидаты этих бет и разные-разные состояния.
То есть можно в принципе прямо сейчас поставить и получить свои динамические импорты.
Но, я думаю, лучше дождаться конечно финального и предположения про март вполне себе обоснованы

**Лёша.**
Не, ну динамические импорты это, конечно, хорошо что они появятся в Safari, но это не то ради чего мы ждём его.
Потому что ты же не сможешь их использовать сразу сейчас если у всех остальных браузеров всё отвалится.
Я бы, конечно, хотел, но увы не могу.

**Вадим.**
Ну как, подожди, если у меня работает, значит, у всех заработает.
Разве не так?

**Лёша.**
А, ну это ты как с вёрсткой pitercss.com

**Вадим.**
Ну, типа того.
Меня в этом релизе больше всего, конечно же, порадовал `<link preload>`, потому что вы можете не пользоваться всякими трюками, скриптами и прочим для предзагрузки ресурса, а можете их вполне себе удобно планировать.
Там ведь можно подгружать картинки, можно подгружать шрифты, стили, и так далее, и оно всё очень хорошо работает в браузере если вы  понимаете что на странице потребуется что-то другое или третье.
Как мы раньше подгружали картинки, помните?
Это скрипты Macromedia, в `img.src` создавался объект и загружался, ну в общем, безумные способы мы всегда использовали, а тут вполне себе удобная штука и браузер про неё с самого начала знает.
Он читает в шапке и понимает, что какой-то ресурс нужно предзагрузить, а не вы используете какие-то хаки, чтобы заставить браузер, поэтому он может планировать.
Соответственно, когда браузерные алгоритмы изменятся, соответственно, изменятся и алгоритмы `<link preload>`, потому что они будут учтены при изменениях.
Вот главный плюс встроенных фич в браузер, что они образуют единую систему, а не вам нужно на каждые изменения браузера подстраивать вот эти свои трюки и хаки.

## Как работают браузеры в 2017 (08:43)

**Оля.**
На этой неделе вышла огромная статья Санджая Пурсвани [Оптимизация фронтенда для браузеров](https://dev.to/sanjsanj/optimising-the-front-end-for-thebrowser).
Действительно, огромная, очень подробная, очень, такая вот, чётко всё рассказывающая статья на английском языке пока, но, наверняка, кто-нибудь переведёт в скором времени.
Я когда её читала, конечно, у меня возникло впечатление, что это было сказано уже 10 лет назад всякими корифеями нашего фронтенда.
Но, тем не менее, если вы новичок - это очень хорошее руководство о том как сделать загрузку ваших сайтов гораздо быстрее.

**Вадим.**
Мне эта штука напоминает скорее такое, знаете, исследование, которое Санджай провёл для того чтобы оптимизировать фронтенд какого-то своего проекта.
То есть он сел и скомпилировал, и изучил вообще всё что на эту тему есть, и вот в виде такой штуки сделал.
В принципе, из неё можно сделать чек-лист, довольно легко по структуре.
Там это 6 шагов: оптимизация от HTML до конечной отрисовки.
Поэтому, наверно, это действительно просто пути оптимизации его собственного проекта, и подобные исследования можно взять за основу если у вас есть новый проект, и вы готовы, и вы хотите сделать его лучше, видимо можно, вполне себе, пройтись по  этой статье и понять, что вы можете сделать, что вы уже сделали.
Оно, действительно, напоминает многие другие исследования, то есть там «как работает браузер», и доклады, и статьи были, и много чего интересного я на эту тему читал.
Обычно все эти статьи огроменные и вот эта вот тоже на них похожа.
Но, в целом, я бы, наверно, не рекомендовал прям новичкам, потому что новичкам лучше, конечно, полагаться на то как браузер сам всё оптимизирует и идти по спецификации, допустим.
А вот если вы прям вот серьёзно взялись оптимизировать, то это такое комплексное решение, ещё и с картинками если вам понимание важно, а не просто сухой чек-лист.
Так что, интересный труд.
Я прям вижу в каком-нибудь блоге Mail.ru на Хабре переведённое в ближайшие пару недель, потому что ребята оттуда берутся переводить очень большие статьи и прям вот такие монолитные штуки выходят.
Вот недавно	Эдди Османи труд про [оптимизацию старта JavaScript](https://habrahabr.ru/company/mailru/blog/321748/) вот тоже в мэйловском блоге. Так что ждём, ребята, перевода.

**Лёша.**
Ты думаешь, что ребята из Mail.ru просто нас слушают и статьи переводят?

**Вадим.**
А что, нас кто-то не слушает, подожди?

**Лёша.**
Ладно, Бог с ним.
На самом деле, я не согласен с тобой.

**Вадим.**
Первый раз.

**Лёша.**
Угу, вот так новость!
Ты просто говоришь, что новичкам ты не советуешь, а я не знаю.
Мне вот кажется что, ты вот просто говоришь, что «отдать на откуп браузеру, он там сам всё оптимизирует».
Но тут ведь немножко глубже, тут не какие-то трюки, которые тебе нужно делать чтобы на несколько наносекунд всё было быстрее. Нет!
Тут же просто оптимизация от глубокого понимания как оно всё работает.
То есть, что за чем начинается, где когда что останавливается, что когда кого ждёт там и так далее.
И когда ты это понимаешь, это не какая-то конкретика, это когда у тебя есть это понимание ты просто более правильно используешь те вещи, которые ты знаешь и, не знаю, ты можешь впихнуть стили куда угодно, заинлайнить всё подряд или в `base64` сделать картинки все и вставить их прямо в контент или, я не знаю, всё скриптами, кучу файлов сделать.
Это вот новичок легко может сделать и браузер ему тут не поможет, и какое-то общее понимание что за чем идёт, мне кажется, оно полезно.

**Вадим.**
Мне кажется, что  новичку не стоит знать про дерево рендеринга и про всякие `CSS Object Model` и прочие истории, потому что есть ведь другая крайность.
Можно ведь увлечься и переоптимизировать всё настолько, что сделать очень много ручной работы, которой в итоге занимается браузер.

**Оля.**
Мы перед выпуском говорили, что на этой неделе у всех бомбит.
Вот у меня сейчас просто бомбануло, Вадик, от твоих слов, серьёзно!
Нет, новичку обязательно надо знать как работает браузер, как он рендерит страницу, прям вот, я считаю, что это первое что он должен узнать, потому что это базовая какая-то вещь.

**Лёша.**
Это не практическое какое-то руководство, а именно понимание.
То есть, как работает тот инструмент с которым они собираются работать ближайшие несколько лет.

**Вадим.**
Наверно, у нас разное с вами понимание про новичка.
Для меня новичок - это человек, который вчера ничего не знал про браузеры, а сегодня сел и написал свою первую страницу.
Видимо, для вас новичок это человек, который уже может сверстать что-то, сделать что-то, и, в принципе, он уже может работать, но он мало что знает, да?

**Оля.**
Знаешь, мне кажется, что есть некая разница.
Мы, наверно, с Лёшей рассматриваем образование более фундаментально, да?
То есть нужно дать фундамент новичку прежде чем он начнёт делать свою первую страницу.
А ты, видимо, идёшь от практики.

**Вадим.**
Ну да, я просто с самого начала и шёл от практики.
Я думаю, все сидящие здесь начинали с того что они просто пробовали, методом тыка понимали что как на самом деле работает.
И это, естественно, кажется нам более естественным путём развития обучения.
Но если прям лезть в такие хорошие большие статьи, наверно, она может, если её грызть по кускам - вот её масштабы тоже немножко могут ошеломить - если её грызть по кускам, типа «сегодня я пошёл шаг первый - я знаю как работает HTML», наверно, она зайдёт.
Просто, правда, монолитная такая большая штуковина.

**Оля.**
Ну, честно, мне не показалось что это какая-то Rocket science, какие-нибудь основы сетей, которые дают в любом университете гораздо сложнее.
А здесь, ну прям, всё очень просто.

**Лёша.**
Просто посмотри на то как разбирают вот каждый этот этап.
И тут же он и советы даёт.
Например, подключать стили в начале, а скрипты в конце.
Ну, какой здесь Rocket science?
Это понятно, так и надо делать.
Ты просто исходишь из мысли того, что новички это и так откуда-то узнают.
А может они это узнают как раз отсюда.
Или ты хочешь чтобы они подключали скрипты наверху, а стили внизу?

*Вадим.*
Не, я хочу чтобы была отдельная статья, типа «Пишем HTML правильно».
Через неделю: «Пишем CSS правильно» и так далее.
А вот это вот большое монолитное, монолитный труд: «Мои 6 шагов к быстрому рендерингу страницы», - они могут ошеломить.
Вот, только об этом.

**Лёша.**
Как ты объяснишь разницу в джаваскриптовых подключений просто с атрибутом `async`, с атрибутом `defer` если ты не понимаешь?
Там вся разница за счёт того как происходит рендеринг страницы.
Иначе не объяснишь.
Ты сказал про 6 этапов, но на самом деле 6 этапов это только половина статьи.
Вторая половина статьи она про нетворкинг, который не про эти 6 этапов, а про то что эти 6 этапов проходит каждый ресурс, и как эти ресурсы подключаются, как они встраиваются в этот процесс, как они в этой пачке появляются.
И это тоже важно.
То есть, какие ресурсы когда браузер подключает, почему основное правило выносить - всё кроме важных стилей и важных скриптов куда-то в асинхронные, загружать картинки после, загружать дополнительные скрипты после, стили загружать после, по возможности, шрифты, обязательно, после загружать.
Это ж всё почему так происходит?
Потому что есть понимание того как браузер это загружает.
А почему это важно - потому что каждый кусочек этого ресурса будет проходить все эти 6 этапов.
И чтобы показать вашу страницу, нужно пройти через всё это.
Это достаточно сложно, долго, и когда у тебя есть вот это вот понимание, как это всё строится, тебе потихонечку становится легче.
И более того, на тех же самых базовых интенсивах Академии, Вадим, на первой лекции, объясняется как браузер работает.
Вот эта вот любимая статья: «Что делает браузер, когда я ввожу URL-адрес?», - там ведь куча всего.
И про нетвокинг там объясняется.
Это очень рано, да, люди, возможно, только что, я не знаю, статьи на журфаке писали.
А сейчас им рассказывается какая-то жесть.
Ну, без этого никуда, как иначе?

**Вадим.**
Ну, и если вам эта статья кажется знакомой, то вы возможно видели статью «Как работает браузер», Санджай упоминает её и, на самом деле да, есть совместно большая [статья на HTML5 Rocks](https://www.html5rocks.com/ru/tutorials/internals/howbrowserswork/), в общем-то есть и видео встроенное и он ссылается.
Поэтому, если вы читали ту самую статью 2011 года, господи, как давно это было, то, может быть, вы узнаете что-то новое из этой, потому что, видимо, она посвежее.
Тут упомянуты какие-то реализации, какие-то новые механизмы.
Ладно, уговорили, буду рекомендовать новичкам, отстаньте уже!

**Лёша.**
Ну, на самом деле, перевод был бы, и правда, здесь полезен, потому что она такая, она хорошая, здесь есть много очень простых концепций, а есть очень сложные концепции, типа, я не знаю, сколько байт в одном TCP-пакете и почему нужно пытаться укладываться в него и так далее, что вот уже to-match, но есть и простые концепции.

**Оля.**
Ну, в общем, мы желаем читателям не ошеломляться, а постараться это всё осилить.

## Кастомные свойства (18:56)

**Оля.**
Ну и к слову о Rocket science.
На CSS-live вышел перевод статьи [Трюк: раздельные функции CSS-трансформации](http://css-live.ru/tricks/tryuk-razdelnye-funkcii-css-transformacii.html) и вот я прям осилила, на самом деле, с трудом.
Тут весь смысл в том, что для CSS-трансформаций предлагается использовать CSS-переменные.
Я каждый раз когда вижу CSS-переменные вот эти вот в чистом виде, у меня просто мозг заклинивает и там что-то происходит, вообще очень сложно.
Вадим, может ты мне объяснишь на простых словах, что там происходит?

**Вадим.**
Ну, представь себе что, допустим, у нас есть свойство `background` а в нём есть там `url()`, координаты, повторять/не повторять, масштабирование и всё остальное.
И представь, что у нас нет отдельных свойств `background`: `background-color`, `background-position`, `background-repeate` и так далее.
Это очень неудобно.
Тогда нам приходится задавать одним свойством `background` и если мы хотим дополнить, то есть, в каком-то месте сменить координаты, в каком-то месте переключить повторение или ещё что-нибудь такое, картинку просто поменять - нам приходится переписывать всё свойство и дублировать код.
Это было бы очень неудобно.
И такая ситуация у нас, на самом деле, есть со многими свойствами, которые принимают несколько значений, разделённые пробелами, и отдельно эти значения не поменять.
По какой-то причине авторы спецификации не разделили их на части.
Из этого есть разные выходы.
Вот, допустим, свойство `transform` - его порубили на части и у нас есть отдельные функции `translate`, `rotate` и `scale`,  которые уже поддерживаются в Chrome Canary и когда-нибудь будут поддерживаться во всех остальных браузерах.
Допустим, вам нужно элемент повернуть: вам не нужно писать свойство `transform`, а сразу вы используете такое вот свойство, я не знаю, `rotate` и задаёте градусы, то есть не функцию.
Соответственно удобно.
У вас элемент уже повёрнут, допустим, он трансформирован как-то, а вам нужно его повернуть - вы берёте и добавляете поворот или меняете поворот, а не переписываете всё свойство.
И в этой ситуации, понятно что, помогают отдельные свойства, но отдельные свойства есть не для всех свойств, которые хочется разделить на части.
Отдельные свойства до сих пор не поддерживаются и, возможно, вместо отдельных свойств туда можно в эти функции прокидывать переменные и менять уже переменные.
Поскольку всё происходит в runtime а не PostCSS-ный вариант какой-нибудь, соответственно, вы получаете живые свойства, допустим, в этом случае с трансформацией.
Что интересно, из-за того что все эти `rotate`, `scale` и `traslate` они, на самом деле, в итоге складываются в матрицу, которая браузером пересчитывается динамически и изменяет положение объектов в пространстве вашей страницы.
Как бы вы там не меняли порядок применения этих отдельных свойств - `rotate`, `traslate` и `scale` - в итоге браузер, по-моему, всё равно применит как если бы вы записали их в порядке `traslate`, `rotate` и `scale`.
И в итоге, если вы туда прокидываете CSS-переменные, вы всё равно получаете определённый жёсткий порядок.
А если вы хотите прям вот менять порядок применения трансформаций, вам нужно уже внутри `transform` писать целиком свойства.
В общем, с одной стороны получается гибко, что мы можем менять отдельные свойства.
С другой стороны, получается, что мы всё равно не можем нормально управлять так же гибко, поэтому приходится менять свойства внутри `transform`.

**Лёша.**
Ты немного ошибся: там `translate`, `scale`, `rotate` - `scale` с `rotate` наоборот, ну, `translate`, я помню, что он первым всегда идёт.
И интересно, что эти вот отдельные свойства не позволяют отдельно ещё писать XYZ-координаты, то есть это пока не решено в спецификации.

**Оля.**
Ну на самом деле это вот первый случай который я вижу, где CSS-переменные очень годно применены.
Вот в остальных всех случаях, там, цвет ссылочки можно и так поменять, а здесь прям вот по делу.
Кстати, где они поддерживаются сейчас?

**Вадим.**
Во всех браузерах зеленоватых - браузерах которые часто обновляются они поддерживаются.
В ночных сборках, ладно, не в ночных - в тестовых сборках Edge уже поддерживаются кастомные свойства.
Так что всё хорошо.

**Лёша.**
Ну да, то есть во всех браузерах поддерживаются кроме Edge.
Edge на подходе.

**Оля.**
Ну, относительно.
Вы так говорите как будто IE 11 там никому не нужен и Edge обычный стабильный тоже никому не нужен.
На самом деле, там большая аудитория сидит.

**Вадим.**
На самом деле, скорее, в этих статьях и в похожих докладах или исследованиях мы просто нащупываем, как мы в итоге сможем применять CSS-переменные или кастомные свойства так, чтобы они имели смысл.
Потому что за ними чувствуется какая-то мощь и потенциал, но вот мы сейчас нащупываем зачем они нам нужны.

**Лёша.**
Мне кстати кажется что вот эта вот спецификация новая с отдельными свойствами для `transform` - это идеальный случай для [плагина на PostCSS](https://github.com/jonathantneal/postcss-transform-shortcut "PostCSS Transform Shortcut").
Вот прям по-моему лучше придумать нельзя.
Потому что ты хочешь использовать их уже сейчас, поведение никак не меняется, а меняется только синтаксис.
Но ты не можешь использовать их сейчас потому что ну только в Canary это поддерживается, в остальных браузерах фиг знает когда это будет.
И это очень похоже на `autoprefixer`.
То есть ты используешь раньше чем браузеры могут, но так как у тебя этот функционал и так есть, а тебе просто синтаксис нравится новый, вот, по-моему, идеальный вариант для PostCSS плагина, и по-моему он есть.

**Вадим.**
Да, плагин точно есть, но тут вот есть терминологическая сложность.
Я читаю свой доклад про ванильный CSS, называю вот эти такие штуки «сахаром», «синтаксическим сахаром».
Но ведь есть сахар который как бы совсем безобидный в ситуации вот с этим `transform` и отдельными функциями.
А есть сахар который убирает точки с запятой, скобочки фигурные и прочее.
Видимо, нам нужно разделить, придумать какое-то название, допустим, «синтаксический сахар» и «синтаксический сироп», или там не знаю, «синтаксический клей» какой-нибудь.
Ну, потому что некоторые вещи, вот как ты сказал, действительно, помогают писать удобнее, но по сути не меняют порядка применения и не мешают нам потом от исправлений с помощью PostCSS.
А некоторые прям сильно мешают и прививают какую-то зависимость от синтаксических решений.

**Лёша.**
Я не зря привёл в пример `autorefixer` потому что тут как раз таки именно то как используется он - вы используете его пока браузер не поддерживает, потом выкидываете и всё.
То есть максимально не думаете об этом.
И это то что будет в браузерах, поэтому я не знаю, стоит ли отдельно придумывать какое-то название тому, что никогда не будет в браузерах.
Ведь есть просто «по спеке» и «не по спеке».
Этого не достаточно?

**Вадим.**
Ну нет, просто мы смотрим на свойства какое-нибудь, функцию в CSS и думаем: «она по спеке».
Но то как она работает в итоге, мы либо используем её не полностью, и мы не используем её динамический потенциал, как с CSS-переменными, которые в PostCSS можно использовать сейчас - они будут статическими.
То есть как будто мы используем их, но на самом деле нет - мы используем только малую их часть и не самую мощную.
То есть тут в этом месте очень легко запутаться и в итоге потерять огромный потенциал фичи, когда она станет доступна динамически.

**Лёша.**
Я ещё хотел вернуться вот к этому решению на CSS-переменных.
Не знаю, мне оно кажется каким-то большим оверхэдом.
То есть, возможно, оно как пример как мы можем использовать кастомные свойства - Ок, но в плане применимости, вот в конкретном случае, ну это реально какой то оверхэд.
Потому что, что тебе мешает написать `transform` просто?
Ведь разницы никакой.
То что тебе нужно где-то в переопределениях повторить это - ну да, ну ничего страшного.
С другой стороны, если у тебя `autoprefixer` уже  стоит, и PostCSS уже стоит, то тебе вообще об этом думать не нужно.
Ты можешь просто это использовать сейчас.
А наворачивать эти кастомные свойства, у которых поддержка не такая хорошая как у `transform`, ну вот знаешь, решение оно такое, да, посмотреть как можно будет использовать когда-то в будущем CSS-переменные - Ок
Но вот для того чтобы использовать новые свойства для трансформации - вообще не нужно, мне кажется это даже контрпродуктивно.

**Вадим.**
Ну я помню, что я регулярно ошибался из-за того что мне приходилось такие монолитные свойства повторять, и потом я забывал в каком-то месте поменять значения - это приводило к ошибкам.
Там по `hover` надо сменить трансформацию, а ты её описал раньше, и тебе нужно её целиком скопировать и потом не забыть её поменять если вновь в первом месте меняешь тоже.
Но, на самом деле, в этой статье уже проклёвывается, проглядывается момент, когда мы можем начинать проектировать наши компоненты в CSS.
Не просто писать код, а проектировать, то есть заводить какие-то переменные в начале в контексте `root` или в контексте нашего компонента, продумывать их значения, обозначать их переменными, а потом уже использовать, менять и так далее.
То есть, это немножечко ещё архитектурный подход, когда у вас что-то сложное происходит, и вы можете обозначить это переменными а потом модифицировать, присваивать, переназначать и так далее.
Мне кажется, это сделает CSS более похожим на языки программирования, с одной стороны.
С другой стороны, мы не будем повторяться, мы будем допускать меньше ошибок.
Ну ладно, понятно что это всё направлено на будущее и...

**Оля.**
Не, ну подожди, препроцессоры нас этому уже научили, уже сколько лет этим препроцессорам?
Мы там делаем всё то же самое, точно так же проектируем.
Выделяем какие-то миксины, инклюды и так далее, считаем, делаем функции.
Просто сейчас это будет нативно, но, я думаю, многие уже и так умеют всё это делать.

**Вадим.**
Ну, проблема с подходом препроцессорным в том, что они сильно ограничивают возможность переопределения, доопределения, изменения динамического этих переменных.
То есть, они просто делают невозможным это.
Поэтому нам нужно сделать следующий шаг, понять что это может происходить динамически в runtime.
То есть, мы можем в зависимости от какого-нибудь `hover` взять и поменять очень много всего, не писать всю батарею кода, типа, в каком-нибудь `hover` ты можешь взять и изменить значение переменной, и у тебя весь предыдущий код изменится тоже, основанный на этой переменной.
Вот я к этому веду, мы этого пока не понимаем.

**Оля.**
Ну почему, ты с препроцессорами тоже ничего не пишешь, происходит компиляция и то что тебе там выдано.
Ну да, там кода больше, чем если бы ты написал нативно, но всё равно, когда ты пишешь CSS код, ты этого не делаешь.

**Лёша.**
Тут основная разница в том, что в препроцессорах ты получаешь в итоге CSS готовый, скомпиленный, а с кастомными свойствами ты получаешь возможность ими манипулировать прямо там, на странице в браузере.
С помощью JS, с помощью других изменений.
С препроцессорами ты этого не получаешь.
Это, в принципе, основная разница.
Там  есть ещё всякие разные штуки, типа как каскадность и всякой такой фигни.
Но ладно, давай это опустим.
Просто, ты не можешь манипулировать своими SASS-переменными из JS.
Не можешь ведь?

**Оля.**
Нет, но зачем это делать если ты можешь менять CSS.

**Лёша.**
Вот!
Зачем это делать?
Понимание зачем это делать ещё не пришло, потому что это то, что будет в будущем.
Сейчас нельзя это использовать, IE 11, как ты говоришь, не поддерживает, текущий Edge не поддерживает.
Поэтому никто даже пока не думает из, ну так, условно назовём это, практиков, кто каждый день фигачит лэндинги не думает о том как это им изменит потом их подходы.
Так как `flexbox`, ты долгое время не думала о них, а потом поняла и влюбилась в них, ну например.

**Оля.**
Нет, я хотела просто защитить нашу привычку к архитектурному подходу.
Она есть, и она есть уже много лет.
А то что в runtime этим можно пользоваться, ну, как бы, классно, но немножко разные вещи.

**Вадим.**
Ну вот у меня есть такой пример.
У нас на сайте, не знаю, есть 2-3 темы цветовые.
Сейчас чтобы иметь 2-3 темы на сайте нам нужно иметь 2-3 идентичных файла, больших файла, в которых написан CSS, в которых все цвета захардкожены, все их модификации захардкожены.
Три файла!
Когда переменные можно будет использовать динамически мы можем иметь один файл, а JS-ом просто выставлять на нужный элемент изменения переменной или подгружать другой CSS, в котором эта переменная изменена, допустим, и на основе этого файла, как шаблона,  динамически изменять тему сайта в зависимости от прокинутого цвета.
А внутри этого CSS - изначального CSS темы - уже там цветовыми функциями как угодно изменять, модифицировать и использовать на основе цвета. То есть, один файл против трёх файлов.
То есть, мы идём к динамическому использованию, переменному, как в JS.
Ведь мы в JS не объявляем переменные, нам потом транспайлер проходится и прописывает все значения, иначе это было бы, ну нереально.
JS бы так не работал просто.

**Оля.**
Три файла не нужны.
Делается класс внутри одного файла.
Класс на `<html>`, который переключает тебе темы.
Конечно, я согласна, резонно, что кода будет больше.
И когда CSS-переменные войдут уже в нашу жизнь плотно, конечно, всё будет лучше с точки зрения той же оптимизации, о которой мы говорили чуть ранее.
Нет, всё хорошо, просто пока немножко преждевременно.

**Вадим.**
Ну да, мы как обычно мечтатели здесь и хотим чтобы всё случилось раньше.
Но почему эти статьи ценны?
Потому что мы заранее начинаем понимать и продумывать, а не когда уже всё появится, а мы уже настолько привыкли к препроцессорам что нам и не нужно.
Ну, в общем, давайте, раз уж мы тут занимаемся образованием и новостями, не бояться фантазировать.
Ну и к моему слову про архитектурный подход: Серджио Гомес продолжил писать про кастомные свойства на этой неделе и написал статью, что [кастомные свойства это ваш новый API](https://sgom.es/posts/2017-02-17-css-custom-properties-as-your-api/ "CSS Custom Properties as your API").
Он здесь предлагает задуматься о том, что CSS теперь можно использовать не как инструкцию, в которой уже всё готово, её нужно подключить и уже на уровне HTML всё менять.
Ведь можно использовать CSS как шаблон, в который потом прокинуть переменную, и он приводит хороший пример, когда у вас, допустим, подгружается библиотека с сетками, в которой не обозначено количество колонок.
Или обозначено, но вы хотите его переопределить, соответственно, вы создаёте переменную `my-grid-columns-2` и у вас layout на этой странице двухколоночный.
А загрузили всего один файл CSS, и в HTML ничего менять не нужно, просто можете там стилем задать количество колонок на уровне вот этого.
Ведь можно переменную задавать в каждом блоке, то есть у вас на уровне `<body>` 2 колонки, а на следующем уровне, где вы переопределили эту переменную, тот же самый класс, один и тот же класс, допустим, `columns`, станет трёхколоночным, потому что на его уровне вы поменяли переменную.
То есть, удивительные вещи которые позволят нам, в итоге, разгрузить HTML от количества классов, которые мы в виде модификаторов расставляем, и задавать там конкретные переменные, и это очень-очень круто.
В общем, Серджио продолжает, с нетерпением ждём новых статей, потому что он очень классно разбирает кастомные свойства.

## Make great again (36:16)

**Лёша.**
Предлагаю немножко поговорить про юбиляра.
Дело в том, что в этом году кое-кому исполнится 40 лет.
Он, наверно, старше нас раза, не знаю, ну, не в 2, а может быть, кстати, кого-то и в 2 раза среди нашей аудитории.
Такой дедушка среди наших инструментов.
Ну что, поговорим?

**Вадим.**
Ты про Антона Епрева?
Нет, он моложе чем 40 лет, но он [написал](http://eprev.org/2017/02/20/make-as-a-front-end-development-build-tool/ "Make as a front-end development build tool") про `make`, которому исполняется 40 лет в этом году.
Дедушка, ладно, в 40 лет это ещё не дедушка, но в общем-то он ещё жив и будет жить ещё долго.
Эта штука, которую придумали 40 лет назад для того чтобы делать какие-то безумные вещи в подвалах университетов, я не наю даже зачем.
Но сейчас я сам иногда пользуюсь `make` чтобы деплоить, например.
У меня там записана единая строчка, `task-default` какой-нибудь, и через команды я просто деплою с помощью `rsync` какой-нибудь проект куда-нибудь без того чтобы мне думать о том что мне нужен `package.json`, что мне нужно установить какие-нибудь зависимости, написать какой-нибудь `gulpfile.js` или написать какие-нибудь npm-скрипты.
Я просто беру и обычную консольную команду заворачиваю в файл, который запускаю командой `make`, которая есть на всех юниксовых системах.
На Mac по умолчанию она не работает, но этот же способ я использую, когда хочу поставить на Mac инструменты для разработчика.
Я открываю свежий Mac, на котором вообще ничего нет, открываю терминал, пишу там `make` и он говорит: «Поставить инструменты разработчика?»
Скачивает, ставит, и после этого я уже могу пользоваться всеми остальными штуками.
Но Антон рассказывает более подробно как не просто одну команду запустить, как там использовать переменные, как использовать всякие штуки, но это всё, попахивает башем и имеет чёткий привкус `shell`.
40 лет назад взгляды на программирование, взгляды на то какими должны быть API и возможности языка или какой-ибудь системы командной, были другие.
Я понимаю, что все возможности языка писались так, чтобы точно влезть в экран шириной 480px.
Он такой, очень локаничный, немножко странный и непривычный для фронтендера.
Наверно, поэтому все так радостно пишут конфиги для деплоя или для какой-нибудь сборки на JS, который синтаксически более привычен.
То есть, если вы в консоли готовы запускать какие-то команды с параметрами и понимаете как работает вот эта вот вся история с `shell`, ну более или менее, вам `make` пригодится.
И если вы хотите просто одной командой rsinc-ом копировать файлы с вашей локальной машины на внешний сервер, `make` вам тоже очень пригодится.
Поэтому не думайте, что он страшный, немовременный и так далее.
В него очень легко войти, вот реально.
Написать одну команду которая что-то делает проще простого.
Вот если вы хотите сделать что-то более сложное, вот в этом месте, мне кажется, вам нужно написать то ли npm-скрипт, то ли `gulpfile.js` какой-нибудь, и уже делать в вашем привычном мире, потому что вам не нужно изучать новый язык.
Вы сделаете меньше ошибок, и в итоге то что вы напишете будет более читаемо.
Вот я знаю, Лёша, ты любишь npm-скрипты за то что не нужно ставить никакие зависимости, ты просто берёшь и в понятном языке скрипты прописываешь удобно.
Тебе `make` ближе чем `gulp`?

**Лёша.**
Какой-то очень странный вопрос.
У меня есть на make скрипты, конечно же, и что значит ближе?
Я не пишу каждый день на `make`, поэтому ближе мне, конечно JS.
Но вот про что ты говорил, возвращаясь к моему какому-то прошлому давнему постулату, что не нужно наворачивать ничего сложного, то с `make` оно никуда не девается.
Почему я говорил про npm-скрипты тогда вместо `gulp`, и почему, например, я буду писать npm-скрипты а не `make` файл в моём JS проекте?
Да потому что в этом JS проекте уже есть npm, уже `node.js` есть.
Это не что-то, что я принёс в этот проект ради того, чтобы написать автоматизацию.
Нет, она там нужна для того чтобы мне подключить зависимости и кучу всего, он уже там существует.
Конечно же в рамках существующей экосистемы проще будет писать не на `make` а в привычном синтаксисе, используя привычные библиотеки.
Если его там нету, то зачем его туда приносить в проект, который совершенно не на JS, зачем приносить какие-то джаваскриптовые штуки?
Конечно я напишу на `make`.
Или если это какая-то штука со своей экосистемой, где есть свои инструменты, ну я напишу на них.
Таких примеров много, вот у меня есть несколько `ruby` маленьких проектов. Там `race` используется, в принципе `race/make`, ты можешь догадаться, что это одно и то же.
Ну, не одно и то же, но тебе этого достаточно.
Я, да, не люблю когда в проект попадают сущности не знаю ради чего.
Вот `gulp` впихнуть в проект в котором нету JS вот это вот странное что-то.

**Вадим.**
Ну я тоже вот только сообразил, что, на самом деле, `make` я чаще всего использую там где у меня просто какой-нибудь `index.html`, папка с картинками и всё.
И никакой сборки даже нет.
Просто мне нужно какую-нибудь заглушку для сайта деплоить, по ходу дела копировать какие-то файлы или вызывать какую-нибудь команду, которая что-то делает.
И действительно, там проще всего сделать `make`, потому что `package.json` в этом проекте вообще нафиг не нужен.
И да, я согласен, приводить в какой-нибудь проект на `PHP` `node.js` только ради того чтобы что-то красиво деплоить, например,  странно.
Но если тебе нужно обработать какую-нибудь статику и ты знаком с этими инструментами, наверно можно туда его пропихнуть.
Но, опять же, выбор каждого.
В общем, как обычно, не стартуйте проект с конфига `webpack`, не стартуйте проект с создания `gulpfile.js`, а пишите суть, а потом уже разбирайтесь какие вам инструменты нужны.

**Лёша.**
Ну и надо сказать, что синтаксис у `make` он такой непривычный, можно сказать, для хищников, потому что это совсем непривычная штука, и может показаться что «о боже мой! Лучше я заведу ещё 100500 пакетов, чтобы оно как-то работало».
Да, Оль?

**Оля.**
На самом деле, с лёгкой руки Вадика я использую `make` скрипты для очень простых вещей.
Один собирает сайт на `Jekyll`, а второй его деплоит.
И это классно, это просто и очень быстро и гораздо проще чем то, что пыталась навернуть я, пока Вадик не принёс мне эти `make` скрипты.
На самом деле, привычка к ноде и ко всем инструментам, связанным с ней, она иногда очень сильно переусложняет всё.

**Лёша.**
Ну да, тут просто это вопрос общего кругозора.
То есть `make` он всегда был, и на самом деле, первые автоматизации которые я делал до того ещё как появились `npm` и все остальные, они были на `make`, почему нет?
Потом какой-то другой инструмент был, то есть, всегда так делали.
Просто потом нашли способ, который немножко упрощает и увеличивает вхождение людей в вот эту историю про автоматизацию.
Потому что у автоматизации пошёл такой рост большой во фронтенде тогда, когда это получилось делать с помощью JS.
На самом деле, сначала с помощью [CofeScript](http://coffeescript.org/), если вы помните.
Потому что в CofeScript был `cace` (`race`, `make`, вот это вот всё), а потом уже на `npm` можно было запускать таски.
Ну и дальше уже таскраннеры и так далее, вот.
Автоматизацией всегда занимались, просто другими инструментами, но то что сейчас ты можешь делать автоматизацию на том же языке, на котором пишешь — это конечно всё упрощает.

**Вадим.**
Тут ещё есть момент, связанный с тем что какие-то инструменты кажутся, знаете, такими, ну «они всегда там были и они всегда есть».
Если вы какой-инбудь UNIX рассматриваете, то там всегда есть `make`, и это удобно.
Но если, я не знаю, в UNIX через 10 лет будет по умолчанию стоять нода и `npm` какой-нибудь, ещё что-нибудь такое, `gulp` станет пакетом must-have на UNIX, который там всегда есть, что-нибудь такое.
Звучит немножко безумно, но а кто знает.
Я думаю авторы `make` не подозревали, что через 40 лет о нём кто-нибудь будет писать.

**Лёша.**
Не знаю, не уверен.
По-моему они вот так и хотели.

**Вадим.**
Ну в общем странные люди 40 лет назад писали код.
Я думаю, про нас то же самое скажут через 40 лет.

## Новый HTML-заголовок (45:28)

**Лёша.**
На этой неделе было много разных безумных обсуждений, и я бы хотел спросить, Оль, у тебя.
Ты хочешь новый тег `<h>`?

**Оля.**
А, ну, когда я почитала вот эту вот статью, я подумала, что да, я его хочу.
У меня очень часто бывают моменты, когда ты делаешь какой-то модуль, ты не понимаешь реально каким он будет по номеру заголовком на странице.
Ну не знаешь ты какой он.
И если бы браузер сам как-то мог узнавать какой он и ставить ему соответствующий приоритет, было бы очень классно.

**Вадим.**
Но на самом деле браузер уже так делает, и если ты сейчас внутри `<section>` положишь `<h1>`, потом положишь ещё один `<section>` и положишь ещё туда `<h1>` и так далее, браузер уменьшит размер этого `<h1>` в зависимости от вложенности, и все `<h1>` не будут одного размера, а будут уменьшатся.
Это потому что браузер как будто бы пытается внедрить алгоритм `outline`.
Ладно, давайте по порядку.

Вышел перевод статьи на CSS-live [Нужен ли нам новый заголовочный элемент? Мы не знаем](http://css-live.ru/html5/nuzhen-li-nam-novyj-zagolovochnyj-element.html) Джейка Арчибальда, и он рассказывает как в недрах github W3C проходит работа над новыми идеями.
И там, в частности, Джонатан Нил, предложил новый элемент `<h>` без номера, просто `<h>`, для заголовков.
Его главный плюс в том что, как ты, Оля, правильно сказала, рассчитывается автоматически в зависимости от вложенности.
И это всё подняло бурю обсуждений, там засветились и наши соотечественники: Марат Таналин и другие люди.
Я тоже попытался что-то там пописать, но понял, что дискуссия катится куда-то не туда и радостно отписался.
Но Джейк очень хорошо суммировал всё, и там он, на самом деле, в этой дискуссии играет скептика.
Почему скептика?
Ну смотрите, чтобы этот элемент `<h>` заработал, нужно нам понять, что нужно реализовать.
И главное, что нам нужно реализовать — это механизм `outline` в браузерах.
Это такой механизм, который генерирует структуру документа и её могут использовать всякие альтернативные средства доступа к странице, вроде экранных читалок.
Поскольку алгоритма `outline` нет, и поскольку спецификация уже разрешает использовать один заголовок одного уровня, допустим `<h1>`, в ваших документах, то этот элемент `<h>` разницы никакой не сделает.
И Джейк об этом как раз и пишет, что, мол, ну хорошо, мы введём элемент `<h>`, ситуация вообще никак не поменяется, потому что всё это заработает только тогда, когда в браузерах появится алгоритм `outline`.

А что это вообще такое?
Это такая мифическая штуковина, которая описана в спецификации HTML, но никак не реализованная, к сожалению, ни в одном из браузеров.
Есть всякие синтетические инструменты, которые позволяют вам построить `outline` вашего документа, но на самом деле, это просто инструмент.
Браузер, на самом деле, так не делает.
Зачем это нужно?
Представьте, что у вас есть какой-нибудь Google Doc или просто документ в Word.
У вас есть там название его и заголовки первого уровня, второго уровня, ещё что-то такое.
И по сути, у вас есть структура и есть вид, что в Google Docs, что в Word, есть режим оглавления, или `outline` документа.
То есть, вы можете вывести такой вид вашего документа, который покажет вам только заголовки.
И глядя на эти заголовки вы сможете оценить логическую структуру документа и понять, что важно, и перемещаться по этим заголовкам.
Дело в том, что экранные читалки, они, когда видят ваш документ, ваше web-приложение, видят ваше что угодно, в вебе, в браузере, у них  есть возможность  включить навигацию по заголовкам, и, нажимая определённое сочетание клавиш, можно передвигаться от одного заголовка к другому.
Соответственно, выбирать какую часть сайта читать.
То есть, это самая интуитивно-понятная навигация по заголовкам.
Представьте, что вы взяли в руки газету.
Там ведь заголовки крупные почему?
Чтобы вы переключились в режим чтения заголовков.
Вы выхватываете то, что крупнее, потому что оно стилистически выделяется от обычного текста, и вы, по сути, включаете режим навигации по заголовкам.
Вы можете пробежаться по заголовкам статьи, выбрать какую вам удобнее читать и продолжить её читать.
Именно поэтому заголовки HTML, правильно использованные на странице, так важны.
Потому что по ним можно отдельно навигировать, когда вы их не видите.
Когда вы их видите это тоже помогает, но когда вы их не видите, правильная разметка нужна.
Соответственно, алгоритм `outline` позволит использовать любой заголовочный элемент, `<section>` внутри `<article>` специальным образом видоизменять, ставить `<h1>`, `<h2>`, `<h3>` и так далее, и структура будет строиться логически и автоматически.
Но это нигде не реализовано, поэтому у нас есть проблема, которую, на самом деле, элемент `<h>` не решает.
И элемент `<h1>` не решает, и спека не решает.
Решает только реализация.
А вот реализация застряла, и почему застряла — это отдельный вопрос.

**Лёша.**
Я, всё таки, хотел вернуться к элементу.
То есть `outline` и предназначение заголовков это здорово.
Но элемент `<h>`, и вообще все HTML элементы, они нужны для разработки сайтов.
Конечно же, для результата отображения этого всего, но вроде как, мы с этим справились, и так нету ни в каком браузере.
Мы просто исходим из текущей ситуации.
Так вот, в текущей ситуации, по моему, элемент `<h>` это упрощение и почему мы не должны упрощать?
Почему не дать возможность нам упрощать.
Вот например, отличный пример был про вложенный `<li>`, вложенные списки.
Браузеры же нормально справляются с этим.
Никто не хотел `<li1>`, `<li2>` или `<oi1>`, `<ol2>`.
Всё нормально сразу было.
Ок, когда-то в начале не подумали об этом, сейчас, так как веба уже очень много и не хочется сломать его.
Вот есть какое-то небольшое противостояние введению этого `<h>` элемента.
Но вообще по факту разработки, ведь `<h>` элемент был бы гораздо проще для использования, возможно.
Вот, например, наш любимый с тобой пример про логотипы и главные страницы.
Ты любишь когда логотип завёрнут в `<h1>` на главной странице, но на других страницах он не должен быть завёрнут в `<h1>`.
И тут эта ситуация могла бы немного спасать.

**Вадим.**
Тут ведь какая проблема?
Джейк когда противостоит Джонатану Нилу, его идее, он даже не противостоит.
Он говорит: «Ребята, чтобы нам решить эту проблему, нам мало заменить `<h1>`, который мы будем использовать во всех местах, мало заменить его новым элементом.
Нам нужно комплексно подойти к проблеме.
Нам нужно предже всего, понять почему предыдущая попытка заменить все `<h>`, все уровни, на один уровень `<h1>`, провалилась, сделать из этого выводы.
Убедиться что эта попытка заменить `<h1>` на просто `<h>` не провалится, и только тогда действовать.
Потому что фантазировать можно сколько угодно, но мы сделаем очередную мертворожденную часть спецификации, которая никому не нужна.»
Именно об этом он говорит: «Ребята, давайте конкретики, хорош уже разбрасывать классные решения и о том как всё классно будет.
Давайте вернёмся к процессу и давайте сделаем хорошо.»
А вот этого никто не хочет делать, все начинают фонтанировать идеями, предлагать какие-то вещи, говорить как всё будет классно.
Да, будет классно.
Да, будет удобно.
но давайте поймём, внедрять ли это в браузеры, прежде всего, а вот это проблемы.

Я как человек работавший в браузере, знаю, что доступности уделяется очень мало внимания.
Она, к сожалению, мы видим и среди разработчиков такое же отношение примерно, она не кажется чем-то важным, что приведёт нам пользователей в ваш браузер.
Хотя, по идее, он может.
Она не кажется чем-то, о чём вы расскажете на пресс-конференции.
Оно кажется чем-то таким, ну как налоги вы платите, ну типа, ну хорошо, наверно, платить налоги, чтобы жилось в государстве лучше.
Хотя есть разные точки зрения на эту тему.
То же самое с доступностью: немножко поработали, но не обязательно углубляться.
Вот с `outline` такая же проблема, он не показался важным, но он, по идее, может и должен стать важнее.
Поэтому давайте разберёмся, давайте подойдём к этому вопросу иначе, и вот об этом пишет Джэйк.
И я вам рекомендую, конечно же, почитать, чтобы понять, как работает процесс стандартизации чего-либо.
Не просто от столба выбираете идею и просто внедряете её, хотя и такое бывает, ну в редких случаях.

**Лёша.**
Только нужно понимать что Джейк он не просто так, он аффилированное лицо компании Google и работает, всё таки, на браузере.
Я просто вижу, как он радостно рассказывает о новых вещах, которые только Google внедряет: о сервисворкерах, о всяких линках и так далее, и кричит всем: "Используйте, пожалуйста".
А потом это как-то развивается в том русле куда нужно Google в целом как большой компании, как те же самые приложения на Android, Chrom OS и так далее.
Я понимаю, что в этих всех решениях есть стратегия компании.
И когда так яро, ну ок, когда так взвешенно тот же самый человек приходит и говорит, что, ну давайте о процессе думать, думать зачем это нужно, решать все проблемы.
Да, с одной стороны звучит очень здраво.
Но когда ты смотришь на его другие высказывания, то у тебя так сомнения закрадываются.

Я это ни к чему не хочу сказать, ну вот например, Марат Таналин, который в этом же обсуждении участвовал, его немножко бомбило.
Но одно высказывание было у него вот очень близкое к тому, как часто браузеры реагируют.
Он говорит, что у него складывается в последнее время ощущение, что, чтобы браузеры что-то реализовали извне, нужно просто разработчикам начать это использовать.
С помощью полифиллов, <!--TODO: Незнакомый термин  56:08--> PostCSS, PostHTML.
Когда какая-то масса появится, вот как прошлый раз Сергей рассказывал, что как только в трекере будет 30 звёздочек, Google будет это реализовывать.
Вот тут у Марата складывается такое ощущение, что нужно просто использовать этот `<h>`.
кстати, это несложно сделать, потому что ты прокидываешь всё, полифил добавляешь, новые теги можно, с тех пор как HTML5 появился.
Мы придумали как это делать, просто используешь и всё.
И браузеры, когда увидят что WEB изменился, им придётся это поддерживать.
Видимо он уж был совсем злой, его всё уже конкретно достало, потому что вот это противодействие, оно немножко странное.
Я бы не сказал, что это история с одной позицией, точнее с одной верной позицией.
Вот эта сторона, которая говорит что давайте не будем внедрять `<h>` а разберёмся с проблемами `outline` и так далее, ок.
Но при чёт тут `outline`, точнее, при чём тут `<h>` элемент и то что не реализовали `outline` в течении 10 лет и так далее.
Вы могли реализовать его и раньше.
В чём проблема то?
Чего вы на `<h>` то накинулись?
Реализуйте `outline` отдельно, реализуйте `<h>` отдельно.
В чём проблема?

**Вадим.**
Может быть ты недопонял какую-то ключевую вещь?
Проблема в том что читалки и браузеры уже используют, и уже много кода написано.
Поэтому просто вкинуть новый элемент, сказать разработчикам используйте нельзя, потому что иначе мы не сможем нормально структуру документа, даже без `otline`, просто навигировать по заголовкам.

**Лёша.**
Ты всё равно сводишь это всё к доступности, а если сводить всё к элементам?
Вкинули же `<picture>`?
Очень быстро вкинули.

**Вадим.**
Ну так его вкинули на основе `<img>`.

**Лёша.**
Ну, а какая разница.
Обёрток кучу навертели и вперёд.
Тут же тоже можно было что-нибудь придумать.
Если браузерам внутри себя сложно это реализовать, я уверен, на самом деле, если бы они собрались это сделать, они бы придумали.

**Вадим.**
Смотри, разработчику элемент `<h>` не нужен.
Разработчик не хочет ничего знать, он хочет фыр-фыр-фыр.
Разработчик хочет, чтобы его вёрстка работала во всех браузерах одинаково.
Но у разработчиков есть определённая ответственность перед пользователями.
Чтобы разработчику было проще нести ответственность перед пользователями, ему нужен элемент `<h>`, который будет автоматически, в зависимости от вложенности, модифицироваться в нужный уровень заголовка, и тогда страница будет логически структурирована правильно.
Но сейчас разработчики вкладывают `<section>` вместо `<div>` как попало.
Сейчас разработчики уже используют `<h1>`, `<h2>`, `<h3>` и так далее и всё нормально.
Уже очень много кода написано, и в эту ситуацию нельзя просто вбросить новый элемент `<h>`, он не заработает.
Нужно её проанализировать, нужно понять.
К сожалению именно так.

В случае с `<picture>` мы просто взяли и обернули значимый элемент `<img>`, у которого есть `alt`, `src` и так далее, всё на свете, определённая роль в доступности и всё абсолютно просто.
Мы просто обернули их в командную конструкцию `<picture>`, добавили элементы `source` и всё, и оно заработало.
В случае с какими-нибудь сервисворкерами — это просто дополнительный файл который подгружается.
В случае с WEB-приложениями прогрессивными — это просто файл манифеста который добавляет что-то.
В случае с заголовками — это существующий уже механизм, который нужно переработать.
Всё сложнее.

## Нервный опенсорс (59:36)

**Вадим.**
Ну, на самом деле, эта дискуссия старая.
По поводу неё начало бомбить людей пару недель назад, а то и дольше, и оно всё продолжается, и Джек резюмировал.
Тут есть свеженькое.
Скандалы, интриги, расследования.
Хейдон Пикеринг, довольно циничный британский джентльмен, пришёл в репозиторий Casper - это такая дефолтная тема для движка [Ghost](https://ghost.org/), блогового движка.
И в числе прочих, [ишью](https://github.com/TryGhost/Casper/issues/286), которое он туда написал, он написал что, дословно: «У `<html>` элемента в шаблоне таком-то должен быть дефолтный атрибут lang, и он должен быть `en`», ну то есть english иначе.
А вот почему — он не написал.
Туда тут же пришёл, ну ладно, не тут же, через какое-то время пришёл Джон О'Нолан и сказал: «Нет, не должен».
Поставил точку и закрыл ишью.
И в этом месте началось обсуждение.
Но всё свелось к тому, кто из них был прав?
Мол, тот кто отправил ишью без комментариев дополнительных, не объяснил почему  атрибут должен быть?
Или Джон О'Нолан, который закрыл дискуссию, потому что не было достаточно аргументов «почему».
В общем, после этого в треде пришли разные ребята, самый хороший, развёрнутый комментарий был у Хьюго Жироделя.
Он написал, собственно, зачем это нужно.
И есть ещё один хороший пример от одного француза, у которого дефолтный язык системы французский.
И если на странице не задан атрибут `lang`, то скринридер начинает читать всё по-французски, потому что он не знает языка страницы.
Потому что нет такого `default lang`, `default city`, `default country`.
Соответственно, действительно его важно задавать.
И это всё, по идее, было бы классно Хейдену объяснить.
И после этого дискуссия развернулась дальше, выяснилось что Джон О'Нолан, на самом деле, пришёл и сказал, что Хейдон его уже давно травит всякими ишьями в трекере, и, бедный он, устал и, господи, почему, сколько можно, и эту проблему он давно хотел решить но по-другому.
И в общем, удивительная дискуссия развернулась, и на на эту дискуссию ещё до комментария Джона я написал новость, мол, почему атрибут `lang` нужен.
И как не вести опенсорс, мне показался ответ Джона грубым, и тоже завертелась дискуссия.
И в твитере все начали писать, что как бы это совершенно нормальный опенсорс.
В общем, весело, весело у нас в опенсорсе.

**Лёша.**
А я вот хочу сказать что, ну мы же тут дискутируем насчёт этого, мне кажется, что Джон прав.
Сколько раз мы обсуждали замечательные статьи и были согласны друг с другом, о том как нужно вести опенсорс.
О том что опенсорс — это штука, где никто никому не должен.
Что когда ты приходишь, ты вообще-то что-то должен внести, а не требовать или устанавливать свои правила.
Это не твой проект.
Если он в опенсорсе — это не значит, что тебе кто-то что-то должен.
Если ты хочешь внести в него какие-то изменения — будь, пожалуйста, добр, поработай над этим, объясни зачем они тебе.
Или предложи пулреквест с объяснением, или сделай что-нибудь, а не приходи и не требуй.
Мы очень много говорили о том, какая демотивация у людей возникает, которые занимаются опенсорсом, и они не хотят больше им заниматься.
Да, я согласен, что Хейдон абсолютно прав в своей содержательной части.
У элемента `html` должен быть атрибут `lang`.
В этом я не спорю.

Но здесь, по-моему, вся проблема была не в содержании, а в форме
Он пришёл и начал требовать, и не объяснил.
Да, и он, оказывается, ещё и не один ишью создал, а создал много ишьей, где он требовал разные вещи.
И вот это очень странно.
И это, мне кажется, абсолютно эмоциональный ответ.
К тебе приходят, говорят: «Ты должен».
Первый же ответ: «Иди подальше»
Ну а что вы хотели, когда с таким приходите?
И, конечно же, потом в конце Джон объяснил почему в таком виде это решение, например, не подходит.
Опять же, это к тому, что у Хейдона не было, например, всей картины этого проекта.
Он видел внешнее.
Он видел репозиторий с темой где нет `lang`, может быть даже он это попарсил и нашёл по всем github аккаунтам и ко всем так пришёл и написал.
Вот, не знаю, вечер у него задался, вполне возможно.
Он объяснил что, например, Ghost — эта платформа, собственно, для блога, где используется эта тема Casper — 50% пользователей не пользуется английским языком.
Это абсолютно другие языки, и в их текущем состоянии они не могут взять и вкатить в дефолтную тему атрибут `lang="en"`, потому что они просто испортят всем остальным их блоги сейчас.
Это к тому что  вот этот вот постулат "Давайте не будем ломать WEB текущий", это вот о том же!
Вот такое вот решение оно бы сломало большому количеству пользователей этой платформы сейчас их страницы, и это плохо.
Он объяснил как они хотят это решить, с тем что `lang` должен быть оне не против, ну просто решение не подходит.

**Вадим.**
Ты приходишь ко мне и требуешь атрибут `lang`, но делаешь это без уважения.
Так это прозвучало, и у нас тут не мафия.
У нас тут опенсорс.
А опенсорс, если ты ведёшь какой-то проект не для самого себя, когда ты ведёшь большой проект, которым, на самом деле, пользуются.
Ты в этом месте называешься maintainer.
Ты человек, который поддерживает проект.
У тебя есть определённая ответственность перед людьми.
И он ведёт себя очень ответственно, говорит, если включить этот атрибут `lang` - он поломает, и так далее.
Но если бы он включил его раньше, всё было бы лучше.
То есть, он мог поступить лучше.
В этом случае вместо того, чтобы на основе этой ишьи стартовать обсуждение, он просто эмоционально отреагировал.
Я знаю что люди, которые ведут опенсорсные проекты выгорают, это очень сложно, и так далее.
Вежливость, внимание и ответственность — это то что должно быть по умолчанию.
тебе не нужно тратить эмоциональных усилий для того, чтобы сказать: «Объясни пожалуйста, почему и как?»
Или он тут же этот свой комментарий, не закрывая свой ишью, мог развернуть.
Сказать: «Привет Хейдон.
Было бы круче если бы ты подробнее объяснил.
Но смотри, эта штука не сработает по умолчанию, у меня уже есть ветка в которой я это разрабатываю.
Решение в виде шаблона», и так далее...
Нет, он взял и эмоционально отреагировал.
Это плохо!
Maintainer не должен вести себя так эмоционально.
Он должен быть больше чем просто нервный подросток, который не может снести обиды, что человек не отправил пулреквест, а всего лишь упомянул о проблеме.

**Лёша.**
А я всё равно не согласен, потому что он может быть даже нервным подростком, неважно.
Если он делает вклад в опенсорс — это его дело.
Я ещё раз хочу обратить внимание, что он реагировал.
Это не он всю эту штуку затеял.
Штуку затеял Хейдон, на самом деле, мяч был на его стороне.
Он мог не доводить до этого.
Это он мог это сделать, а не Джон.
Джон просто реагировал, и это абсолютно нормально.
Это, знаешь, как в футболе, когда один пасует другому, и тот, кому пасуют мяч, не ловит его, не добежал, или плохо обработал.
Ты в первую очередь думаешь: «Вот какой козёл! Чё не мог мяч-то обработать?»
Но на самом деле профессионалы тебе скажут — виноват не он, виноват дающий.
Потому что он мяч отправил плохо, а не тот кто принимал.
Здесь абсолютно та же ситуация.
Я тоже хочу ещё раз сказать, что Джон не ответил грубо, он не назвал его козлом, что он ему отвратителен, и так далее.
Ничего такого не было.
Он просто сказал «Нет» и закрыл ишью.
Он имел абсолютное на это право.

**Вадим.**
Смотри, мы тут говорим не про равных участников: два футболиста на поле или два разработчика встретились.
Мы говорим здесь про мейнтейнера проекта и человека, который пользуется этим проектом.
Он зашёл с улицы и говорит, что у тебя здесь есть проблема.
В этом месте нужно реагировать не эмоционально, а нужно говорить: "Да, проблема есть. Да, так мы её решаем".
Он просто сказал "Нет" и закрыл ишью.
Это плохой подход от мейнтейнера проекта, вот и всё.
Мэйнтейнер это больше чем просто разработчик.
Это человек который отвечает.
Здесь он поступил безответственно.

**Лёша.**
Ладно, я тебе хочу сказать, что он больше чем мэйнтейнер.
Он основатель платформы Ghost, и он, возможно, то что этот Casper вообще был публичен — это, возможно, его в принципе заслуга.
Он мог это сделать и приватным, и Хейдон Пикеринг пользовался бы тем чем мог, а не открытой платформой, повёрнутой к нему, куда он может придти и написать и попросить что-то.
Этого вообще могло не быть.

**Вадим.**
С каких пор заслуги человека оправдывают его дурное поведение?

**Оля.**
Так, мальчики, стоп!
Я тоже хочу вклиниться!
Я уже это пытаюсь сделать минуты три.
Я, на самом деле, согласна с вами обоими.
Я имею такой же вот опыт, я конечно не занимаюсь опенсорсом в веб-разработке, но занимаюсь им в другой области.
И мне часто приходится взаимодействовать с людьми, которые считают, что они могут вот так вот придти ко мне как к мэйнтейнеру некоего проекта и что-то требовать.
Причём, проект то тоже как бы бесплатный.
А я считаю, что с их стороны нехорошо требовать, у меня на самом деле тоже начинает бомбить, вот так же мне хочется не просто закрывать их ишью, мне хочется их как бы посылать пинком в пешее эротическое путешествие.
Но при этом я согласна с Вадимом, в том что, когда человек ведёт какой-то проект, ему, действительно, стоит держать себя в руках лучше, потому что он ещё и лицо этого проекта.
Он несёт ответственность за него.
Эта ответственность на него накладывает обязательства стараться разруливать какие-то такие ситуации наименее конфликтным способом.
Да, это требует сил.
Да, конечно, Лёша тоже прав, никто никому ничего не обязан.
Но тем не менее, профита будет больше, если и пользователи будут стараться быть вежливее и адекватнее в своих претензиях и предложениях.
И мейнтейнеры будут стараться тоже идти навстречу, а не захлопывать дверь прямо по носу человеку.

**Вадим.**
Вы, наверно, могли меня не понять.
Я считаю, что Хейдон поступил неправильно.
Он должен был нормально развёрнуто объяснить почему и так далее.
В принципе, если скопировать то, что написал Хьюго чуть ниже, вот так должна была выглядеть ишья, которую заводит Хейдон, и я сам так стараюсь делать.
Я расписываю, я пишу фрагменты кода, если могу, отправляю пулреквест и так далее.
*Так должно быть.*

Но если сравнить, то что я не заведу багу в трекере, и то что я заведу её неправильно, я бы предпочёл второе.
Если я заведу и скажу о чём-то неправильно, не по форме, не используя `contibuting.md` или ещё что-нибудь такое — это ценнее, чем я промолчу.

Поэтому, если к вам в опенсорс приходят люди, которые, чёрт побери, не читают ваши `readme`, но сообщают о проблеме, и вы узнаёте об этой проблеме — не отпугивайте их, не отгоняйте их, не говорите, что, типа, не дорос, чтобы мне пулреквесты оправлять.
Понимаете, вы, как мейнтейнер, не должны выгонять людей.
Вы не должны выдавать фразы, которые токсичны для вашего проекта.
Вы должны приглашать людей в дискуссию.
Даже если это происходит сто раз в день, даже если вы устали, но если вы устали — найдите нового мейнтейнера.
Пассивно-агрессивные комментарии Джонатана...
Да он устал, да он основатель проекта и это его тысячный комментарий такой глупый.
Да, Хейдон мерзкое создание, я читаю его в Твиттере, это правда человек сложный и  интересный одновременно.
Но ты мейнтейнер, у тебя ответственность.
Веди себя выше, веди себя лучше.

**Лёша.**
Они нашли друг друга.
Я думаю что, если резюмировать, то на самом-то деле оба не правы.
Потому что, как ты говоришь, если бы Хейдон написал комментарий как Хьюго, то, скорее всего, и ответ был бы как Джон написал внизу.
Все бы разошлись миром, и эта история — мы бы её даже не обсуждали.
Это было бы тысячное ишью, которое поправили в Casper за последний год.

Но, знаешь, я хотел бы еще отметить момент, не совсем к этому, а в принципе.
Мы как какая-то образовательная, вещательная часть мира веб-разработки и другие такие-же ребята, часто говорят как нужно себя вести, когда вы приходите в опенсорс проект.
Ну, то есть как нужно заводить ишью, почему это важно, почему важно, как вы общаетесь и так далее.
И практически никогда мы не говорим как мейнтейнеры должны себя вести.
Это ведь тоже, наверно, о чём-то говорит.

## 01:14:00 W3C против WHATWG

**Лёша.**
Ну раз уж у нас этот выпуск про «бомбалэйло», то, видимо, мы и будем заканчивать таким же образом.
Потому что тут на [reddit зашёл забавный спор](https://www.reddit.com/r/javascript/comments/5swe9b/what_is_the_difference_between_the_w3c_and_the/).
Некто спросил в чем разница между W3C и WHATWG?
Это вообще отличный вопрос, потому что хочется воскликнуть: «И правда, а в чём разница то, какого чёрта, где она?»
И тогда, конечно же, пришёл Доменик Деникола объяснить в чём разница, и пришёл туда Иэн Хиксон, чтобы тоже объяснить в чём разница.
В общем, два лагеря там встретились и начали объяснять друг другу, кто прав а кто нет.
И, конечно же, это вылилось в такую же бомбёжку и закидывание друг-друга тапками.
Потому что Иэн туда пришёл и, точнее даже не он, а кто-то там другой, начал рассказывать.

Постулат о WHATWG был такой: это чёртовы хипстеры, которые ни фига не думают о фундаментальных вещах, о вещах, которые проживут в вебе 20 лет, как мы это и делаем.
Мы то тут уже давно, простите, вы пишите на тех технологиях, которые мы придумали давным-давно.
Привносят тут какой-то сумбур, фигачат тут какие-то странные штуки, какую-то лайф спеку, в общем, вообще непонятные какие-то маленькие ребята, и вообще они весь этот проект WHATWG стартовали потому что они не могут нормально донести свою идею W3C, потому что в группах W3C они всего лишь малюсенькая часть.
Вы представляете, представители браузеров в группах W3C — это всего лишь малюсенькая часть, которая даже не может толком объединиться и протолкнуть свою идею, потому что там огромные корпорации типа Боинга и других, которым, как это ни странно, важны все эти спецификации не для того чтобы вы создавали PWA-приложения, а для того чтобы просто документацию к своим самолётам написать.
И им важно как символы будут выглядеть в браузере на японском или ещё где-то, они для этого всё делают в этих группах.
В общем, он, так скажем, немножко обидел ребят.

Ну и конечно, Доменик Деникола пришёл, а вы помните его.
Он последнее время тоже не может себя сдержать и говорит, что вы меня достали, я ухожу, или вы бесите использовать названия технологий в своих полифилах, когда мы их ещё не зафинализировали, и короче, вы меня все раздражаете.
Ну вот как-то так, у меня от Доминика сложилось такое впечатление.
И тут он, конечно же, тоже сказал, что ребята из W3C вообще не очень, когда-то давно они делали всё нормально, но потом они стали делать всё фигово, зафакапили XHTML2, зафакапили другие технологии, поэтому мы - браузерные ребята — ушли из W3C и основали WHATWG и теперь пилим там.
И если вы хотите знать, что будет в браузерах, то смотрите в WHATWG. И он ещё так, знаешь, очень дерзко сказал: «И вообще эти ребята из W3C приходят к нам, копируют наши спецификации к себе, убирают логотипы, убирают авторство, вносят кучу опечаток, как будто они это специально делают, как будто бы они там символ по символу пишут, и вообще они плохие ребята.
Я их ненавижу, и вообще, API, которые они делают, они делают их тоже ужасными, потому что там Java-теоретики, ничего они не понимают, как работают современные разработчики в браузерах.»

**Вадим.**
Ну, на самом деле, Хиксон совершенно не кажется оппонентом Доминику, потому что Хиксон когда-то сам стартовал то, что не смогли сделать W3C, то есть Иэн Хиксон был редактором HTML5 спецификации, когда с ней не справилось W3C.
`Web-applications 1.0` — спецификация которая потом стала HTML5, так называемым — WHATWG этим занимался, Хиксон этим занимался, все эти хипстеры, которые решили спасти web-технологии от XHTML мертворожденного, и сделать их живыми и сравнять теорию с практикой.
И тут он как бы не особо-то оппонирует, в основном с Домиником согласен, но он, конечно, делает определённые замечания, что мол, W3C не хухры-мухры, это вполне себе организация, у которой много задач.
У неё есть задачи, которые шире чем просто web-технологии — да, ты прав, Лёша.
Но, было бы хорошо, чтобы они друг с другом не конкурировали, и этот момент, что W3C форкает какие-то вещи и портит их по дороге, конечно, немного странный.

**Лёша.**
А вот кстати, этот момент до конца не понял.
Ну вот эту претензию такую большую Доминика к W3C.
А разве ребята из WHATWG изначально не взяли те труды, которые были написаны.
Ну вот на секундочку, разве это было не так?

**Вадим.**
Ну, тут не важно кто что взял, тут важно что они в своём [Living Standard](https://html.spec.whatwg.org/multipage/ "WHATWG HTML Living Standard") они пытаются именно практическую сторону вопроса привести к реализациям в браузерах.
Соответственно, у них всё заточено под этот процесс, что это не просто абстрактный документ, какими это когда-то были многие спецификации, а это, вполне себе, реальное состояние вещей.
Для W3C чтобы оценить реальное состояние вещей нужно выпустить версию HTML5.1, HTML5.2 и так далее.
А актуальная документация, чаще всего, хранится на WHATWG, поэтому? когда я сам иду за спецификацией HTML, я иду в спецификацию WHATWG.
Хотя, на самом деле, некоторые авторы, уважаемые мною, типа Стивена Фолкнера, они работают в W3C и правки вносят именно черновики W3C и по семантике, по каким-то вещам, и в какой-то момент они попадают в WhatWG и вот я не знаю...
То есть, наверно, нам стоило закрыть этот проект WHATWG, в какой-то момент и улучшить процессы в W3C и, может быть, как-то двинуть всё общими усилиями.
Но этого не случилось и поэтому они в какой-то момент форкнулись, сделали очень важную вещь, но продолжают двигаться.
И, может, именно процесс разработки именно HTML отдать на откуп браузерам, а не Боингам.
Вот, может быть это будет правильнее.
Грубо говоря, было бы проще и разработчикам браузеров, и разработчикам спецификации, и просто рядовым разработчикам сайтов, если бы у нас был единый источник правды.
Но мы настолько привыкли к концепции вечнозелёности, что мне WHATWG версия вечно актуальной спецификации без номеров, в которой просто прописано, что сейчас происходит в вебе, мне она ближе, поэтому WHATWG, наверно, имеет больший авторитет в этом смысле чем W3C.

**Лёша.**
Но я всё равно, даже то что ты сказал, я всё равно не понимаю разницу между спецификацией HTML в W3C и спецификацией HTML в WHATWG.
Да, вечнозелёное, ок.
Ну, например, просто по косвенным факторам.
Мы сейчас обсуждали новый тег `<h>`, это обсуждение происходило в W3C, в репозитории там.
Почему Джонатан Нил не пришёл с ним в WHATWG.
Есть всё таки какое-то ощущение, что вот эта спецификация и версирование, вот эта вечнозелёная спека — это очень хорошо, но не для всех.
Нужно как-то за что-то цепляться.
Вот смотри, я делаю проект, или вот, помнишь как Саша нам рассказывал, они в Сбербанке делают проект.
У них версия старая.
Как им понять, если была бы вечнозелёная спецификация, какой-то срез фич, который у них работает?
Они по спеке уже не смогли бы этого сделать.
Это хорошая штука, когда всё вечнозелёное, браузер вечнозелёный, вечнозелёная спецификация, и мы просто всё время фокусируемся на том, что у нас есть.
И ещё степень обновляемости браузеров всегда хорошая, никто не зависал как с андроидами.
И тогда да, это идеальный мир, было бы всё здорово.
Но этот мир, он не сейчас.

**Вадим.**
Какой бы ни был Сбербанк, или какой бы бюрократической ни была организация, всё равно всем разработчикам и всем организациям важно как их сайт работает в конкретных браузерах на которые они ориентируются.
Допустим, если у Сбербанка такие требования по `Internet Explore`, которые нужно соблюдать, там 8-й, 11-й? yикакой привязки между версиями браузеров и весией HTML спецификации нет.
Если и нужно ориентироваться на браузеры, и нужно смотреть что реализовано сейчас в браузерах современных — это спецификация WHATWG, и тогда уже делать выводы, что из этого они могут использовать, к чему стоит стремиться и так далее.
Мы, всё таки, должны, как разработчики, больше беспокоиться о реализации наших технологий в конкретных устройствах просмотра, то есть браузерах.
Поэтому ориентироваться на версии спецификации — да никому никакого дела до них нет.
Мы просто знаем, что был HTML4, был XHTML, а потом стал HTML5, и всё.
Никто разницы между HTML5.1 и HTML5.2 не знает, а если знает — это не имеет никакого значения, потому что имеет значение реализация в браузерах и всё.

**Лёша.**
Ну да, я только хочу сказать что, на самом деле, даже не знаю вот эту историю, которую ты рассказал: что был HTML4, был XHTML, и потом HTML5.
Я даже недавно с нашими ребятами что-то там обсуждал, и у них было понимание, что XML был и потом HTML5.
Ну, что-то такое.
И это в принципе и не важно, потому что какая тебе разница как что там было, господи.
История, бог с ним.

Я, кстати, хотел ещё вернуться к Доминику, я в одном с ним очень чётко согласен.
Это в том, что из под пера W3C выходят ужасные API.
Потому что он вот прям справедливо говорит, ну ребят, вы написали, что в DOM чтобы удалить какого-то потомка вам нужно сначала взять его родителей, и только у него вызвать метод удаления, а не как-то по другому.
У вас нету нормальных методов `.before()`, `.after()`, у вас нет нормальных методов `.replace()` и так далее.
У вас, чёрт побери, есть какие-то массивы, которые на самом деле не массивы и нельзя их перебирать, ими нельзя пользоваться обычными итераторами функций и так далее.
И это же полный бред.
И в этом смысле я с ним абсолютно согласен.
Да, ребята в W3C, у них с API как-то очень плохо, они какие-то не очень юзабельные.
И когда ребята это делают из WHATWG — это `fetch`, что там было еще?
Вот `fetch` точно помню, абсолютно удобнейшая штука.
Её думали именно для того чтобы удобно было её использовать каджый день.

**Вадим.**
Ну, DOM API, современные методы `.before()`, `.after()`, вот эти все штуки — это тоже разрабатывается WHATWG сейчас.

**Лёша.**
Ну да, я к этому и веду, что они исправляют те глупости, которые были в спеках.

**Вадим.**
В общем, дорогие разработчики, WHATWG за вас, W3C пока не очень.

**Лёша.**
Но надо только одну вещь сказать, что WHATWG это только про `HTML`, `DOM`, `fetch`, что там у них ещё есть?
Они работают на лоадером для ES-модулей.
А например, какие-нибудь `IndexedDB`, и кучей других спек, которыми WHATWG вообще не занимается, ими, вообще то, занимается W3C, и не так плохо это делает.
Ну да, там ужасный API, но  они хотя бы это делают, и это проходит внедрение в те самые браузеры, которые так плохо относятся к W3C.

**Вадим.**
Знаешь, чем не ещё симпатично WHATWG?
У них есть логотип каждой спецификации, которую они разрабатывают.
Вот это классно!

**Лёша.**
А знаешь почему?
Потому что у них  мало спецификаций.
Это легко.

**Вадим.**
Нет, там много, очень много.
У них там и к `fetch`, и к спеке урлов, вообще ко всему.
Даже к `XMLHttpRequest` там есть профиль Аякса — героя древнегреческого.
Они в этом смысле поинтереснее, конечно.

**Лёша.**
Я имею ввиду, у них несравнимо малое количество разных спек по сравнению с W3C.

**Вадим.**
Ладно, в общем, мы за хипстеров.
Я за хипстеров, а вы как хотите.

**Лёша.**
Вот это вот было опасное утверждение.
Ну, ок, ладно.

---

**Вадим.**
Ладно, Оля, ты знаешь, что делать.

**Оля.**
С вами был 57 выпуск подкаста «Веб-стандарты» и его постоянные ведущие Вадим Макеев и Алексей Симоненко из HTML Academy.

**Вадим.**
И Ольга Алексашенко — верстальщик руками из EXANTE.
Мы увидимся с вами на следующей неделе в Москве, мы туда с Лёшей поедем.
А так услышимся на следующей неделе, пока!

**Оля.**
Пока!

**Лёша.**
Пока!
