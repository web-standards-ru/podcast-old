# Выпуск №17

23 мая 2016: Семантика и БЭМ, CSS для новичков, клиенты для Git, JS-модули в Edge, Google I/O.

- Ольга Алексашенко
- Вадим Макеев
- Алексей Симоненко

**Лёша.**
Привет, с вами 17 выпуск подкаста «Веб-стандарты» и его постоянные ведущие Вадим Макеев из [Opera](http://opera.com), Ольга Алексашенко — верстальщик руками из [Exante](https://exante.eu)…

**Оля.**
И Алексей Симоненко из [HTML Academy](https://htmlacademy.ru).

## События (00:13)

**Вадим.**
И мы снова будем говорить вначале про события. Всем надоело, но, чёрт побери, надо встречаться. [PiterCSS №4](https://pitercss.timepad.ru/event/331983) пройдёт уже во вторник 24 мая. Если вы из Питера или надумали приехать — у нас тут лето и всё хорошо — регистрируйтесь, места, я думаю, закончатся в понедельник. Там будут доклады про SVG, про AMP — технологию, как возвращать страницы в изначальность, которую придумал Google, чтобы страницы загружались быстро — какая-то такая странная штука, и немножко про вёрстку писем — поплачем всем залом. Мы сейчас раздумываем, проводить ли PiterCSS в июне, потому что в июне будет уже [WSD в Екатеринбурге](https://wsd.events/2016/06/25). Хотя уже есть два заявленных доклада — так что, вот, думаем. Но, может быть, сделаем, если будет свободное время. Вы что думаете, ребята, вообще летом конференции имеют право быть?

**Лёша.**
Мне кажется, что летом достаточно сложно собирать конференции, именно в середину лета. В принципе июнь и август — это ещё более-менее, а вот июль — мне кажется, это совсем не надо.

**Оля.**
Я согласна с Лёшей, примерно такая раскладка по месяцам. В июне, как правило, ещё никто в отпуск не уходит, потому что холодно, у всех ещё дети учатся и всё в таком духе. Хотя какие дети у нашей аудитории? Ну вот, мне кажется, в июне ещё можно, а в июле и августе уже, наверное, бессмысленно.

**Вадим.**
В общем, мы делаем WSD 25 июня. Так что, если мы где-нибудь в середине сделаем PiterCSS… Ну, посмотрим.

**Лёша.**
Если у тебя уже есть желающие что-то рассказать, то площадку-то мы уж найдём. Может быть, и не останавливаться.

**Вадим.**
Ну да, кто я такой, чтобы мешать людям докладывать?

**Лёша.**
Конечно.

**Вадим.**
Вот. В начале июня я всё ещё надеюсь съездить на ScotlandJS и ScotlandCSS. Сейчас в волнении жду визу. И вы тоже волнуйтесь — я ведь могу и текстовую трансляцию оттуда сделать, поэтому давайте волноваться вместе, чтобы всё получилось. Вот. В общем-то, WSD в Екатеринбурге, как я и обещал, 25 июня, мы уже опубликовали полпрограммы. Там 5 докладов уже есть. А я там расскажу свой доклад, про который ко мне периодически приходят люди и спрашивают: «А видео есть?». Я — «Есть, но оно паршивое». Я, наверное, подниму свой старый доклад про кнопки и ссылки — «Жми сюда» называется — в котором я рассказываю, что делать с интерактивными элементами: что делать кнопками, что делать ссылками, что делать псевдоссылками, как всё это делать доступным, как правильно добавить CSS, чтобы навигацию можно было делать с клавиатуры. В общем, что-то про доступность, но с хорошей долей практики.

А ещё я в календарь на лето планирую отпуск, и понял, что 27 августа [Frontend Union Conf](http://frontend-union.co) в Вильнюсе — такая конференция, объединяющая разные митапы. Она прошла в Москве в августе прошлого года, там были англоязычные и русскоязычные доклады. В общем, надо спросить у ребят, будет ли она, потому что про неё в последнее время не было новостей, но обязательно добавьте в календарь — Вильнюс, 27 августа, Frontend Union Conf. По крайней мере, что ребята хорошие и они соберут хорошую программу, я могу поручиться точно.

**Лёша.**
И ты, конечно же, забыл про [HolyJS](http://holyjs.ru). Ведь HolyJS совсем уже скоро будет, буквально через две недели, программа уже готова: три потока и 22 доклада — будет что-то большое.

**Вадим.**
Да, я собирался выступить с докладом на HolyJS, но нормальную JS-тему пока не подготовил, может быть, осенью что-нибудь придумаю, была у меня одна идея. Наверное, просто напрошусь в гости — придти, посмотреть, как это всё работает, и можно ли сделать коммерческую конференцию в России. Так что увидимся 5 июня.

## Семантика и БЭМ (04:01)

**Вадим.**
Большой темой на этой неделе была семантика и БЭМ, или Бэмантика, как новый термин. Смотрите, в чём дело. Тим Бакстер на [A List Apart](http://alistapart.com/) — таком старинном уважаемом сайте, на котором я учился веб-технологиям, читал Джеффри Зельдмана и Эрика Мейера — опубликовал статью. Её ребята из [CSS-Live](http://css-live.ru/) быстренько перевели на русский, и получилась статья [Осмысленный CSS: описывайте стилями свою логику](http://css-live.ru/articles/osmyslennyj-css-opisyvajte-stilyami-svoyu-logiku.html).

В чём суть. Тим Бакстер говорит, что в спецификации чётко написано — хорош использовать классы, слишком много этой «классянки». Джеффри Зельдман в своём классическом труде (откуда, собственно, пошёл термин веб-стандарты) пишет, что классов нельзя использовать слишком много, потому что это вредит и семантике, и логике, и всему на свете. И он говорит, что можно просто обращаться к элементам по именам элементов, приделывая к ним атрибуты. Допустим, у вас есть шапка на странице — элемент `<header>` из HTML 5. Вы берёте, и употребляете этот элемент `<header>` у вас прямо в стилях, потому что он единственный на странице. Но он ведь может использоваться где-то ещё — вы берёте, добавляете к нему атрибут `role="banner"` — он точно должен быть один на странице — и у вас получается `header[role="banner"]`, и у вас такой уникальный элемент шапка.

В чём проблема с этим подходом? Об этом говорят в дальнейших статьях, но я хочу поговорить немножко о другом. Почему Тим Бакстер вообще написал об этом? Смотрите, у нас, действительно, есть спецификации и у нас есть рекомендованные подходы, которые идут от логики, от того, как документации и стандарты по языку HTML и CSS были когда-то написаны. Потом это всё применилось к жизни и стало практиковаться разработчиками, и пришёл большой опыт применения всего этого в реальной жизни. И мы получили немножко другие подходы, которые сейчас в среднем формулируются как БЭМ, то есть Блок-Элемент-Модификатор. Когда мы ушли от сложной специфичности, когда мы ушли от сложных вариантов именования, когда мы ушли от всяких каскадов, айдишников и прочих элементов, которые всё немножко усложняют, и пришли к более стройной и понятной системе именования и использования Блоков-Элементов-Модификаторов, как вы это ни называете: SMACSS, Object-oriented CSS, неважно.

И вот сейчас столкнулись — в статьях, которые вышли на этой неделе — два мира: мир теории и мир практики. Один из самых хороших ответов на эту тему был [ответ Мэтта Стоу про Бэмантику](http://css-live.ru/articles/bemantika-pishite-osmyslennye-stili-bez-povtorov.html "Бэмантика: пишите осмысленные стили без повторов"). Собственно, он этот термин вырулил, и, мне кажется, довольно забавное получилось слово — и БЭМ, и семантика в одном слове. Хотя, казалось бы, вещи противоречащие. А он говорит: нет, я использую как и БЭМ, для того, чтобы именовать классы, так и семантические элементы, так и ARIA-атрибуты, которые очень здорово описывают, что на странице происходит. И, на мой взгляд, подход Мэтта — это как раз то, что должны практиковать современные разработчики: знать теорию и хорошо применять это на практике, и в итоге, получается, и волки сыты, и овцы целы. Ребята, а вы видите какое-нибудь рациональное зерно в том, что написал Тим Бакстер, или это для вас звучит, как брюзжание какого-то пенсионера?

**Лёша.**
Мне кажется, что у него идея-то хорошая, просто, ты прав, он от практики очень далёк. И на больших сайтах это вообще невозможно, чтобы у тебя все элементы выглядели одинаково. Ведь есть такая штука, как редизайн, ещё что-то. Это в принципе невозможно. Но с другой стороны он очень много говорил про ARIA-атрибуты, про которые, наверное, среднестатистический разработчик никогда и не слышал. И в этом смысле, конечно, его статья полезна. Понятное дело, что она немножко «кривая» в этом смысле, потому что он мало рассказывал, зачем это и почему. Ведь с доступностью какая главная проблема? Или с семантикой? Да нет, давай про семантику. Представим, что я ничего в этом не понимаю. Вот ты, как человек, понимающий, что семантика — это хорошо, скажи мне, нафига мне нужна семантика, зачем мне на это тратить время?

**Вадим.**
Семантика — это универсальный язык, о котором мы все договорились. Когда я тебе говорю: «Лёша, привет!», ты слышишь своё имя и приветственное слово. Когда мы читаем в исходнике страницы — кто-либо, вообще один из многих возможных вариантов агентов, которые читают HTML, присланный вашим сервером — он читает и видит элемент `<header>`, элемент `<main>`, элемент `<footer>` и он может понять, что в каждом элементе содержится. Если он читает названия классов, которые ещё наверняка и зашифрованы какими-нибудь CSS-Modules, он не может понять, что там находится, он не может интерпретировать более широко и более правильно. Ему приходится включать всякие морфологические разборы, чтобы попытаться понять: где заголовок сайта, где основной текст, где ещё что-то. А ведь такие вещи пока ещё не надёжны. Поэтому мы договорились о метаязыке, описали его в спецификации, и у нас, у разработчиков, есть общий язык. Ты читаешь исходник сайта глазами, ты понимаешь, что-где, не опираясь на имена классов, а именно глядя на HTML-структуру. Робот читает, понимает, что-где, читалка экранная пропускает какой-нибудь элемент `<header>` прямо в `<body>` первый, потому что он уже прочитал его на главной странице, и он может его пропустить. По крайней мере теоретически они могут это сделать.

**Лёша.**
Ты говоришь, что это метаязык, чтобы кто-то понимал твой код. Но мне кажется, что среднему сайту, среднему разработчику абсолютно не нужно, чтобы кто-то понимал его код, он ведь решает задачу какого-то клиента, чтобы его сайт работал, а не чтобы код был красивым. И опять же, я сейчас с этой стороны, я выключил из своей головы все знания про семантику и доступность и сейчас говорю без них, чтобы получилась дискуссия. Не очень понятно, нафига — ты привёл очень хороший пример про язык, ты говоришь мне: «Привет, Лёша!», и мы понимаем, что это значит. Ты мог бы сказать «Hey, Лёша!», или вообще всё что угодно, ты мог произнести любое слово — и мы бы тебя поняли.

И точно так же с браузерами, с роботами. Да, у нас есть история про то, что нужно определять как-то семантически верно нашу разметку, чтобы браузер понимал где-что, или чтобы робот понимал, где-что. Но ведь робот справляется и без этих знаний, хорошо справляется, очень долгое время справляется. Поисковые роботы умеют находить нужный контент в ужасном коде, там наверняка все assistive technology научились понимать, какой контент важный, а какой — нет. Почему так произошло? Потому что нет идеальной вёрстки, нет идеального инструмента, в рамках которого мы бы могли договориться: да, мы будем проверять только так и будем давать результат этого всем нашим пользователям. Но, так как договориться об этом не получается, хотя есть стандарты, все технологии понимают, что нужно смотреть шире, гибче. И в том числе из-за этого, получается так, что все технологии нам дают такую широту. Поэтому непонятно, зачем мне тогда поддерживать семантику, если все эти инструменты и так могут работать.

**Оля.**
Ну, на самом деле-то, вот это отсутствие жёстких конвенций приводит к тому, что каждый браузер ваяет, что он хочет. И в результате у нас есть проблема кроссбраузерности. Всё это отсутствие стандартов приводило к большим проблемам. Поэтому сведение наших технологий к каким-то конвенциям упростит жизнь всем — во внедрении и в реализации.

**Лёша.**
Возможно, возможно, но посмотри на любой сайт, который состоит из одних дивов и классов.

**Оля.**
Я сама делаю такие сайты, к сожалению. И у меня тоже встал этот вопрос. Эта статья хороша тем, что она нас немножко возвращает к истокам и напоминает, что разметку надо бы делать семантичной, и это хорошо.

**Вадим.**
На мой взгляд, эта статья как раз не просто возвращает нас к истокам, а берёт и тыкает носом, причём больно, неприятно и немножко грубо. И когда тебя грубо тыкают носом куда-то, ты такой: «Эй, старичок, ты вообще из другого века, с тебя давно песок сыпется, поэтому иди-ка к чёрту, я тут лучше знаю, как мне что-то сделать лучше». Вот это проблема. Вот это плохой пропагандист. Пропагандист, который оторван от практики. Этот персонаж, Тим Бакстер — я плохо знаю, кто он, на самом деле. Возможно, он практикует что-то, но я почему-то сомневаюсь, что он работает с большими, даже средними или, по крайней мере, поточными проектами. И поэтому, когда ты читаешь его аргументы, ты думаешь: «какая-то чушь». И ты не хочешь вдумываться: семантика, ARIA, ещё что-то такое, ты просто чувствуешь, что он не понимает сложностей и задач твоей работы. Мэтт Стоу, который ответил ему — понимает. Джон Снук, который в [«Shopify»](https://www.shopify.com/) работал какое-то время, сейчас, по-моему, ушёл и фрилансит; который написал про [More Meaningful CSS](https://snook.ca/archives/html_and_css/more-meaningful-css) — тоже пытается объяснить, откуда взялась вся эта «классянка» — он тоже понимает практику. Тим Бакстер — не очень, поэтому те здравые идеи, которые звучат у него, мне кажется, никто всерьёз не воспринял. Действительно, поднялась волна комментариев, что чувак написал полную ерунду, хотя он написал не ерунду, он написал правильные вещи, но не в практической плоскости, а в теоретической. И там действительно очень много ошибок и упущенных мест, которые стоило бы восполнить.

**Оля.**
На самом деле, цель-то достигнута: волна-то поднялась, мы немножко задумались. И, может быть, всё это была такая хитрая провокация? Хотя, конечно, не факт. У каждого подхода есть свои плюсы и минусы, и утверждать, что одно идеально хорошо, а другое абсолютно плохо — тоже нельзя. Поэтому хорошо, что дискуссия поднялась. Тут опять есть о чём подумать.

**Вадим.**
Я хочу ответить на Лёшину провокацию про «кому нужна семантика, если роботы и так разбираются». Я частенько сталкиваюсь с тем, что я захожу в какой-нибудь Google, ищу что-нибудь и вижу заголовок сайта. Откуда он, кстати, взялся? Наверное, из `<title>` или `<h1>`, то есть какие-то теги разработчики выучили, молодцы. А потом, сразу под заголовком сайта идёт сниппет. И в сниппете поисковик пишет самый важный текст на сайте: «Нажмите на эту кнопку, чтобы закрыть диалоговое окно». Я регулярно сталкиваюсь с тем, что поисковик выбирает неправильный сниппет для того, чтобы описать сайт. Он выбирает его из какого-нибудь `<div>`, у которого есть какой-нибудь `class="content"`, или какая у него там эвристика. Но я регулярно вижу, что они ошибаются. А если бы он взял внутри `<header>` какой-нибудь параграф, который следует сразу за `<h1>`, или что-нибудь другое вытащил из значимых элементов — он бы со сниппетом не ошибся. Возможно, сниппет нужно засовывать в `<meta name="description">` — это уже вопрос к сеошникам. Но суть следующая: поисковики частенько ошибаются. Вот в чём дело.

Практики, рекомендованные в спеках, действительно внедрены в браузерах. Оля правильно сказала, веб-стандарты помогли нам добиться лучшей кроссбраузерности, и эта ситуация улучшается с каждым днём. Но мы всё ещё очень далеко, потому что средний разработчик браузера и средний разработчик веб-страницы — это очень разные люди. Первым важно читать спецификацию, чтобы соответствовать другим браузерам. Вторым важно быстренько «тяп-ляп и в продакшен». Кто-то пожёстче говорит: «По-моему, вторым (собственно, верстальщикам) не хватает знания спецификаций». В отсутствии этих знаний, в отсутствии доступных спецификаций — я не обвиняю только разработчиков, я обвиняю ещё людей, которые пишут спецификации, я обвиняю нас с вами, ребята, которые сами не читают спецификации, читают их мало, мало о них рассказывают. Видимо, об этом нужно больше говорить. Если кто-то из вас (или из нас, по крайней мере, точно я) считает семантику, вот эти идеи важными — о них нужно больше говорить. Собственно, не то чтобы «на волне», но, видимо, я предчувствовал и захотел на WSD в Екатеринбурге рассказать, чем кнопка отличается от ссылки. Это тоже, в общем-то, про веб-стандарты и про то, как их немножко помирить с практикой.

**Лёша.**
Тебе не кажется, что этого всё-таки недостаточно? Доклады про семантику происходят периодически, статьи про семантику пишут периодически — например, был шикарный доклад [Семантика или смерть](https://events.yandex.ru/lib/talks/1520/), как раз на одном из WSD.

**Вадим.**
Да, Наташа Арефьева рассказывала.

**Лёша.**
Даже до сих пор дают ссылку на это видео. Посмотрите обязательно его, чтобы понять, почему это важно. Но, тем не менее, у нас в вебе громадное количество сайтов, которым на семантику наплевать, и выходят новые сайты, которым на семантику наплевать. Любой новый инструмент или фреймворк, который выпускается — ему на семантику наплевать. Почему так происходит, если это так важно?

**Вадим.**
Кто делает фреймворки? Фреймворки делают люди, которые решают задачу, им нужно в браузере нарисовать картинку. Не сделать сайт удобным, доступным, быстро работающим, а нарисовать картинку. Так что фреймворк или библиотека — это абстракции, которые позволяют сделать какой-то скелет, или прицепить две руки к плечам, где есть правильные разъёмы. То есть, чтобы модульность какая-то была. А когда у нас есть реальная практика применения, реальные пользователи и реальные задачи, начинаются уже попытки подпилить к этим всем фреймворкам правильную семантику, правильные ARIA-атрибуты, доступность и всё остальное, и тогда уже, получается, практика применения совсем меняет эти фреймворки, если они вообще позволяют это делать. Наверное, нужно меньше писать фреймворков и больше собственного кода. Наверное, стоит смотреть на практику, а не просто подключать jQuery-плагины. Вот в этом, наверное, есть выход какой-то. Тот же самый eBay на неделе опубликовал [MIND](http://ianmcburnie.github.io/mindpatterns/) — библиотеку доступных элементов интерфейса, такой сборник паттернов, я бы сказал. И они рассказывают, как они используют всякие карусели, кнопочки. Они пишут, что стоит делать и чего не стоит. Это не то чтобы библиотека компонентов типа copy-paste — извини, средний разработчик, copy-paste не получиться — а просто такой подход на котором растёт всё остальное.

**Лёша.**
Кстати, у них и правда очень хороший инструмент. Но я хотел бы немножко вернуться назад. Я сказал про фреймворки, но я хотел бы и долю оптимизма какую-то внести. Например, возьмём тот же самый React — он вам никак не помогает ни с семантикой, ни с доступностью.

**Вадим.**
А он мешает?

**Лёша.**
Ну, а ты посмотри на любой сайт, в котором одни дивы и классы. Как ты считаешь?

**Вадим.**
Нет, подожди, а React мешает?

**Лёша.**
Он ничего не делает. Вообще. Но, когда тебе дают другой инструмент ты как бы думаешь, что ты совсем в другой плоскости, и не думаешь уже о каких-то привычных вещах. Фокусы у элементов делаются другим способом. Наведение на элементы делается другим способом. Media-выражения — какие media-выражения? То есть, каких-то привычных вещей у тебя вообще нет. Поэтому ты думаешь об этой штуке, как о чём-то вообще в принципе другом, и забываешь про семантику. Но, я к чему? Если React такой, то это не значит, что с ним нельзя сделать доступный сайт. Посмотрите в код Facebook. Он весь утыкан aria-атрибутами и другими штуками доступными. Там теги используются по назначению. Просто зайдите в Facebook, откройте код и посмотрите, как они это делают. Видимо, нужно больше тратить время на то, чтобы проект был хорошим? Но вот со временем-то у всех и проблемы.

**Оля.**
На самом деле, проблема вот этого отсутствия семантики ещё чуть глубже лежит, на мой вкус. Потому что у нас сейчас в вебе есть разница между приложениями и документами. Разметка нужна документу, приложению разметка не нужна, потому что оно не работает без всех вспомогательных технологий. Разработчикам всегда надо думать, есть ли в их сайте документ? Документ должен быть размечен, потому что такова конвенция и так будет лучше всем. А вот остальные — это большой вопрос пока, как их делать.

**Вадим.**
У нас именно для этого есть такая штука, которая называется WAI-ARIA — это огромный набор aria-атрибутов, которые сделаны для того, чтобы описывать состояния веб-приложений. У документов есть старинный способ оформления — белый лист, чёрные заголовки, подзаголовки, параграфы, цитаты, синие ссылки — в интерфейсах приложений всё это не нужно. В интерфейсах приложений главное — сделать элементы и описать взаимодействия между ними. Так вот, эти aria-атрибуты описывают вот эти взаимоотношения между элементами. Они специально были сделаны для всего этого описания в ситуации, когда не хватает привычной нам семантики. Их можно и нужно использовать. Есть статьи, есть сборники паттернов, которые используются для разметки aria-атрибутами ради доступности веб-приложений. Но, ничто не мешает в твоём интерфейсе приложения использовать правильную систему заголовков, чтобы человек с какой-нибудь assistive technology мог бы передвигаться по твоему сайту от заголовка к заголовку и понимать, на каком уровне вложенности он находится. Ведь у всех есть какая-то иерархия интерфейсов — есть главный блок, шапка, сайдбар, есть какие-то вложенные блоки в нём — это всё можно описать html-элементами, которые когда-то были придуманы для документов. Они, в принципе, до сих пор подходят для описания интерфейсов приложений.

**Лёша** Я думаю, что, всё-таки, не хватает хорошей информации про семантику и доступность, и не просто хорошей информации, удобочитаемой, с хорошими примерами, а чтобы… Мне кажется, до конца не определена проблематика «почему я должен это делать», она не заложена каждому в голову. Помнишь, мы в прошлом выпуске говорили о том, как заложили в голову людям мысль, что таблицы — это плохо. Сейчас про семантику и доступность эту мысль о том, что это важно, не заложили в голову. Она где-то рядом витает, кто-то постоянно говорит, что нужно-нужно-нужно, но она как-то не заходит в голову, потому что непонятно, почему важно. Ты говоришь — вот поэтому и поэтому, но она как-то не остаётся. Не знаю, почему. Мне кажется, что нужно как-то в это поле приложить больше усилий, показывать и объяснять, почему это важно.

**Вадим.**
Я продолжаю это делать и буду продолжать. Может быть, когда-нибудь я попаду в цель. У меня получается рассказывать какие-то вещи, которые там застревают. Может быть, получится в один день рассказать про доступность так же понятно, чтобы люди запомнили.

**Лёша.**
Давайте тогда вернёмся к eBay, потому что у них сайтик с компонентами, которые должны быть доступными. И вот мне интересно: я всё время пользуюсь Safari, а у него, знаете, такая проблема, что у него не каждый элемент табается.

**Вадим.**
Это можно настроить на уровне системы в Mac.

**Лёша.**
Да, но я не понимаю, почему это по умолчанию не так. И каждый раз меня это немножко парит. Я хочу перейти на какую-то кнопку, которая не совсем кнопка, но у которой всякие роли прописаны, и фокусы есть, и tab-index, но она никак не табается. А вот у них, например, в тех же самых кнопках показано, и даже в Safari, который вроде как не должен фокусировать элемент, он переходит по нему табом.

**Вадим.**
Мне ещё очень нравится у них такой маленький паттерн, как поимка фокуса. И, в принципе, это довольно важная штука для доступности интерфейсов. Ведь что такое фокус таба? Допустим, вы в каком-то поле ввода, вы нажали таб и перешли, допустим, на кнопку (если там всё в порядке с кнопкой). Нажимаете дальше и проходите через какие-то ссылки на странице, а потом возвращается в адресную строку вашего браузера. Ну, обычно так всё происходит. А там есть техника, которая позволяет закольцевать поведение перехода этого таба внутри какого-нибудь интерфейсного элемента.

Объясню. Допустим, у вас на сайте какое-то очень важное модальное окно, которое подгружает совсем что-нибудь другое, замыкающее пользователя на этом элементе. Вы можете сделать так, чтобы у вас фокус замкнулся внутри этого окна. Довольно часто я вижу интерфейсы, в которых я пытаюсь табать по этому окну, а у меня фокус уходит под затемнение на большую страницу, которая лежит под этим модальным окном. В итоге мне приходится кликать мышкой ещё раз, возвращаться туда, и так далее. А можно замкнуть фокус внутри и таким образом вы из поля ввода перейдёте на кнопку закрытия, а потом снова в поле ввода. Довольно хороший паттерн, главное им, опять же, правильно пользоваться, чтобы не дай бог не забывать его откручивать и прикручивать вовремя.

**Лёша.**
Оля, ты как-то раз рассказывала о том, что ты пишешь лэндинги, делаешь их много, с удовольствием. А вы там как-то заботитесь о доступности? Про семантику я понял, что иногда это не требуется — ты сама сказала, а про доступность?

**Оля.**
Нет, у нас нет такой задачи. Все наши приложения, которые мы рекламируем, они не подготовлены. Поэтому нет ни возможности, ни задачи тратить время на подготовку доступности. Я понимаю, что это плохо, но пока вот так.

**Вадим.**
А есть ли у вас какая-то базовая структура заголовков? Скажу так: `<h1>` на странице есть?

**Оля.**
Есть, конечно. Семантика HTML, в каком-то виде, естественно, присутствует на наших страницах, по крайней мере, на тех, которые совсем с нуля делала я. Наш новостной сайт, он тоже нормально свёрстан, не одними `<div>` с классами. А вот с приложениями всё немножко сложнее.

**Вадим.**
Вот ты, Лёша, задаёшь мне провокационные вопросы. Я тоже задам тебе провокационный вопрос. Вот ты тут говорил: «А зачем? А кому это нужно?» Я понимаю, что ты играл в человека, который про семантику ни разу не слышал. А я у тебя другое спрошу: а зачем вы учите своих ребят семантике на курсах «HTML Академии»? У вас всё так серьёзно, что на первом этапе вёрстки сайта у вас студенты исключительно HTML верстают, и только потом им разрешают дотронуться до CSS?

**Лёша.**
Поменялись ролями, да? Почему мы так делаем? Ну, потому что мы считаем, что это правильный подход, потому что мы тут типа большие профессионалы уже и знаем, что это хорошо, это помогает… Мы просто поменялись ролями, и я рассказываю всё тоже самое, что ты говорил. Потому что это хорошо и для роботов, и для читалок, и для всего чего угодно. Документ — это важная штука, которая должна быть размечена правильно. Часто говорят, что на это нужно тратить дополнительное время. Проблема в том, что если вы знаете сразу же об этом, то не нужно тратить дополнительное время, если вы сразу же делаете хорошо — будет хорошо. Нормально делай — нормально будет. Вот поэтому мы специально новичков изолируем в ту систему, где у них в принципе нет ничего, кроме разметки. Почему мы так делаем? Если вы им всё сразу же будете рассказывать, вы их соблазняете забыть о разметке, о чём-то важном, а когда они ничего другого не знают — они учатся, делают. Если бы мы всё сразу рассказали, они бы забили на это. И вот когда такой процесс обучения выстроен, в каком-то замкнутом мире, то получается хорошо и хорошо все справляются. Вы просто подумайте: новички, которые в первый раз встречаются с вёрсткой, размечают документы семантически вернее, чем вы.

**Вадим.**
Вы, как хорошие родители, говорите им: «Сначала доешьте овощи, потом будет десерт» — в виде CSS, анимаций и прочего.

**Лёша.**
Да, так и есть. Про прогрессивное улучшение рассказываем. Наши новички умеют верстать сайты без JS — это вообще магия.

## CSS для новичков (29:40)

**Вадим.**
На этой неделе были хорошие статьи как раз для новичков, или, может быть, даже не для новичков, но по крайней мере, для людей которые открыты к обучению. Мы нашли перевод [Магия CSS](https://webref.ru/layout/magic-of-css) — учебника Адама Шварца, в котором он рассказывает про блочную модель, про какую-то базовую вёрстку макетов, про переходы, анимации, и так далее. То есть, довольно хорошее интро перевели на русский язык. Если вы хотите освежить свои знания или просто порекомендовать кому-то такой базовый учебник, то на русском языке, наверное, будет проще. Он, видимо, не совсем с нуля, но хороший.

И Бен Фрейн опуибликовал статью [Отладка CSS](https://benfrain.com/debugging-css/). Её, по-моему, пока ещё не перевели, но, мне кажется, такая вещь долго не залежится _([перевод статьи](http://css-live.ru/articles/otladka-css.html "Отладка CSS") — примечание редактора)_. Прочитайте её, там довольно интересно. Он проходит через базовые понятия того, как вообще CSS работает, и, если что-то пошло не так, что с этим делать. Вот, Оля мне рассказывала вчера: смешно, что этот учебник она порекомендовала своим программистам.

**Оля.**
Ну да, иногда возникает какой-то вопрос, почему вот так происходит, или что тут вообще происходит? Я говорю: «посмотрите тут, а это вот происходит потому». И слышу в ответ: «О, боже, это ужасное колдунство, что за CSS, не хочу ничего об этом знать!» Да, отладка CSS — это немножко странная вещь. В этой статье достаточно логично описано, как к этому подходить и почему оно всё так.

**Вадим.**
Все мы занимались отладкой CSS, и большинство в начале, и до сих пор включают-выключают свойства и добиваются нужных результатов методом тыка. Наверное, хорошо бы из этого сделать систему, и Бен Фрейн пишет как раз об этом. Не то чтобы это какое-то пошаговые руководство, как решить все проблемы, но, по крайней мере, оно немножко организует всё это дело. Я помню, как Юра Артюхов формулировал вот эту идею отсечения CSS: когда что-то жуткое происходит, ты удаляешь половину исходника и проверяешь — на месте ли баг, если на месте, то удаляешь половину оставшейся половины, и так далее. Это был один из первых методов с научным описанием, который я применял в отладке CSS, когда только начинал. Довольно интересно, что разные люди независимо к этому пришли без особых книг, без всего. Просто практика подсказывает, что, наверное, так нужно делать.

## Контроль версий и клиенты (32:09)

**Лёша.**
У нас тут на повестке дня клиенты для Git. Кажется, пора уже отойти немножко от семантики и доступности. Мы с вами хотели немножко поговорить про то, как кто работает с Git, какой workflow использует, и так далее. Ну, я надеюсь, все ведь работают с системами контроля версий?

**Вадим.**
Ну, дизайнеры через Dropbox работают, и ничего.

**Лёша.**
У нас сейчас продвинутый интенсив стартует, и там у меня первая лекция про Git как раз. Ты говоришь, что дизайнеры работают через Dropbox — это очень показательный момент, и я именно на нём показываю, почему работать с Git удобнее. У меня в примерах два дизайнера, которые друг другу макеты отправляют. И это просто шикарнейший, лучший пример, который можно найти и на котором можно легко объяснить, почему Git — это хорошо.

**Вадим.**
Ну расскажи немножко.

**Лёша.**
А что рассказывать? Ты же видел папочку дизайнера, в которой есть `maket.psd`. Потом `maket-1.psd`, потом `maket-2.psd`, `maket-3.psd`, потом появляется, после всех финальных правок, конечно же `maket-6-final.psd`. Потом, конечно же, приходится ещё немножко внести правок, поэтому появляется `final-final`, `final-final-final`. Потом у тебя такая гигантская папка из этих psd-макетов. Ну что тут рассказывать? Вот так.

**Вадим.**
Нет, ну смотри. Я небольшой фанат Dropbox, по-моему, это медленная сволочь. Но у них же, насколько я знаю, есть история версий. Соответственно, вы можете сохранить одно и то же имя, а потом возвращаться к предыдущим версиям.

**Лёша.**
Это совсем неудобно, тебе нужно видеть все версии, поэтому мало людей так пользуется. Дизайнер, например, удалил какой-то блок в какой-то из версий, а теперь в `final-final` версии понял, что, наверное, поспешил и надо всё-таки этот блок вернуть. И что ему делать? Через этот ужасный механизм Dropbox как-то там возвращаться, открывать этот psd, забирать этот слой, копировать его в свой новый макет? Ну, это же ад.

**Вадим.**
На самом деле, никто всерьёз не придумал ещё, как дизайны держать в контроле версий. Вот ребята из того же самого Protein, Zeppelin и прочих — пытаются в эту сторону двигаться. Но я видел интересную цитату в одном докладе, что код — это один из немногих важных инструментов, который дизайнеры ещё не освоили. И я с этим согласен. Может быть, когда дизайнеры будут больше верстать, у них получится и с контролем версий лучше работать. В Dropbox ведь не напишешь комментарий, почему этот блок убрал. И какой-нибудь патч не вернёшь из предыдущего коммита, чтобы что-нибудь доделать в новом дизайне используя элементы старого.

Почему мы вообще заговорили об этом? На этой неделе вышел клиент [GitKraken](https://gitkraken.com) — это такая штука, написанная на Electron со всеми его детскими болезнями в виде корявеньких интерфейсов, которые ты больше ожидаешь увидеть в вебе, чем на десктопе. В общем-то, альтернативный клиент, у которого есть тёмная и светлая темы. Собственно, я решил поговорить об этом просто потому, что я чувствую явный конфликт между любителями консольного Git и интерфейсных программ, которые позволяют немножко по другому работать. Вот вы, ребята, как работаете с Git?

**Оля.**
Я работаю через консоль. Не знаю, зачем нужны все эти интерфейсы… Наверное, для какой-нибудь сложной работы. Но, так как мне обычно надо сделать ветку, смёржить ветку, сделать ветку, смёржить ветку — я не заморачиваюсь.

**Лёша.**
А я практически всегда работаю через консоль. Единственное, что я делаю не через консоль — это когда я работаю с проектом в Atom, я просто отправляю коммиты из Atom, чтобы не переключаться на другой интерфейс. Но, тем не менее, потом я перейду в консоль, и сделаю там всё, что мне нужно ещё.

**Вадим.**
А мне очень всегда нравились программы с интерфейсами для Git просто по одной причине: консоль модальная. То есть, в один момент в консоли вы вызываете одну команду, и она вам показывает результат. Вы можете вызвать вторую команду, и, если у вас достаточно большое окно, вы увидите результат предыдущей команды и текующей. Два, скорее всего, ну, максимум, три — если у вас огроменный экран, вы увидите пять. И чтобы сделать что-то следующее, вы просто убираете все эти штуки с экрана, потому что они прокручиваются наверх.

В интерфейсе клиентов типа [Tower](https://git-tower.com), [GitHub Desktop](https://desktop.github.com), [GitBox](http://gitboxapp.com), [GitUp](http://gitup.co), и так далее — кроме умных вещей, которые позволяют вам делать меньше, писать меньше и как-то иначе смотреть на историю веток, коммитов и прочего, там нет модальности. Например, в Tower вы можете кликнуть на какую-нибудь вкладку history и увидеть все свои двадцать пять коммитов, которые влезут в один экран, быстренько пробежаться по ним глазами, выбрать нужный и кликнуть на него — у вас сразу появится и diff, и автор коммита, и что именно изменилось, и в каком месте изменилось, и что произошло, какая хэш-сумма, и так далее. Вы тут же получаете одним кликом информацию обо всём. Вам не нужно решать, что вы хотите сейчас увидеть: хэш коммита, или diff, или ещё что-то; у вас не откроется никакой Vim во время мёржа, у вас во время мёржа откроется какой-нибудь внешний редактор, или встроенная мёржилка.

**Лёша.**
Ну, это ты просто настраивать не умеешь. Можно настроить, чтобы у тебя и редактор открывался из консоли.

**Вадим.**
Нет, я верю. Есть всякие Git Dev Tool, Merge Tool и так далее.

**Лёша.**
Не-не-не, это вообще базовый функционал: где писать тебе merge — в Vim или в редакторе — определяешь сам, прямо в дефолте.

**Вадим.**
Я имею в виду, что большинство-то не настраивают, большинство-то просто работают с консолью. Ладно, я готов принять любые другие аргументы. Но вопрос модальности, когда вы можете сделать и увидеть только одну вещь, одну выбранную информацию, скорее всего, в не очень удобном виде — вот это для меня определяюще. Я могу легко искать по коммитам в нормальном интерфейсе, а не в какой-то адской консоли, которую кто-то раскрасил как новогоднюю ёлку. Я могу делать обзор коммитов и смотреть, насколько нормально дерево строится. Мой клиент периодически сам фетчит что-то с сервера, я могу посмотреть, когда появилась какая-то ветка на удалённом (remote), я могу понять, что пришёл какой-то пулреквест. То есть, мне не нужно думать: «пойду проверю, не появилась ли какая-то ветка». Он мне сам это делает. Очень много вещей автоматизируется, поэтому я знаю как пользоваться консольным Git, иногда бывают ситуации, когда я и так уже в консоли, и я что-нибудь там стэшу, добавляю к коммиту или ещё что-нибудь, или какое-нибудь сообщение коммита пишу — бывает. Но в большинстве случаев я предпочитаю открыть интерфейс и там всё натыкать.

**Лёша.**
Знаешь, как я говорю нашим ученикам на базовом и продвинутом интенсивах? На базовом интенсиве все они работают с GUI.

**Вадим.**
У вас там [GitHub Desktop](https://desktop.github.com) рекомендуется, да?

**Лёша.**
Да, потому что это GitHub-клиент. Мы на GitHub работаем, чтобы проще было. Можно использовать любой, но смысл в том, что мы не даём им использовать консоль вообще ‒ там задача не в этом. Там Git ‒ это просто средство. Раньше там был FTP, теперь там Git. Там совсем не до этого. А вот на продвинутом ‒ там нет никаких GUI, там только консоль, потому что любой разработчик должен понимать, как это работает. Вот ты сказал, что ты пользуешься GUI, потому что ты понимаешь, как работает это всё, понимаешь, как консоль работает, но пользуешься GUI, потому что тебе так удобнее — это, в принципе, нормально. Но, в отличии от тебя, в подавляющем большинстве случаев люди берут этот клиент, потому что они не понимают, как работает Git. И для них нужно, чтобы программа за них делала магию. Это такой чёрный ящик, в котором они не понимают, что происходит. Ты говоришь: «Я тыкаю на коммит, и у меня всё показывается». Но человек абсолютно не понимает, что произошло.

**Вадим.**
Я не думаю, что средний разработчик понимает, как Git вообще всё это делает. Git очень много магии делает. Он резолвит всякие мёржи, конфликты, делает очень много автоматики, в отличие от SVN.

**Лёша.**
Да. А ты тут ещё больше магии наворачиваешь за счёт того, что используешь GUI-клиент. И ты становишься рабом этого клиента. Git можно пользоваться по-разному. А вот в каждых GUI заложен какой-то, чаще всего один механизм. То есть, они считают, что тебе нужно работать с твоими репозиториями вот так. И ты работаешь именно вот так, потому что это GUI. Ты заложник этого. Если вдруг этот клиент решит как-то перестроить твой процесс ‒ тебе придётся перестраиваться. Если этот клиент не поддерживает какую-то фичу ‒ у тебя этой фичи нет. Если вдруг у тебя обновится версия Git — хотя, скорее всего, этого не произойдёт, но мало ли — ты вдруг обновляешь консольные утилиты, а клиент не научится работать с какими-нибудь штуками, которые сильно поменялись в самом Git, и у тебя сломается твой клиент. GUI — это хорошо конечно, но тут всегда компромисс между удобством и поддерживаемостью.

**Вадим.**
Оля, а ты не пробовала GUI-клиент? Просто интересно.

**Оля.**
Нет. Просто не за чем. Я не знаю, что они мне могут дать, у меня есть вся нужная мне функциональность в консоли. Очень редко бывает, когда мне нужно посмотреть историю ‒ я иду в веб-интерфейс и там смотрю.

**Вадим.**
А у тебя бывали сложные мёржи, допустим? Что ты используешь для мёржа?

**Оля.**
Команду `merge`. Если там есть конфликт, я открываю редактор и всё правлю. В чём проблема-то?

**Лёша.**
Я точно так же. Открываешь редактор и просто правишь конфликт.

**Вадим.**
В редакторе все эти ёлочки, ты видишь, где там конфликт?

**Оля.**
Да.

**Лёша.**
Вадим просто говорит о том, что ему нужен инструмент, который ему это красиво покажет и он кликом будет говорить, что он этот кусочек коммита хочет.

**Вадим.**
Ну, да.

**Оля.**
Ну, это какое-то сибаритство.

**Вадим.**
Ну, не знаю. Я просто люблю, чтобы было удобно, не смейте меня в этом обвинять!

**Лёша.**
Не-не-не, это лень, это нормально. Все разработчики ленивы. Это, в принципе, нормально. Но при этом нужно понимать, что это всё-таки продиктовано ленью.

**Вадим.**
Ну нет, пожалуйста…

**Оля.**
Честно говоря, я тоже могу сказать, что у меня это лень, потому что я не хочу изучать никакие там новые клиенты. Я как привыкла с консолью работать ещё с каких-то чудовищных систем контроля версий, которые сейчас даже не помню как называются, так и продолжаю. Может быть мне бы принесли что-нибудь новое эти десктопные клиенты, но как-то вот не срастается.

**Вадим.**
Есть два типа клиентов, которые мне нравятся. Я периодически пробую разные клиенты для Git. Одни клиенты ничего не добавляют к логике, которая есть в обычной консоли: просто ставишь галочку, добавляешь какой-то файл, потом пишешь комментарий и нажимаешь коммит, и он тебе показывет историю ‒ всё. А слева список репозиториев. Я люблю такие базовые клиенты без кучи кнопок, без кучи всякой ерунды. Вот таким клиентом был [GitBox](http://gitboxapp.com). Но, по-моему, последняя версия выходила в 2012 году, и, к сожалению, автор совершенно забросил его. А я когда-то был большим фанатом.

С другой стороны, есть клиенты, которые пытаются сделать что-то альтернативное. Показать тебе твои ветки в новом интерфейсе, какие-то интересные переплетения, взаимодействия внутри твоего репозитория. И вот такой клиент, [GitUp](http://gitup.co) называется — как раз интересен тем, что он помогает тебе по-другому посмотреть на твой репозиторий. Поэтому, если вы не пробовали, если вы хотите попробовать что-то такое, посмотрите на GitUp ‒ он довольно интересный. Вот именно [GitHub Desktop](https://desktop.github.com/) мне не нравится тем, что он упрощает всё настолько, как будто у тебя GitHub, а не Git. По-моему, он немножко ломает типичную модель взаимодействия с коммитами. Там есть такая вещь, как синхронизация — ты не пушишь и пулишь, ты синхронизируешь — вот это, по-моему, вредная штука.

**Лёша.**
Я согласен. `Sync` — это на самом деле `pull`, `push`. Это, наверное, вредно. Но опять же, смотря, какая у тебя задача. Ты новичку не сможешь объяснить вот эти концепции сразу же.

**Вадим.**
Ну да, да.

**Лёша.**
Не сможешь, и всё. А команда `sync`, она вообще-то более человечная.

**Вадим.**
У меня как-то Брюс Лоусон спросил: «А почему на GitHub нет кнопки типа „синхронизироваться с оригинальным репозиторием“?» Ты форкнул что-то, ты месяц его не трогал. Была бы кнопочка «синхронизировать мой форк», которая берёт и пулит из родного репозитория что-то и обновляет твой форк. На GitHub до сих пор нет такой кнопки, и для этого нужно зайти в консоль, сделать `checkout`, потом сделать пул из какого-то оригинального ориджина.

**Лёша.**
(шёпотом) Апстрима, апстрима.

**Вадим.**
Апстрима, да. Кстати, вот у нас сейчас [твой пулреквест](https://github.com/web-standards-ru/dictionary/pull/235) про Git-термины в словаре терминов по фронтенду. В общем, скоро мы опубликуем _([опубликованы](https://github.com/web-standards-ru/dictionary/blob/master/git.md "Термины Гита и Гитхаба") — примечание редактора)_ те термины, которые ребята из «Академии» используют в своём обучении. Так что, может быть, вам самим будет немножко проще говорить на одном языке вместе с нами.

## JS-модули в Edge! (45:51)

**Лёша.**
Я предлагаю ещё немножко поговорить про ECMAScript, потому что на этой неделе наконец-то сдвинулась самая большая проблема ‒ ES-модули. И в блоге Edge — Microsoft тут хочет застолбить за собой право первооткрывателей — [рассказали](https://blogs.windows.com/msedgedev/2016/05/17/es6-modules-and-beyond "Previewing ES6 Modules and more from ES2015, ES2016 and beyond"), что в последней сборки Edge они добавили экспериментальную реализацию ECMAScript-модулей. Мне даже удалось перед подкастом установить этот новый Edge, посмотреть, поиграться немножко. И я вам скажу ‒ это и правда работает, импорты и экспорты работают в Edge. И, более того, работает `<script type="module">`.

Расскажу немножко подробнее, как это происходит. В первую очередь, если вы хотите использовать импорты и экспорты в любом скрипте, то этот скрипт обязательно должен быть подключен в HTML с атрибутом `type="module"`. В обычном скрипте импорты и экспорты просто выключены, они работать никак не будут. Вместе с `type="module"` у вас появляются конструкции `import` и `export`, и вы можете прямо из них подключать какие-то дополнительные файлы. Кстати, знаете, что смешно? В примере, который в блоге Edge показан, там вообще ошибка.

**Вадим.**
Подключается HTML-скрипт, а комментарий джаваскриптовый, да?

**Лёша.**
Не, не. Подключается HTML-скрипт, но не закрывается.

**Вадим.**
А, да-да. Когда я пишу новость, я иногда копирую код из каких-нибудь блогов, вставляю в Atom и делаю скриншот для картинки. Так вот, я помню, что я скопировал, а там незакрытый тег. Я его закрывал руками.

**Лёша.**
Вот. А я сначала тоже не заметил. В первую очередь, чтобы попробовать, скопировал пример, посмотрел, но при этом вставил ещё скрипты сверху и снизу, чтобы посмотреть, как оно работает, когда что показывается. И ничего не работало. Я думаю: «что за фигня, может, у меня Edge кривой?» А потом смотрю ‒ действительно ошибка.

**Вадим.**
Внимание, авторы статей и докладов! Пожалуйста, убедитесь, что ваши фрагменты кода работают без ошибок, что у вас там прямые кавычки, теги закрыты и так далее, потому что иногда примеры хочется скопировать и попробовать.

**Лёша.**
Да, именно так и произошло. Ну, что я скажу? Штука работает. Она, конечно, за экспериментальным флагом, но работает такая базовая концепция. Она, конечно, кривоватая — у меня она там падает туда-сюда. Но, в принципе, у меня получилось завести пример.

Если у вас есть ряд скриптов, то все скрипты подключаются друг за другом. И скрипты с `type="module"` тоже подключаются друг за другом. А вот всё, что дальше, оно подключается асинхронно. Если у вас есть два тега `<script type="module">` и просто `<script>`, оба они будут подключаться асинхронно друг с другом. И, если вы подключаете что-то из импорта, то оно тоже в каком-то отдельном процессе асинхронно от всех остальных скриптов на HTML-странице. Но при этом оно подключается и выполняется когда загрузится. То есть, вроде всё работает, как мы хотим.

Но, опять же, это только первая реализация, в ней ещё много чего не работает. Например, вы не можете динамически подключать модули, всё только статически. Вы декларативно объявляете наверху все импорты, которые вам нужны и они все подключаются. Сделать так, чтобы импорт подключался при каком-то условии, пока нельзя. Они говорят, что они над этим работают. И спецификация лоадеров тоже ещё не закончена, ещё будет работа над ней. В общем, Edge попытался застолбить за собой право первых. Вроде как у него получилось, по крайней мере, формально. Но, тут смешно было про Firefox, ты рассказывал мне, Вадим.

**Вадим.**
Да, [Firefox попытался застолбить](https://twitter.com/jlongster/status/732645925978550272) за собой право вторых. Обычно так это делают ребята из Webkit — они такие приходят и говорят: «А кстати, а у нас это уже давно есть, просто мы не рассказывали». Ребята из Firefox тоже прибежали, говорят: «А вы знаете, мы тоже уже реализовали модули, просто ещё никому не показали — вот вам скриншоты». Они показали скриншоты работающих модулей в сборке Firefox, которая запущена на компьютере какого-то разработчика, но пока никому не доступна. То есть, давайте, просто поверим, что модули работают в каком-то движке, кроме Edge.

**Лёша.**
Вообще, это замечательно. Наверное, к концу года мы будем иметь такую реализацию во всех браузерах. Я вот только очень бы хотел, чтобы в Safari, который, скорее всего, выйдет осенью с новой операционной системой — чтобы они как-то постарались подумать над модулями. Иначе нам придётся ждать ещё год, а этого бы не хотелось.

**Вадим.**
А модули не полифилятся в итоге никак. Вот, чтобы они работали прямо так, как они должны работать.

**Лёша.**
Не-не, вообще не полифилятся. Тебе придётся бандлить всё, а это значит — бандлить и во всех других движках, где можно было бы работать. Нет вариантов. Это такая системная штука.

**Вадим.**
Она просто меняет поведение JS, поэтому это всё не отполифилить. Тоже самое, как с проектом «Houdini» — там слишком много слишком сложных вещей, поэтому css-свойства не отполифилить. Для этого нужно забираться глубже.

**Лёша.**
Кстати, если оно к концу года появится, то это будет даже хорошо, потому что HTTP/2 уже, наверное, можно будет использовать. И вот вместе оно, по-моему, очень гармонично будет смотреться. Я вот, например, эту фичу очень жду, и если меня спросят в конце года ‒ самая ожидаемая фича, которую я ждал — я, наверное, расскажу как раз про модули.

## Google I/O (51:42)

**Вадим.**
Мы обычно о событиях говорим вначале выпуска. Но тут есть событие, о котором решили поговорить в конце. На этой неделе прошла большая конференция [Google I/O 2016](https://events.google.com/io2016). Это такая конференция, типа WWDC от Apple, на которой три дня Google рассказывает обо всём новом, что у них есть. Они представили какую-то новую железку для управления умным домом, показали одну, другую вещь. Но, в общем, это всё ерунда. Главная новость этого Google I/O в том, что Google всё больше [говорит про веб](https://youtube.com/playlist?list=PLNYkxOF6rcIDz1TzmmMRBC-kd8zPRTQIP "Веб и Chrome на Google I/O"). И продолжает говорить про веб очень много и очень серьёзно.

Меня это страшно радует. Кстати, сегодня мы ещё не упоминали про компанию Opera — удивительно. Так вот, мы как компания Opera поставили на движок Chromium, потому что он сильно ориентирован на веб, который нам всегда нравился. И когда я слежу за новостями с Google I/O, я вижу, что веб в большом приоритете у компании Google, и мне становится немножко спокойнее, потому что когда я слежу за новостями с WWDC от Apple, я вижу железки, софт, AppStore и у нас что-то новое и очень крутое, но ни слова про веб обычно.

Так вот, что же было интересного в Маунтин-Вью 18-20 мая? Очень много докладов было, и мы потихоньку начали публиковать уже все доклады в наших новостях. Но, если резюмировать то, о чём говорят на Google I/O, можно назвать две ключевых вещи, две аббревиатуры: [PWA](https://developers.google.com/web/progressive-web-apps) и [AMP](https://ampproject.org).

PWA ‒ это не клей, это Progressive Web Apps. Кто слышали наши предыдущие выпуски, давно уже об этом знают. Некоторым, наверное, уже надоело. Но суть в том, что это способ сделать из страниц приложения, которые можно устанавливать в операционные системы. Они работают с оффлайном, со всеми браузерными API. У них есть описание их поведения, иконок, загрузки и так далее. У них есть Service Worker, который по умному работает с сетью. У них есть пуш-уведомления. В общем, всё на свете, чего нам не хватает, чтобы делать из сайтов веб-приложения, чтобы они чувствовались, как нативные. Так вот, Progressive Web Apps решают эту проблему.

А AMP решает другую проблему. Он решает проблему скорости загрузки страниц. На PiterCSS во вторник будет доклад про AMP. Accelerated Mobile Pages — это такое подмножество современных веб-технологий, сильно ограниченное. Если зайти сейчас на типичную страницу в интернете, то она грузится-грузится-грузится: «О, соединение потерялось, чёрт, ладно, на следующей станции метро догружу». AMP загружается мгновенно. Почему? Потому что там не исполняется внешний JavaScript. Там ограничены доступы к каким-то разным технологиям. Там есть чёткая спека, которая описывает, как валидные технологии (там в основе, конечно, HTML) должны быть исполнены. А если страница не валидная ‒ браузер показывает вам, что страница не валидная, как было с XHTML. У Facebook и у других ребят есть [Instant Articles](https://instantarticles.fb.com) ‒ особый формат, который работает на основе RSS, примерно. В общем, крупные компании пытаются сделать страницы, которые будут работать очень быстро, невероятно быстро, которые даже не загружаются ‒ они уже там, когда вы их запросили.

Так вот, с одной стороны, Google пытается двинуть страницы, чтобы они работали нативно, с другой стороны он пытается двинуть, чтобы обычные веб-странички грузились мгновенно, моментально и без тормозов. Такие, две немножко противоречащие, очень разные штуки, но это два ключевых термина с конференции Google I/O. Естественно, там ещё много говорят про оффлайн, про всякие HTTPS. И, наверное, ещё большой новостью стало то, что Google не просто активно продвигает API для платежей в вебе, а они собираются их до сезона осенних праздников и распродаж внедрить в браузер.

На этой неделе была интересная [статья про автозаполнение](http://blog.cloudfour.com/autofill-what-web-devs-should-know-but-dont "Autofill: What web devs should know, but don’t"), в которой прошлись по всем методам, которые существуют для автозаполнения форм браузера, и как они реализованы, и в чём вообще разница между реализациями. Выяснилось, что всё довольно плохо. Так вот, одним из способов решить проблему с автозаполнением в браузере будет новый API для платежей в вебе. И этому посвящён отдельный доклад; мы, конечно, на неделе дадим ссылку на него, поэтому внимательно посмотрите ‒ это поменяет то, как пользователи заполняют ваши формы.

Лёша, а ты видел что-нибудь интересное на этом Google I/O, слышал о чём-то?

**Лёша.**
Я за Google I/O следил. Я почему-то больше всего видел не про веб, а про всякие железки, как раз-таки наоборот. Кстати, сравнивал Apple и Google. Мне кажется, что Google уделяет так много внимания вебу, потому что они зарабатывают через веб. Они не научились ещё зарабатывать не через веб. И тут тоже самое с Apple ‒ у них ровно наоборот, они зарабатывают не через веб, а через свои железки. Поэтому всё достаточно логично ‒ каждая компания делает то, что приносит ей больше прибыли. И в этом смысле для Opera и правда хорошо быть рядом с Google, потому что для них веб важен. Но, вот ты спросил меня, что я видел ‒ я видел очень много железок. Во-первых, железки. Во-вторых, приложения — это всякие чатики, чат-боты, управление домами, и так далее. То есть, Google всё-таки пытается в железки уйти. Поэтому, я бы на вашем месте не был бы так уверен в том, что веб будет всегда для Google первоочередным. Но, по крайней мере, очень-очень долгое время, наверное, так и будет.

**Вадим.**
Я тоже понимаю, что много всего анонсировали софтверного и железного Google, я конечно, слежу за вебом, но я имею в виду, что не возникает ощущения, что веб ‒ это просто одна из платформ, это прямо одна из ключевых. Даже приложения, которые чисто софтверные получили очень интересный поворот в стиле веба. Там ведь Google сделал так, что приложения из PlayStore можно будет устанавливать просто кликнув по ссылке. вы кликаете по ссылке ‒ и приложение запускается. Оно не ставится в вашу систему, оно не загружает 500 метров, оно не просит разных разрешений. Вы просто кликнули, произошёл какой-то редирект, и оно запустилось. И там очень сильно имитируется модель работы веба в этот момент, хотя никакого веба как такового нет. Может быть там веб-протоколы используются, но не более того. Веб-технологий там нет особо.

**Лёша.**
Да, кстати, это было интересно. Недавно ещё показали, что будет подгрузка контента в приложениях. Если тебе нужен кусок кода для твоего приложения, который используется не в основной части, а чуть-чуть позже, то он не будет грузиться сразу же, а подгрузится позже. Ну да, это было интересно. Но мы совсем сейчас не про веб.

**Вадим.**
Каждый третий в моей англоязычной Твиттер-ленте опубликовал ссылку на [комикс xkcd](https://xkcd.com/1367/), про то, как «я сделал это, сделал это ‒ ой, я кажется переизобрёл веб».

**Лёша.**
С вами был семнадцатый выпуск подкаста «Веб-стандарты» и его постоянные ведущие: Вадим Макеев из Opera, Ольга Алексашенко, верстальщик руками из Exante…

**Вадим.**
И Алексей Симоненко из HTML Academy.

**Лёша.**
Услышимся.

**Оля.**
Всем пока!

**Вадим.**
Пока!
