# Выпуск №10

5 апреля 2016: Bash на Windows, обновления Safari, правильный фронтенд, нужны ли препроцессоры, ES2016.

- Ольга Алексашенко
- Вадим Макеев
- Алексей Симоненко

## События

**Вадим.** Привет, с вами 10-й юбилейный выпуск подкаста «Веб-стандарты» и его постоянные ведущие: Алексей Симоненко из HTML Академии, Ольга Алексашенко из Exante.

**Оля.** И Вадим Макеев из Opera.

**Вадим.** У нас опять не очень много событий происходит вокруг, но мы по-прежнему едем на DUMP и «Стачку» с Алексеем, где расскажем свои доклады. Я буду рассказывать доклад про гриды, который я презентовал на CodeFest, так что приходите послушать. DUMP — 8 апреля, Стачка — 22 и 23. А вы, Лёша, приедете с Виталием?

**Лёша.** Мы с Виталиком приедем на DUMP, где он расскажет про баги в браузерах. А на «Стачку» мы поедем с еще одним Лёшей и он там расскажет про регрессионное тестирование на массовых аудиториях. Достаточно интересный доклад про то, как мы большое количество людей автоматически проверяли, как они верстают полностью проект.

**Вадим.** И поскольку мы с Лёшей оба там будем, то скорее всего мы возьмем все свое оборудование и будем записывать подкасты прямо там, благо все там на выходных, как раз к понедельнику будем выкладывать выпуски. Еще непонятно с кем будем записываться. Может с Олегом Моховым на DUMP, а на «Стачке» Рома Дворнов или еще кого-нибудь вытащим, поговорим. В общем: будут у нас выпуски выездные следующие.

## Bash на Windows

**Лёша.** На этой неделе прошла конференция Microsoft Build 2016, где ребята показали очень интересную штуку, которая позволяет появиться наконец-то bash и юниксовым инструментам внутри нашего любимого Windows. Ну, как нашего любимого, я думаю, что из авторов этого подкаста никого уже нет, кто пользуется Windows. Да ведь, ребята?

**Оля.** Да!

**Вадим.** Ну да, я давно ушел и не то что бы скучаю, но иногда с интересом поглядываю.

**Лёша.** Вот. А многие до сих пор сидят на Windows и для них то, что показали на этой конференции было таким неким _вау_, потому что внутри Windows появится возможность запускать настоящие живые юниксовые команды. Наконец-то мы сможем собирать проекты, использовать `grep`, `sed` и все остальное. Вот такой вот интересный момент. Они это делали вместе с компанией Canonical, которая разрабатывает Ubuntu и это не совсем виртуализация, не совсем что-то похожее на Cygwin, которым вы сейчас пользуетесь. Это именно преобразование вызовов Ubuntu в вызовы Windows. Вы пишите обычные команды Ubuntu, а система автоматически понимает, что ей нужно запустить в Microsoft.

**Вадим.** Они это назвали какой-то подсистемой Linux на Windows, в общем какая-то сложность у них там. Главное, что для вас это все будет прозрачно: вы будете делать обычные вещи, которые вы делаете на Юниксе, на ваших там серверах, а потом получать все тоже самое. Я помню момент перехода свой на Мак и было интересное ощущение, что я получил систему, которая работает точно также, как сервера на которых работали проекты компании, собственно в которой я верстал. И у меня было ощущения, что я могу поднять весь целиком проект на компьютере и не просто через какой-нибудь Denver, помните такая штука была? Не поднимать Apache и настраивать MySQL и так далее, а делать простые вещи такими же юниксовыми инструментами, как были доступны на сервере. Кое-что всегда можно было сделать, но полноценно не работало. Сейчас эпоха немного поменялась, но мы по-прежнему очень сильно зависим от юниксовых утилит, наверное даже больше, чем раньше, потому что сейчас очень много всяких сборщиков на Node.js, типа Gulp, Grunt или таск-раннеров — они оперируют юниксовыми утилитами, а не просто JS, соответственно просто запускаются то, что есть в системе. Какой-нибудь `gulp-rsync` или похожие вещи не берут с собой бинарники, а используют системные, такое бывает тоже. Соответственно это сложности большие и в общем-то сама идея Unix, отдельных утилит, npm-скрипты, которые позволяют использовать системные утилиты и легко описать нужные вам таски.
Все это будет доступно для пользователей Windows и Windows перестанет быть платформой на которой приходится работать, потому что нет мака.

**Лёша.** Да, это звучит очень заманчиво. Они еще и с файловой системой поработали, то есть например, когда вы находитесь внутри Bash, внутри вашей консольки вы можете получить доступ ко всем вашим дискам: C, D, E. Ну если вы работали в Unix и Windows, то вы понимаете, что файловая система у них немного разная. И точно так же наоборот, если вы открываете свой любимый Проводник, или как он там сейчас называется, вы можете в папочке AppData и еще несколько уровней вниз найти ваши привычные юниксовые папочки: ETC, usr, local и все остальное. Всё это будет жить прямо у вас на компьютере и работать вместе. И еще момент, очень удобный вам: вы наконец-то сможете выкинуть программку Putty с помощью которой еще я когда-то, лет 10 назад, коннектился по SSH к серверам, потому что другой возможности не было. И сейчас ее можно просто выкинуть и пользоваться просто Bash, обычно писать SSH и ваш сервер и заходить туда. Конечно, есть еще большое количество проблем: плохо работает `tmux`, еще несколько утилит, которые именно оконными менеджерами занимаются. Но в целом направление, которое взяли Microsoft, оно очень интересное. Мне кажется Windows снова становится интересной платформой для разработки.

**Вадим.** Мне еще приятно, что здесь происходит взаимодействие двух принципиально разных сред, то есть Windows, как большого коммерческого продукта: корпоративный, кровавый энтерпрайз и вот это все, и все такие хиппи от технологий: Canonical, Ubuntu, Linux и вот это все. Дастин Киркланд подробно рассказывает о внедрении, поскольку он сам этим занимался и довольно интересно, что давние враги, по крайней мере сильные конкуренты, которые обзывали друг друга плохими словами и кидались чем попало сейчас начинают взаимодействовать, чтобы разработчикам было удобнее. Поэтому на это очень приятно смотреть, даже если вы давно работает на маке и это не ваша проблема.

**Лёша.** Меня только один момент настораживает. Я, конечно, давно на Windows не находился. Меня настораживает то, что там в том числе будут работать такие команды, как `apt-get`, например, то есть установка пакетов, обычных пакетов, как мы на Ubuntu ставим. Тут вот я не очень понимаю, они же будут компилироваться. Очень много всякой сложной фигни должно прийти в Windows и мне интересно, как это все будет работать, правда ли можно будет поставить вот вообще абсолютно все, правда ли можно будет скомпилировать свой собственный nginx или Apache прямо под Windows, если это так, это по моему очень круто.

**Вадим.** Нет, ну давайте не увлекаться, у нас тут фронтендерский подкаст, а уж что там у себя линуксоиды через `apt-get` собирают с помощью `make` — отдельная история. Главное, что наши самые любимые утилиты, которыми мы каждый день пользуемся, будут доступны.

## Новая тестовая сборка Safari

**Вадим.** Другая большая новость на этой неделе о том, что Apple, тоже большая компания, неожиданно обратила внимание на разработчиков. Не то чтобы неожиданно, она делала попытки в последнее время: релиз Safari 9.1, такое ощущение, что он был сделан исключительно для разработчиков, что вообще в новинку для Apple, потому что мы получили очень много фич и на iOS и на macOS. Мы получили всякие там штучки: трехсот миллисекундные задержки для тапа, для тача…

**Лёша.** `<picture>` же, `<picture>`

**Вадим.** Да, точно, `<picture>`, как же вылетело. Так что рады, рады. Надеюсь, они будут чаще делать такие минорные штуки, которые будут приносить новые фичи для веба. Так вот они пошли дальше. У Apple всегда были сборки WebKit движка, которые скачивались и работали, используя встроенный системный Safari, как «морду», грубо говоря, как интерфейс браузера, но подменяли движок. И эти сборки были достаточно нестабильны, регулярно разработчики WebKit извинялись: ой, извините, у нас тут все немножко поломалось. Со свежим выходом macOS вы не сможете запускать эту сборку, точнее сможете, но она будет работать с другим движком. Постоянно были какие-то проблемы. А сейчас они выпустили более стабильную версию [Safari Technology Preview](https://webkit.org/blog/6017/introducing-safari-technology-preview/). То есть видимо договорились с разработчиками macOS и теперь этот браузер будет обновляться через встроенный AppStore, там будет полноценная синхронизация с iCloud, там будет поддержка расширений нормальная и вообще: все будет хорошо и удобно. Разработчики, кому нравится, кому интересно, смогут использовать Safari на маке, как основной браузер, потому что раньше это было сложновато из-за того, что каждый раз при запуске он открывал *насильно* страницу webkit.org, не работал нормально с какими-то системными фичами. В общем-то: был нестандартным. А поскольку у нас тут тенденция выпускать браузеры специально для разработчиков (Firefox Developer Edition) и другие похожие штуки, то Apple в общем-то встроилась в этот тренд очень хорошо. Из интересного, что уже было в WebKit, но стало доступнее широким массам разработчиков, там появилась поддержка Grid Layout, то есть гридов, но с префиксом `-webkit`. И сейчас можно посравнивать удобно реализации: реализации Chrome — одна штука, реализация Firefox — другая, а реализация WebKit — немножко третья. На самом деле реализации гридов в Chrome и WebKit занимались примерно одни и те же люди и код во многом реиспользуется, но все равно три независимые реализации. Так вот, чтобы потестить все это мне, как человеку, который делает доклад про Grid Layout`, приходилось писать очень много префиксов руками, а информации про гриды не было в Can I Use, соответственно я пошел в Can I Use, отправил заявку, мол добавьте префиксы — они добавили. Потом пошел к Ситнику и сказал, мол запили в автопрефиксер поддержку гридов и в общем-то на выходных было обещано, что все это будет исправлено, максимум на неделе. И мы сможем экспериментировать с гридами нормально и в Safari Technical Preview.

**Лёша.** Знаешь, что интересно? В той статье, которая вышла на webkit.org, где они рассказывали, какие фичи появятся в Safari Technology Preview, не было вообще упоминаний про гриды. Это вот интересно, что вы раскопали и нашли, потому что я не видел ни в одном анонсе публичном про гриды информацию.

**Вадим.** Они то включали, то выключали их именно в WebKit, а вот в Safari они теперь точно появились и, видимо, будет. Поскольку спека не готова, технология не готова, а Apple любители таких полированных вещей, которые прям идеально работают, они не очень любят внедрять неготовые спеки, точнее говорить о них, даже если внедрены. Но интересно, что буквально вчера или позавчера прошел слух, что ребята из Safari и WebKit подумывают о том, чтобы перейти на ту же самую систему с флагами, которая сейчас в большинстве браузеров есть. Суть этой системы в том, что вы не просто внедряете фичу в браузер и прячете ее за префиксами, то есть она все равно работает в браузере, но доступна только через префиксы JS или CSS. А вы внедряете фичу в браузер, выключаете ее, она не работает, не тормозит браузер, если она какая-то принципиальная. Но разработчик может включить ее и попробовать в стабильной версии браузера, но вот под флагом, и не придется городить префиксы, вы сразу сможете писать нормальный код, живой CSS, а не гонять его через автопрефиксер или писать руками, если спека совсем сырая-пресырая и еще никто ее не автопрефиксит. То есть это хорошая новость. Apple опять слушает разработчиков, по крайней мере прошел слух. Посмотрим, будет ли так на самом деле. Мне эта модель нравится больше, потому что я настолько отвык писать префиксы, что я даже не думаю о них и было огромной болью писать их руками для моего доклада. А вы, ребята, когда последний раз префиксы писали?

**Оля.** Эм… Очень давно. Года два назад, наверное.

**Лёша.** Я префиксы тоже писал руками очень давно и последний раз, наверное, это было, когда нужно было что-то руками написать для какого-то доклада, что еще не поддерживал автопрефиксер. А так по-моему префиксы перестали писать руками.

**Вадим.** Я еще пишу префискы до сих пор руками, но в ситуациях, когда это какие-то нестандартные свойства WebKit, какой-нибудь `font-size-adjust`, что-нибудь вот такое.

**Оля.** Ну да-да, такое бывает.

**Вадим.** И они прямо сразу выглядят, как хаки, а раньше это просто было нормальной частью нашего кода. Так что давайте еще земной поклон Андрею Ситнику за его автопрефиксер. *Поклонились*.

**Лёша.** Я еще хотел чуть-чуть остановиться, потому что, я понимаю, что вы не очень все любите JS, а мне вот он нравится. Мне понравилось то, какую поддержку ECMAScript 6 показали в Safari Technology Preview, потому что в текущей версии, которая у нас 9.1, всего лишь 53% поддерживается всех-всех фич, которые у нас есть под этим названием ES6. А вот в этом Technology Preview 98%. То есть почти стопроцентная поддержка всех вот этих новых, вкусных фич прямо в браузере. И насколько я помню, это самый большой процент из всех браузеров, в том числе ночных, то есть, по моему, это очень круто. Я вот любитель браузера Safari, это мой основной браузер, потому что мне нравится, как он работает, что он быстро работает, как он выглядит на маке, мне кажется, что он наиболее естественно выглядит. И я, конечно, все время огорчался, что вот он так плохо поддерживает разработчиков, а тут они вроде начинают обратный путь и это очень круто, меня это радует.

**Вадим.** Ни то что бы тебе как пользователю пригодятся эти 98% фич ECMAScript6.

**Лёша.** Конечно, это же как разработчику. Я же хочу писать все эти `let`, `const` в браузерах, а мне может только Safari там не хватало.

**Вадим.** Ну действительно, так ситуация выглядит с ECMAScript сейчас, что мы используем какие-нибудь сборщики типа Babel для того, чтобы его писать, и даже если какая-то мини фичечка, которая нам нравится, всего одна осталась, то мы все равно будет использовать Babel, чтобы писать. В общем, я не знаю закончится ли этот порочный путь когда-нибудь, может быть когда у нас уменьшится количество фич в браузерах.

**Лёша.** Да нет, конечно изменится. Просто мы же Babel можем тоже ограничивать: перестать использовать транспайлинг `let`, `const`, транспайлить только то, что очень плохо поддерживается, а то, что хорошо поддерживается, выкинуть из Babel. Babel последний позволяет это делать.

**Вадим.** Это я понимаю, но этот экстра-шаг в сборке все равно никуда не уйдет, если мы будем продолжать такими же темпами двигаться. Поэтому какая разница?

**Лёша.** Это знаешь, такое внутреннее желание, что все идет, все развивается и рано или поздно мы это выпилим. По поводу выпиливания: в этом Safari Technology Preview ведь они наконец сделали программную возможность работы с буфером обмена, ведь это последний браузер, который оставался и не позволял нам забирать информацию из буфера обмена. То есть все, когда он реализуется, можно будет выкинуть все эти flash-плагины, которые мы ставили на сайты, чтобы работать с буфером обмена. Это тоже такой момент, когда мы выкидываем какой-то старый способ, старый библиотеки. По-моему это хорошо.

## Оценка задач фронтендера

**Оля.** Перейдем от технологических тонкостей к более практической части нашей фронтендерской работы. На этой неделе Frontender Magazine выпустил перевод статьи [«Оценка задач фронтендера»](http://frontender.info/estimating-a-front-end-web-dev-job/). На самом деле, эта статья может вас на первый взгляд обмануть, на второй расстроить. Но на самом деле она очень полезная. Почему обмануть: вы идете туда смотреть, а там пользовательские сценарии, Scrum, что это вообще и зачем все это нужно, очень страшно. При слове Agile средний разработчик вообще убегает с визгом. На самом деле здесь описан способ, уже выходящий за рамки профессии фронтендера, разработки, который идет от пользовательских сценариев, то есть вы должны со своим клиентом сначала поговорить о пользовательских сценариях, а затем уже разрабатывать какой-то продукт, какой-то прототип и это будет круто. Ну да, в наших мечтах это было бы конечно круто! Но в начале статьи описан более расхожий способ создания проектов на фронтенде: кто-то продает проект клиенту с заранее оговоренной датой релиза, кто-то делает дизайн, а кому-то этот дизайн приносят и говорят: надо сделать вот до такого-то числа, давай фигачь!

**Вадим.** Разве это не 99.9 процентов?

**Оля.** Да, это 99 и 9 десятых процента любого процесса разработки. Здесь это называется наихудшим способом оценки проектов. Ну да, да. Все так, к сожалению. Но чем вам поможет это статья? Даже если вы не идете от пользовательских сценариев при создании при создании своего проекта, вы можете к ним перейти на самом деле в любой момент. Вот вы как разработчик получаете задачу и если вы подумаете, что пользователь хочет увидеть при реализации этой задачи, вам сразу же будет проще оценить сколько времени у вас уйдет на реализацию того, другого, третьего, потому что вот вы получаете дизайн — это картинка. И вы зачастую говорите, мол, я сейчас сверстаю это все, например, большую форму какую-нибудь, а потом оказывается, что календарь должен был кликаться вот так вот, здесь должен быть вообще копипаст. Если вы сразу подумаете как пользователь на интерфейс, то вы более адекватно сможете оценить время на разработку этой задачи. И в этой статье очень доступно описано как подходить к этому вопросу. Так что, я всем рекомендую не пугаться страшных слов и прочитать её.

**Лёша.** Я предлагаю немного поговорить в целом про оценку. И мне вот интересно, Оля, как у вас сейчас устроено в компании, если ты можешь об этом говорить, потому что ты — практик прямо сейчас и мне интересно, как вы оцениваете ваши проекты.

**Оля.** Ну, как везде: надо вчера!

**Лёша.** Это понятно, но более удивительный случай, когда клиент приходит и говорит: я все понимаю, процесс долгий, давайте поговорим не только с сейлзом, a сразу же со всеми: дизайнером, проект-менеджером и разработчиками и вместе оценим проект. Давай допустим, что такой невероятный клиент пришел.

**Оля.** Ну у нас немного другая ситуация: у нас нет клиентов, а только собственные продукты, и их заказывает менеджмент. Они думают что улучшить в этих продуктах или как создать новые, которые будут лучше продаваться. Да, конечно, задаются какие-то вопросы: какой эстимейт? Лично я, как разработчик, привыкла оценивать задачу всесторонне, смотреть на нее как пользователь и задавать какие-то вопросы по макетам, если что-то непонятно, как должно работать. Но иногда хочется на все это забить и сверстать статику и потом уже допиливать все в процессе. Я обычно могу дать достаточно адекватную оценку времени разработки.

**Лёша.** То есть ты уже просто основываешься на своем большом опыте, поэтому ты легко можешь предположить сколько это у тебя займет времени, да?

**Оля.** Да, но иногда бывают такие задачи, когда я не знаю какой-нибудь технологии и я честно говорю: блин, чуваки, я не знаю, мне надо тут вот почитать, тут вот поучить, но примерно это займет у меня столько-то времени. Опыт такое дело, что уже можно даже примерно давать какие-то оценки.

**Лёша.** А вы при этом работаете по каким-нибудь Agile, Scrum или у вас обычная водопадная модель? Мы сейчас такие, про менеджерские штуки говорим. Водопадная модель — сколько задач упало, столько сделали; когда сделали — тогда сделали.

**Оля.** Я не знаю, как другие команды и другие разработчики, может у них есть какие-то Scrum, потому что я прихожу в офис и вижу, что доска исписана какими-то сложными штуками. А у меня нету, вот мне сколько упало, столько я и делаю.

**Лёша.** Я тогда расскажу немножко о своем опыте. Я когда-то давно работал в агентстве, веб-студии, она меняла свое предназначение в течении времени. И я там был одним из людей, которые когда-то пытались ввести все эти гибкие методологии внутри небольшой веб-студии. Я вам скажу, что если брать методологию целиком, например Agile или Scrum, вот полностью, то это очень плохо работает в маленьких компаниях, которые делают проекты на потоке. Вот прям совсем плохо работает, поэтому мы просто выкинули большую часть, оставили какие-то маленькие элементы, которые нам понравились, например те же самые пользовательские сценарии про которые говорит статья. Вообще пользовательские сценарии это и правда хороший момент для оценки проекта в самом начале, потому что с помощью них можно сфокусировать клиента посмотреть на проект под другим углом, со стороны пользователей, как они будут пользоваться этим сайтом. И вот когда у вас получается поменять угол, то работать дальше значительно проще, но при этом это тоже иногда вносит свои нюансы, потому что когда мы описываем проект пользовательскими сценариями, когда мы ими заменяем техническое задание, а чаще всего так и бывает. Если есть пользовательские сценарии, то на техническое задание забивают, потому что зачем. И когда это отдается в разработку, то включается такой бюрократический момент: ну вот я буду делать то, что написано у меня в пользовательских сценариях и если вы в начале что-то не подумали или как-то описали не очень подробно и не совсем понятно, как это фича должна все-таки внутри работать, какие у нее нюансы. То это все включало огромный бюрократический момент, когда отсылали друг друга туда-сюда. Знаете, обычная такая работа в веб-студии, когда все друг друга ненавидят и все считают, что они правы. Вот такой вот у нас опыт был, я не знаю чем это закончилось, я уже там не работаю. Но у нас в Академии мы используем одну единственную вещь из всех этих гибких методологий. Мы встречаемся в понедельник все вместе, при этом работать можно в течении всего времени в разных местах, а вживую мы встречаемся всего один раз в понедельник все вместе, встаем в кружок и рассказываем что каждый из нас сделал на прошлой недели и что будет делать на следуюущей. Таким образом мы во-первых синхронизируемся, знаем кто что делает, а во-вторых мне кажется правильный способ, когда ты сам рассказываешь, что ты собираешься сделать и о своем дедлайне, и произносишь это всем своим коллегам на том же самом уровне, то есть ты им обещаешь, что ты это сделаешь. И конечно же потом, когда ты, например, этого не делаешь, то тебе уже не нужно объяснять, почему это плохо, ты сам понимаешь, что это плохо. Это такой саморазвивающийся механизм в моем понимании. А у вас бывают вот такие встречи, вы как-то синхронизируетесь в своих компаниях. Я понимаю, Оля, ты работаешь внутри продуктовой компании, которая делает свой продукт, и возможно тебе не нужно знать про все остальное. Вадим, у тебя, вас же не очень большая команда людей, которая занимается DevRel, и вам же нужно периодически синхронизироваться. Как вы это делаете?

**Вадим.** У нас очень разные друг от друга задачи. У каждого свой регион ответственности, своя большая доля self-management в собственной работе, но мы синхронизируемся конечно. Мы несколько раз в год съезжаемся, еще особенность, что мы удаленно работаем все. У нас есть Slack чат в котором мы регулярно каждый день общаемся, мы можем сразу коллегу дернуть и видно сразу онлайн или офлайн он. Мы стараемся держаться ближе друг к другу и раз в неделю мы синхронизируемся во время звонка, то есть часа полтора болтаем: как дела, планируем что будем делать в ближайшее время. Ну как-то так. Еще пишем, что сделали на прошлой неделе, что будем делать на следующей, но это не обязаловка, а так, в расслабленном виде. В принципе, серьезное планирование мы делаем, когда съезжаемся несколько раз в год, мы планируем месяцы, даты, релизы, дела, и что мы будем с ними делать как команда. Ничего специального, дедлайнов или еще чего-то нет, но это видимо особенности не продуктовой разработки и не разработки как таковой, а вот именно таких задач, более широкого плана.

**Оля.** На самом деле у меня есть еще два слова про ненависть к друг другу и попытки сбросить друг на друга какие-то непонятные места. Это действительно характерно и это вот такое разработческое упрямство, которое на мой вкус надо преодолевать в себе и просто помнить, что вы делаете вместе какой-то продукт и вам вообще должно нравиться, то что вы делаете. У нас вот очень классно сделано, что мы как разработчики можем выдвигать какие-то свои идеи по улучшению проекта или инициировать какие-то доработки, не все идет сверху, а иногда снизу от нас и очень классно, что мы можем влиять на процесс, что не только сидит какой-то дизайнер и такой решает вообще все, нет, у нас тоже есть право голоса. Но если бы мы были упрямыми или ленивыми, то мы не смогли бы так работать. Надо какую-то инициативу проявлять тоже.

**Лёша.** Я вот думаю это очень крутое качество у разработчиков, если бы оно прям у всех было или хотя бы у большинства, вот эта инициативность или старание влиять на проект. Потому что чаще всего это не так: ты разработчик, сидишь перед своим монитором и закрылся от всех, ни с кем не хочешь общаться и весь такой интроверт, смотришь только в свои чатики и хочешь получать деньги и ни о чем не заботиться — вот это частый пример. И вот про тот, который ты рассказала пример, я бы очень хотел, чтобы все такими были. Мне кажется, что когда налажена хорошая коммуникация между разными специалистами: дизайнер, менеджер(да, менеджер тоже специалист, хоть вы в это и не верите, но тем не менее). Вот если бы она была налажена, то делались бы очень крутые продукты, проекты и всем было бы хорошего от этого.

**Оля.** Я честно сейчас признаюсь, что я много лет работала вот так вот, как интроверт, за своим монитором, не хотела ни в чем участвовать, но когда я пришла в эту команду и посмотрела, как ребята с энтузиазмом участвуют и я была мотивирована тоже участвовать руководством. Потому что руководство сказало, что у меня есть какое-то право голоса. И я поняла, что это классно. Да, это отнимает силы, которых у нас зачастую немного, потому что дедлайны и все такое, но это прикольно и вообще к этому надо стремиться. Как человек, который к этому устремился, стараюсь по-крайней мере это делать, могу посоветовать.

**Лёша.** Вадим, я думаю, тебе пора выводить нас из этой темы, потому что мы с Олей можем долго общаться.

**Вадим.** Да-да, этот product management, и все такое, уже как-то грустновато. Давайте дальше двигаться к технологиям, к тому, что мы все так любим.

## Определение тормозов на лету

**Вадим.** Питер-Пол Кох на неделе все пугал нас, что он придумает способ, как с помощью request animation frame налету определять быстродействие и каким-то образом модифицировать поведение приложение в зависимости от него. И в итоге выложил методику [RAFP](http://www.quirksmode.org/blog/archives/2016/03/rafp_a_proposal.html), не очень благозвучное название, и предложил скрипт, который анализирует налету как приложение работает, насколько у него средний animationframe медленный или быстрый,и в итоге на основе полученной информации включать или выключать фичи. Ну вот смотрите: когда у нас сайт начинает тормозить, как мы можем это определить? Да особо никак, можем только потестировать его в известных нам условиях и предположить, что он не тормозит, какой-нибудь Google PageSpeed, мобилки потестировать, но мы всегда можем упустить много всего интересного, потому что мы не можем потестировать на всех устройствах, мы не можем проверить все условия: вытащили зарядник из ноутбука и он начал работать медленнее или у вас Chrome начал утекать и утекая съел весь процессор, оперативку и так далее. Было бы круто, если бы мы могли это динамически делать. Собственно вот Питер-Пол Кох предложил этот скрипт и по-моему даже, если этот скрипт не работает, в комментариях у людей появились сомнения, что он покрывает все случаи, когда можно ловить проблемы с быстродействием, то все равно это довольно интересная идея, как это все можно на лету анализировать, подключать или отключать фичи. Если вы поняли, что средние значения вашего `requestAnimationFrame` плохие или любым другим способом измеряете быстродействие, то можете отключить этот чертов параллакс. Извините, это личное. Или сделать, что-нибудь еще другое. Сделать не полупрозрачный фильтр, который налету считает значения, как в macOS очень модно,полупрозрачно и красиво. А просто сделать обычную статическую прозрачность, чтобы она не ела все ресурсы CPU на эту красоту. Довольно интересная штука; новое слово в попытке сделать сайты быстрыми, динамически быстрыми.

**Лёша.** Вадим, а ты сказал, что он предложил каждому потестировать.; он написал скрипт, который можно вставить на сайт и попробовать как это работает у вас?

**Вадим.** Ну да, то есть суть в том, что нужно понять, работает эта штука или нет, а лучше всего это можно понять на реальных проектах, потому что синтетически демки конечно хорошие, но поможет ли вам определить быстродействие на ваших реальных проектах или нет — вот это было бы классно проверить. Поэтому почитайте, попробуйте и напишите Питеру, чтобы он продолжил развивать свою идею или смело похоронил. Но может быть у нас найдутся другие способы налету определять быстродействие, не сильно нагружая клиента естественно.

**Лёша.** Ну да, это интересно. Потому что вот у нас есть в инструментах разработчика всякие разные профайлеры, которые показывают, как ведет себя верстка, насколько она быстрая или медленная в разные этапы времени и вообще я сейчас подумал, что было бы круто, чтобы некое такое API браузер отдавал нам, разработчикам, чтобы мы могли в реалтайме. Сейчас requestAnimationFrame Питер использует не совсем по назначению, то есть он не для этого был придуман, а он просто взял его и из-за того, как он работает у него получилось мерить производительность, но это не прямое его назначение. Было бы круто, если был такой API, с помощью которого можно было померить насколько сейчас ты сожрал память своим сайтом или сожрал CPU и что-то отключать. Ведь есть такое API, которое не так давно появлялось и позволяло мерить разные тайминги, то есть насколько быстро загружается твой сайт, насколько быстро DOM отрисовался и так далее. То есть в эту струю его немножко расширить и добавить производительность и идея отключать элементы сайта, которые очень сильно влияют на производительность, по-моему шикарная.

## Селекторы для системных элементов

- [Styling native components, a proposal](https://lists.w3.org/Archives/Public/www-style/2016Mar/0310.html)

**Вадим.** Давайте тогда перейдем дальше. Еще одна довольно интересная идея была на этой неделе: Лея Веру, видимо, как и многие из нас, устала от сложностей оформления контролов, нативных форм и подобных элементов, и предложила упростить синтаксис обращения ко всем вложенным элементам. То есть, когда вы пытаетесь оформить какой-нибудь скроллбар, чекбокс или кнопочка у видеоплеера и пытаетесь достучаться до внутренних элементов, то вам приходится писать какие-то адские селекторы, да еще и с префиксами, поскольку браузеры до сих пор не считают эту ситуацию стабильной и по-прежнему показывают нам какие-то вещи только через префиксы. И поскольку в селекторах префиксы приводят к тому, что браузер, не узнав свой префикс в селекторе, игнорирует все остальные части селектора и не применяет стили; приходится стили писать два-три раза подряд, в зависимости от того на сколько браузеров вы рассчитываете. Лея предложила сделать группирующий селектор, в котором описывать все фичи браузерные. Это такой маленький шажок, но он сделает CSS лучше. Похожая ситуация была и остается для старых браузеров с Keyframe Animation, когда мы описывали анимацию в директиве `@keyframe` и если мы использовали префикс, то нам приходилось снова и снова дублировать этот add-rule с нужным префиксом и в нем дублировать свойство. И тут же, когда мы написали новость о том, что Лея предлагает новую идею, прибежали ребята, которые начали говорить: «А чего? Мы сейчас напишем PostCSS-плагин или Sass-миксин и быстренько всю эту ситуацию исправим. Мы будем писать один раз, а в выходном CSS, а черт с ним, с выходным CSS.»

**Лёша.** Ты прямо хейтером сейчас выступаешь. У них все-таки была идея сделать фолбэк, то есть на время, пока что-то с этим не придумают.

## Нужны ли препроцессоры

Я с тобой согласен, что лучше заниматься спецификациями, лучше развивать CSS и все эти препроцессоры, постпроцессоры и все остальное хорошо, но ребята тратят свою энергию не совсем туда, потому что у нас же никогда не появится ни LESS, ни Sass прямо в браузере. Это всегда будет какой-то инструмент поверх. И мне вот со всеми этими инструментами, которые как-то превращают ваш код в другой код, что это какой-то временный эффект, что мы этим сейчас пользуемся, пока не пошло дальше, и на этой неделе была статья Роджера Йоханссона. Ты сказал, что он ветеран веб-стандартов, я вот его уже не помню, может я тогда маленький был.

**Вадим.** Было действительно не так много блогов интересных, даже англоязычных, в свое время, когда я только начинал заниматься версткой и изучал все это. Был блог Роджера Йоханссона [456bereastreet](http://www.456bereastreet.com/) на котором он писал довольно интересные вещи. Сейчас он пишет меньше, а все больше ворчит, но я его по-прежнему помню и люблю и он один из тех, кто считается ретроградом-ворчуном, и он говорит: хватит использовать все эти ваши штуки, ради того, чтобы использовать штуки, решайте задачи, не забывайте про чистый язык! Иногда это звучит так, как будто он отстал от времени, а иногда пишет хорошие вещи. Он — практикующий разработчик, у него есть проект и клиенты и он пишет, почему он не использует препроцессоры. Сейчас, если какой-то верстальщик выйдет и скажет, что он не использует CSS-препроцессоры, то у него спросят: ты что, дурак? Он же все упрощает, ускоряет и все такое. Но ведь когда-то у нас была мода на всякие CoffeeScript, которые тоже все упрощали и ускоряли, но сейчас если показать человеку CoffeeScript, то он скорее всего позеленеет и ему станет плохо, потому что эпоха уже прошла. И у меня есть ощущения, что когда-нибудь, надеюсь скоро, когда мы посмотрим на программирование на Sass внутри нашего CSS у нас будут точно такие же выражения лиц, как при взгляде на CoffeeScript. В общем-то Роджер делится своим опытом, он пишет живой CSS, который можно прямо сейчас использоваться в браузере, то есть вы открыли страничку и без установки node.js, без поднятия watcher и установки всех зависимостей, вы сможете свой css, который только что написали, показать в браузере. Это делает его быстрее, проще показать клиенту, не нужно поднимать все это. А препроцессоры он не использует, он использует процессоры CSS, то есть такие штуки, которые улучшают существующий CSS, но не делают его принципиально другим, то есть он пишет живой совместимый CSS. А что он делает кроме этого? Он расставляет префиксы, не трогая структуру документа, просто добавляя дополнительные строчечки, он сортирует свойства, он проверяет написание кода и по-моему что-то еще. Грубо говоря, он использует все эти процессоры для того, чтобы наводить порядок в коде, делать те задачи, которые не удобно делать руками и бессмысленно делать руками, потому что машина делает их лучше. Но он не изобретает новый язык, он не пишет на новом языке; и вот эта идея мне понравилась, мне было бы интересно написать что-то на чистом CSS, удивительно звучит, 2016 год, мне интересно что-то написать на чистом CSS. Звучит пародоксально.
Единственной вещи, которые бы мне не хватило всерьез, это пожалуй вложенных конструкций, когда мы вкладываем внутрь блока с правилами другой селектор и таким образом формируем вложенность. Вот таких вещей мне правда будет не хватать. Скажите, ребята, если у вас сегодня отобрать препроцессор на котором вы пишете, чего больше всего будет не хватать?

**Лёша.** Я буду себя чувствовать абсолютно естественно, нормально и так далее. Я еще раз повторю свою мысль, которую я несколько раз уже говорил: Я считаю, что все эти препроцессоры, все языки, которые поверх других языков бегут, они нужны только как живая демонстрация того, как может работать в будущем наш язык. Вот как было с CoffeeScript? Отличный пример. Почти все вынули из CoffeeScript и запихнули в JS — замечательно. Вот с препроцессорами абсолютно точно так же. Я знаю, что 90% людей будет ныть и говорить: да как же так, я же буду писать код в два раза медленнее, как же мой Sass, Less, мои миксины, которые я вытаскивал из бутстрапа в течении пяти лет, куда же я все это дену, как же, я же все потеряю?. Но мне кажется это абсолютно нормально, это естественный путь развития и мы должны заниматься CSS, мы должны развивать спецификацию CSS и делать, чтобы она работала лучше, хорошо в браузерах, прямо в браузерах. Поэтому я считаю, что это хорошо. И если у меня отберут Less, Sass, PostCSS и все остальное, то я не буду чувствовать себя каким-то ущербным, я смогу спокойно написать CSS код и он будет отличным, хорошо структурированный, хорошо читаемый, воспроизводимый и все такое. Препроцессоры — это круто, но можно и без них.

**Оля.** Мне, наверное, будет не хватать в первую очередь миксинов, потому что это действительно очень удобная штука, а вложенность да, но я ей редко пользуюсь потому что БЭМ. Не знаю, мне кажется, что я конечно бы не очень пострадала, но это движение к чистому CSS мне не очень понятно. Ну компилится что-то у вас, ну ладно. Какая разница?

**Лёша.** Тебе было понятно движения от jQuery к чистому JS?

**Оля.** Ты знаешь, я не очень углублялась в подробности, почему так получилось. Мне кажется, интуитивно, что дело в том, что мы подключали какие-то гигантские библиотеки, которые нам не были нужны такими гигантскими и теперь мы можем писать меньше и подключать меньше. В чем там была еще идея я не очень знаю.

**Лёша.** Ну идея была очень простая — всё, что умел jQuery, начало хорошо работать в браузерах. Вот, главная мысль. Конечно, баги, кроссбраузерность — это все осталось за jQuery, но все те удобные фичи, типа путешествие по DOM, поиск элементов, AJAX и все остальное, оно стало очень простым внутри браузеров, поэтому смысла от библиотеки стало не так много.

**Оля.** Ну да, я поняла твою мысль. Но пока что CSS не дает нам всех этих возможностей.

**Лёша.** Поэтому я и говорю, что надо развиваться развитием спецификации. Нужно, я не могу, но может Вадим может, помочь Табу Аткинсу пропихнуть свою спецификацию про нестинг элементов в CSS. Переменные у нас уже есть, вычисления с помощью `calc` у нас уже есть, спека для цветовых функций у нас уже есть. Что нам еще не хватает? Миксинов, да? Вот про миксины я не слышал, что есть такая спецификация.

## Что появится в ES2016

**Вадим.** Спецификация CSS хоть и развивается, но не семимильными шагами. Самое смелое что у нас было за последнее время это CSS-переменные, которые кастомные свойства, это совсем что-то новое, синтаксис и вообще. Самый большой интерес происходил с ECMAScript 6 или ECMAScript 2015, там было просто море фич и вот недавно на Frontender Magazine опубликовали заметку Акселя Роушмайра с [полным списком того, что появится в ECMAScript 2016](http://frontender.info/ecmascript-2016/), и это конечно поразило всех.

**Лёша.** Да, я этот список читал где-то пару недель, потому что реально очень объемный список и нужно воспринять все данные и как бы очень тяжело.

**Вадим.** Ладно, мы, конечно, издеваемся. Список всего из двух пунктов и это действительно шокировало людей, потому что они думали: у нас 100500 фич в ECMAScript 6, а в ECMAScript 7 будет еще больше и мы снова будем все такие на Babel. Но тут какая ситуация, между ECMAScript5 и ECMAScript 2015, раз уж мы перешли на новую модель, то давайте так называть, прошло огромное время в которое ничего не происходило. И вот то, чего нам не хватало оно все вошло в ECMAScript 2015, а дальше мы все это реализовали почти, все больше и больше появляется, в Safari 98% и в конкурирующих браузерах почти столько же, они на процент-два различаются в ночных и стабильных версиях. А что у нас будет в 2016? У нас нет так много идей на следующий пакет из 100500 фич, у нас есть парочка идей, которые не вошли в текущий стек, а войдут в следующий, потому что не успели. Идея такая, что мы раз в год будем определять какие фичи у нас будут в спецификации новые и браузер будет успевать их реализовывать. Нам не придется снова и снова транспилировать все это в старый ECMAScript. Здесь тоже в общем-то вырисовывается тенденция, что мы откажемся от всех этих транспайлеров и Babel, и будем писать живой JavaScript для живых браузеров и он будет просто сразу работать. И у нас не будет огромного пакета фич. Вот, Лёша, ты как думаешь, эти фичи полезна или нам нужно добавить еще столько же, как было раньше?

**Лёша.** Ты про то, что в ES2016 добавили метод `include` для массивов и оператор возведения в степень? Да, это конечно полезно. Любое расширение языка кому-то да полезно или тебе может через проект, через два понадобится. В любом случае, это хорошо. Я бы хотел еще сказать, что, когда они поменяли свой релизный цикл, они ввели еще такую штуку: 4 стадии у каждой фичи, от 0 до 4. И если фича переходит в 4 стадию, то это значит, что она может быть включена в следующий релиз, то есть 2016, 2017 или 2018. И большинство фич осталось на 3 стадии, потому что там что-то еще до конца нехорошо, надо API подкрутить, нужно еще о чем-то подумать, что-то проверить. И тут вышел небольшой конфузик, эта проблема перехода от ES6-ES7 к ES2015-ES2016 в головах такую неразбериху затеяла, потому что все в голове ассоциировали ES6 с ES2015, вот прям равенство, и по факту так и получилось, это и было практически равенством, а все, что мы говорили будет в ES7 и так мечтательно думали: `async-await` — круто, ждем!, и все ассоциировали это с ES7 и автоматически мы перенесли эту идею на то, что ES7 значит ES2016, значит все эти фичи появятся в этом году. И тут произошел крах этой идеи, потому что огромное количество статей говорит о том, что это появится в ES7, а ES7 как такого не существует. Все, забудьте, его нет, нет такого понятия ES7. Есть спецификация ECMAScript, есть релизные названия ES2015, ES2016, ES2017. Все, ничего другого нет. И когда вы видите статью о том, что у нас появится в ES7, то не верьте ей, это не совсем так и это скорее всего не появится. То есть `async-await` не появится в этом году, ждем следующего. И с одной стороны это конечно хорошо: наконец-то у нас каждый год релизится что-то. Это вообще прекрасно. Я помню, как приходилось ждать десятилетия, чтобы в JavaScript что-то изменилось, а тут вот у нас каждый год все эти зеленые браузеры получают новые фичи. Крутотень!

## Новости про новости

**Вадим.** На этом мы заканчиваем выпуск. И хотелось бы еще немножко поговорить про наши соц.сети, новости и так далее. На самом деле, этот подкаст родился на основе наших новостей, потому что раз уж мы пишем много чего, каждый день много новостей, мы решили на основе него сделать подкаст и рассказывать вам новости голосами и обсуждать. Так вот на минувшей неделе мы [завели Телеграм](https://telegram.me/webstandards_ru) и если кто-то из вас пользуется, то будет вам удобно читать вам Телеграм, если там у вас Твиттер, Вконтач или Фейсбук почему-то кажется для этого неудобным. Завели еще сами не знаем зачем, Павла Дурова, наверное, порадовать. Еще из новостей про новости. Мы думаем [отказаться от трансляции наших новостей в Google+](https://plus.google.com/+Web-standardsRu/posts), потому что, ну как сказать, там никого нет. А мы делаем все эти штуки автоматически, постим все везде, единым потоком, а вот с [Google+](https://plus.google.com/+Web-standardsRu/posts) такой трюк не пройдет и приходится руками постить все эти картинки и посты. И мы это делали в течении года, даже больше. И наверное надо перестать, потому что там нас мало читают. Выскажитесь, если мы вдруг не понимаем, что там у нас огромная аудитория и вам страшно неудобно будет, если мы уйдем с Google+, в комментариях где-нибудь в соцсетях в других.

**Лёша.** В Google+ хе-хе.

**Вадим.** Попробуйте убедить нас не уходить оттуда, но пока вот мы уверены, что время тратить на это не стоит. В общем, на этом все. С вами был 10-й выпуск подкаста «Веб-стандарты» и его постоянные ведущие: Алексей Симоненко из HTML Академии, Ольга Алексашенко, верстальщик руками, из Exante.

**Оля.** …и Вадим Макеев из Оперы.

**Вадим.** Услышимся на следующей неделе уже на DUMP в Екатеринбурге. Счастливо!

**Оля.** До встречи!

**Лёша.** Пока.
