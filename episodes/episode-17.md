# Выпуск №17. 23 мая 2016

Семантика и БЭМ, CSS для новичков, клиенты для Git, JS-модули в Edge, Google I/O.

- Ольга Алексашенко
- Вадим Макеев
- Алексей Симоненко

[Слушайте на SoundCloud](https://soundcloud.com/web-standards/episode-17), [обсуждайте в Слаке](https://web-standards.slack.com/messages/podcast/).

## 00:13 События

- [PiterCSS №4 24 мая](https://pitercss.timepad.ru/event/331983/)
- [WSD в Екатеринбурге 25 июня](https://wsd.events/2016/06/25/)
- [Frontend Union Conf](http://frontend-union.co/)
- [HolyJS 5 июня](http://holyjs.ru/)

## 04:01 Семантика и БЭМ

- [Осмысленный CSS: описывайте стилями свою логику](http://css-live.ru/articles/osmyslennyj-css-opisyvajte-stilyami-svoyu-logiku.html)
- [Бэмантика: пишите осмысленные стили без повторов](http://css-live.ru/articles/bemantika-pishite-osmyslennye-stili-bez-povtorov.html)
- [More Meaningful CSS](http://snook.ca/archives/html_and_css/more-meaningful-css)
- [Семантика или смерть](https://events.yandex.ru/lib/talks/1520/)
- [MIND, библиотека доступных элементов интерфейса eBay](http://ianmcburnie.github.io/mindpatterns/)

## 29:40 CSS для новичков

- [Магия CSS](https://webref.ru/layout/magic-of-css)
- [Отладка CSS](https://benfrain.com/debugging-css/)

## 32:09 Контроль версий и клиенты

- [GitKraken](https://www.gitkraken.com/)
- [Tower](https://www.git-tower.com/)
- [GitHub Desktop](https://desktop.github.com/)
- [GitBox](http://gitboxapp.com/)
- [GitUp](http://gitup.co/)
- [Термины Гита и Гитхаба](https://github.com/web-standards-ru/dictionary/issues/234)

## 45:51 JS-модули в Edge!

- [Previewing ES6 Modules and more from ES2015, ES2016 and beyond](https://blogs.windows.com/msedgedev/2016/05/17/es6-modules-and-beyond/)
- [ES-модули в Firefox](https://twitter.com/jlongster/status/732645925978550272)

## 51:42 Google I/O

- [Страница события](https://events.google.com/io2016/)
- [Веб и Chrome на Google I/O](https://www.youtube.com/playlist?list=PLNYkxOF6rcIDz1TzmmMRBC-kd8zPRTQIP)
- [Autofill: What web devs should know, but don’t](http://blog.cloudfour.com/autofill-what-web-devs-should-know-but-dont/)
- [Progressive Web Apps](https://developers.google.com/web/progressive-web-apps/)
- [Accelerated Mobile Pages](https://www.ampproject.org/)
- [Комикс xkcd](https://xkcd.com/1367/)

--------------------------------------------------------------------------------

**Лёша.**
Привет, с вами 17-й выпуск подкаста «Веб-стандарты» и его постоянные ведущие Вадим Макеев из [«Opera»](http://www.opera.com/), Ольга Алексашенко — верстальщик руками из [Exante](https://exante.eu/)…

**Оля.**
И Алексей Симоненко из [HTML Академии](https://htmlacademy.ru/).

## 00:13 События

**Вадим.**
И мы снова будем говорить вначале про события, всем надоело, но, чёрт побери, надо встречаться. PiterCSS №4 пройдёт уже во вторник, 24 мая, поэтому если вы из Питера или надумали приехать — у нас тут, в общем-то, лето и всё хорошо — регистрируйтесь, места, я думаю, закончатся в понедельник. Там будут доклады про SVG, про AMP — технологию как возвращать страницы в изначальность, которую придумал Google, чтобы страницы загружались быстро — какая-то такая странная штука, и немножко про вёрстку писем — поплачем всем залом. Мы сейчас раздумываем, проводить ли PiterCSS в июне, потому что в июне будет уже WSD в Екатеринбурге, хотя уже есть два заявленных доклада — так что, вот, думаем. Но, может быть, сделаем, если будет свободное время. Вы что думаете, ребята, вообще летом конференции имеют право быть?

**Лёша.**
Мне кажется, что летом достаточно сложно собирать конференции, именно в середину лета, потому что в принципе июнь и август это ещё более менее, а вот июль, мне кажется, это совсем не надо.

**Оля.**
Я согласна с Лёшей, примерно такая раскладка по месяцам. В июне, как правило, ещё никто в отпуск не уходит, потому что холодно, у всех ещё дети учатся и всё в таком духе, хотя какие дети у нашей аудитории? Ну вот, мне кажется, в июне ещё можно, а в июле и августе уже, наверное, бессмысленно.

**Вадим.**
В общем, мы делаем WSD 25 июня, так что если мы где-нибудь в середине сделаем PiterCSS… Ну, посмотрим.

**Лёша.**
Если у тебя уже есть желающие что-то рассказать, то площадку-то мы уж найдём, может быть, и не останавливаться.

**Вадим.**
Ну да, кто я такой, чтобы мешать людям докладывать?

**Лёша.**
Конечно.

**Вадим.**
Вот. В начале июня я всё ещё надеюсь съездить на ScotlandJS и ScotlandCSS, сейчас в волнении жду визу — и вы тоже волнуйтесь, потому что я ведь могу и текстовую трансляцию оттуда сделать, поэтому давайте волноваться вместе, чтобы всё получилось. Вот. В общем-то, WSD в Екатеринбурге, как я и обещал, 25-го июня, мы уже опубликовали полпрограммы, там 5 докладов уже есть, а я там расскажу свой доклад, за который ко мне периодически приходят люди и говорят: «А видео есть?». Я — «Есть, но оно паршивое». Я, наверное, подниму свой старый доклад про кнопки и ссылки — «Жми сюда» называется — в котором я рассказываю, что делать с интерактивными элементами: что делать кнопками, что делать ссылками, что делать псевдоссылками, как всё это делать доступным, как правильно добавить CSS, чтобы всё это можно было делать с клавиатуры навигацию, в общем, что-то про доступность но с хорошей долей практики. А ещё я в календарь на лето планирую отпуск, и понял, что 27-го августа Frontend Union в Вильнюсе — такая конференция, объединяющая разные митапы, она прошла в Москве в августе прошлого года, там были англоязычные доклады, русскоязычные. В общем, надо спросить у ребят, будет ли она, потому что про неё в последнее время не было новостей, но обязательно добавьте в календарь — Вильнюс, 27-е августа, Frontend Union Conf. По крайней мере, что ребята хорошие и они соберут хорошую программу, я могу поручиться точно.

**Лёша.**
И ты, конечно же, забыл про HolyJS? Ведь HolyJS совсем уже скоро будет, буквально через две недели, программа уже готова: три потока и 22 доклада — будет что-то большое.

**Вадим.**
Да, я собирался выступить с докладом на HolyJS, но нормальную JS-тему пока не подготовил, может быть, осенью что-нибудь придумаю, была у меня одна идея. Наверное, просто напрошусь в гости — придти, посмотреть, как это всё работает, и можно ли сделать коммерческую конференцию в России, так что увидимся 5-го июня.

## 04:01 Семантика и БЭМ

**Вадим.**
Большой темой на этой неделе была семантика и БЭМ, или БЭМантика, как новый термин всплыл. Смотрите, в чём дело: Тим Бакстер на [A List Apart](http://alistapart.com/) — таком старинном уважаемом сайте, на котором я учился веб-технологиям, читал Джеффри Зельдмана и Эрика Мейера — опубликовал статью. Её ребята из [CSS-Live](http://css-live.ru/) быстренько перевели на русский, и получилась статья [Осмысленный CSS: описывайте стилями свою логику](http://css-live.ru/articles/osmyslennyj-css-opisyvajte-stilyami-svoyu-logiku.html). В чём суть? Тим Бакстер говорит, что в спецификации чётко написано — хорош использовать классы, слишком много вот этой «классянки». Джеффри Зельдман в своём классическом труде (откуда, собственно, пошёл термин веб-стандарты) пишет, что классов нельзя использовать слишком много, потому что это вредит и семантике, и логике, и всему на свете, и он говорит, что можно просто обращаться к элементам по именам элементов, приделывая к ним атрибуты. Допустим, у вас есть шапка на странице — элемент `<header>` из HTML 5. Вы берёте, и употребляете этот элемент `<header>` у вас прямо в стилях, потому что он единственный на странице. Но он ведь может использоваться где-то ещё — вы берёте, добавляете к нему атрибут `role="banner"` — он точно должен быть один на странице — и у вас получается `<header>` выборка по атрибуту `role="banner"`, и у вас такой уникальный элемент шапка. В чём проблема с этим подходом? Об этом говорят в дальнейших статьях, но я хочу поговорить немножко о другом в самом начале: вообще, почему Тим Бакстер написал об этом? Смотрите, у нас, действительно, есть спецификации и у нас есть рекомендованные подходы, которые идут от логики, от того, как документации и стандарты по языку HTML и CSS были когда-то написаны. Потом это всё применилось к жизни и стало практиковаться разработчиками, и пришёл большой опыт применения всего этого в реальной жизни. И мы получили немножко другие подходы, которые сейчас в среднем формулируются как БЭМ, то есть Блок-Элемент-Модификатор. Когда мы ушли от сложной специфичности, когда мы ушли от сложных вариантов именования, когда мы ушли от всяких каскадов, айдишников и прочих элементов, которые всё немножко усложняют, и пришли к более стройной и понятной системе именования и использования Блоков-Элементов-Модификаторов, как вы это ни называете: SMACSS, Object-oriented CSS, неважно. И вот сейчас столкнулись — в статьях, которые вышли на этой неделе — два мира: мир теории и мир практики. Один из самых хороших ответов на эту тему был ответ Мэтта Стоу про БЭМантику — собственно, он этот термин вырулил, и, мне кажется, довольно забавное получилось слово, то есть и БЭМ, и семантика в одном слове, хотя, казалось бы, вещи противоречащие. А он говорит: нет, я использую как и БЭМ, для того, чтобы именовать элементы, так и семантические элементы, так и ARIA-атрибуты, которые очень здорово описывают, что на странице происходит. И, на мой взгляд, подход Мэтта — это как раз то, что должны практиковать современные разработчики: знать теорию и хорошо применять это на практике, и в итоге, получается, и волки сыты, и овцы целы. Ребята, а вы видите какое-нибудь рациональное зерно в том, что написал Тим Бакстер, или это для вас звучит как брюзжание какого-то пенсионера?

**Лёша.**
Мне кажется, что у него идея-то хорошая, просто, ты прав, он от практики очень далёк. И на больших сайтах это вообще невозможно, чтобы у тебя все элементы выглядели одинаково, ведь есть такая штука, как редизайн, ещё что-то, то есть это в принципе невозможно. Но с другой стороны он очень много говорил про ARIA-атрибуты, про которые, наверное, среднестатистический разработчик никогда и не слышал. И в этом смысле, конечно, его статья полезна. Понятное дело, что она немножко «кривая» в этом смысле, потому что он мало рассказывал, зачем это и почему, ведь про доступность какая главная проблема, или про семантику. Да нет, давай про семантику. Вот ты, как человек, понимающий, что семантика — это хорошо, скажи мне… Ну давай представим, что я ничего в этом не понимаю. Нафига мне нужна семантика, зачем мне на это тратить время?

**Вадим.**
Семантика — это универсальный язык, о котором мы все договорились. Когда я тебе говорю: «Лёша, привет!», ты слышишь своё имя и приветственное слово. Когда мы читаем в исходнике страницы — кто-либо, один из многих вообще возможных вариантов агентов, которые читают HTML, который прислал ваш сервер — он читает, он видит элемент `<header>`, он видит элемент `<main>`, он видит элемент `<footer>` и он может понять, что в каждом элементе содержится. Если он читает названия классов, которые ещё наверняка и зашифрованы какими-нибудь CSS-Modules, он не может понять, что там находится, он не может интерпретировать более широко и более правильно. Ему приходится включать всякие морфологические разборы, чтобы попытаться понять: где заголовок сайта, где основной текст, где ещё что-то. А ведь такие вещи пока ещё не надёжны. Поэтому мы договорились о метаязыке, описали его в спецификации, и у нас, у разработчиков, есть общий язык. Ты читаешь исходник сайта глазами, ты понимаешь, что-где, не опираясь на имена классов, а именно глядя на HTML-структуру. Робот читает, понимает, что-где, читалка экранная пропускает какой-нибудь элемент `<header>` прямо в `<body>` первый, потому что он уже прочитал его на главной странице, и он может его пропустить, они, по крайней мере, могут это сделать, теоретически.

**Лёша.**
Ты говоришь, что это метаязык, чтобы кто-то понимал твой код, но мне кажется, что среднему сайту, среднему разработчику абсолютно не нужно, чтобы кто-то понимал его код, он ведь решает задачу, решает задачу какого-то клиента, чтобы его сайт работал, а не чтобы код был красивым. И опять же, я сейчас со стороны вот этой, я выключил из своей головы все знания про семантику и доступность и сейчас говорю без них, чтобы получилась дискуссия. Не очень понятно, нафига — ты привёл очень хороший пример про язык, ты говоришь мне: «Привет, Лёша!», и мы понимаем, что это значит. Ты мог бы сказать «Hey, Лёша!», или вообще всё что угодно, то есть, ты мог произнести любое слово — и мы бы тебя поняли. И точно так же с браузерами, с роботами. Да, у нас есть история про то, что нужно определять как-то семантически верно нашу разметку, чтобы браузер понимал где-что, или чтобы робот понимал, где-что. Но ведь робот справляется и без этих знаний, хорошо справляется, очень долгое время справляется. Поисковые роботы умеют находить нужный контент в ужасном коде, там наверняка все assisted technolody научились понимать, какой контент важный, а какой — нет. Почему так произошло? Потому что никто специально… Нет идеальной вёрстки, нет идеального инструмента, в рамках которого мы бы могли договориться: да, мы будем проверять только так и будем давать результат этого всем нашим пользователям. Но, так как договориться об этом не получается, хотя есть стандарты и так далее, все технологии понимают, что нужно смотреть шире, гибче. И из-за этого, в том числе из-за этого, получается так, что все технологии нам дают такую широту, поэтому непонятно, зачем мне тогда поддерживать семантику, если все эти инструменты и так могут работать.

**Оля.**
Ну, на самом деле-то, вот это вот всё, ну, отсутствие жёстких конвенций, оно приводит к тому, что каждый браузер ваяет что он хочет и в результате у нас есть проблема кроссбраузерности, ну, то есть, всё это отсутствие стандартов приводило к большим проблемам, поэтому сведение наших технологий к каким-то конвенциям упростит жизнь всем — во внедрении и в реализации.

**Лёша.**
Возможно, возможно, но посмотри на любой сайт который состоит из одних дивов и одних классов.

**Оля.**
Я сама делаю такие сайты, к сожалению, и у меня тоже вот встал вот этот вопрос. На самом деле, эта статья хороша тем, что она нас немножко возвращает к истокам и напоминает, что разметку надо бы делать семантичной, и это хорошо.

**Вадим.**
На мой взгляд, эта статья как раз не просто возвращает нас к истокам, а берёт и тыкает носом, причём больно, неприятно и немножко грубо. И когда тебя грубо тыкают носом куда-то, ты такой: «Эй, старичок, ты вообще из другого века, с тебя давно песок сыпется, поэтому иди-ка к чёрту, я тут лучше знаю, как мне что-то сделать лучше.». Вот это проблема, вот это плохой пропагандист. Пропагандист, который оторван от практики — этот персонаж, Тим Бакстер… Я плохо знаю, кто он, на самом деле. Возможно, он практикует что-то, но я почему-то сомневаюсь, что прям вот он работает с большими, даже средними или, по крайней мере, поточными проектами. И поэтому, когда ты читаешь его аргументы, ты думаешь: «какая-то чушь.», и ты не хочешь вдумываться: семантика, ARIA, ещё что-то такое, ты просто чувствуешь, что он не понимает сложностей и задач твоей работы. Мэтт Стоу, который ответил ему — понимает. Джон Снук, который в [«Shopify»](https://www.shopify.com/) работал какое-то время, сейчас, по-моему, ушёл и фрилансит; который написал про [More Meaningful CSS](https://snook.ca/archives/html_and_css/more-meaningful-css) — тоже пытается объяснить, откуда всё это взялось, вся эта «классянка», тоже понимает практику. Тим Бакстер — не очень, поэтому те здравые идеи, которые звучат у него, мне кажется, никто всерьёз не воспринял. Действительно, поднялась волна комментариев, что чувак написал полную ерунду, хотя он написал не ерунду, он написал правильные вещи, но не в той плоскости, не в практической плоскости, а в теоретической. И там действительно очень много ошибок и упущенных мест, которые стоило бы восполнить.

**Оля.**
На самом деле цель-то достигнута: волна-то поднялась мы немножко задумались, и, может быть, всё это была такая хитрая провокация? Хотя, конечно, не факт. У каждого подхода есть свои плюсы и минусы, и утверждать, что одно идеально хорошо, а другое — абсолютно плохо тоже нельзя. Поэтому хорошо, что дискуссия поднялась, тут опять есть о чём подумать.

**Вадим.**
Я хочу ответить на Лёшину провокацию про «кому нужна семантика если роботы и так разбираются». Я частенько сталкиваюсь с тем, что я захожу в какой-нибудь Google, ищу что-нибудь и вижу заголовок сайта… Откуда он, кстати, взялся? Наверное, из `<title>` или `<h1>`, то есть какие-то теги разработчики выучили, молодцы. А потом, сразу под заголовком сайта идёт сниппет. И в сниппете написано типа: «Нажмите на эту кнопку, чтобы закрыть диалоговое окно» — пишет мне в сниппете самый важный текст на сайте поисковик. Я регулярно сталкиваюсь с тем, что поисковик выбирает неправильный сниппет для того, чтобы описать сайт. Он выбирает его из какого-нибудь `<div>`, у которого есть класс, не знаю, `content`, или какая у него там эвристика. Но я регулярно вижу, что они ошибаются. А если бы он взял внутри `<header>` какой-нибудь параграф, который следует сразу за `<h1>`, что-нибудь такое; или как-нибудь что-нибудь другое вытащил из значимых элементов — он бы со сниппетом не ошибся. Возможно, сниппет нужно засовывать в `<meta name="description">` и так далее, это уже вопрос к сеошникам, но суть следующая: поисковики частенько ошибаются, вот в чём дело. Практики, которые рекомендованы в спеках, они действительно внедрены в браузерах, Оля правильно сказала, веб-стандарты помогли нам добиться лучшей кроссбраузерности, и эта ситуация улучшается с каждым днём. Но мы всё ещё очень далеко, потому что средний разработчик браузера и средний разработчик веб-страницы — это очень разные люди, и первым важно читать спецификацию, чтобы соответствовать другим браузерам, вторым важно быстренько «тяп-ляп и в продакшен». Кто-то пожёстче говорит. По-моему, вторым — собственно, верстальщикам — не хватает знания спецификаций. В отсутствии этих знаний, в отсутствии доступных спецификаций — я не обвиняю только разработчиков, я обвиняю ещё людей, которые пишут спецификации, я обвиняю нас с вами, ребята, которые сами не читают спецификации, читают их мало, мало о них рассказывают — видимо, об этом нужно больше говорить Если кто-то из вас (или из нас, по крайней мере, точно я) считает семантику, вот эти идеи важными — о них нужно больше говорить. Собственно, вот я не то, чтобы «на волне», но, видимо, предчувствовал, и, собственно, на WSD в Екатеринбурге хочу рассказать, чем кнопка отличается от ссылки — это тоже, в общем-то, про веб-стандарты и про то, как их немножко помирить с практикой.

**Лёша.**
Тебе не кажется, что этого всё-таки недостаточно, потому что доклады про семантику, они происходят периодически, пишут статьи про семантику периодически — например, был шикарный доклад [Семантика или смерть](https://events.yandex.ru/lib/talks/1520/), как раз на одном из WSD.

**Вадим.**
Да, Наташа Арефьева рассказывала.

**Лёша.**
Вот, и его даже до сих пор дают ссылку на это видео, посмотрите обязательно его, чтобы понять, почему это важно. Но, тем не менее, у нас в вебе громадное количество сайтов, которым на семантику наплевать, и выходят новые сайты, которым на семантику наплевать. Любой новый инструмент или фреймворк, который выпускается — ему на семантику наплевать. Почему так происходит, если это так важно?

**Вадим.**
Кто делает фреймворки? Фреймворки делают люди, которые решают задачу, им нужно в браузере нарисовать картинку. Не сделать сайт удобным, доступным, быстро работающим, а нарисовать картинку. Так что фреймворк или библиотека — это абстракции, которые позволяют сделать какой-то скелет, или прицепить две руки к плечам, где есть правильные разъёмы, то есть, чтобы вот модульность какая-то была. А когда у нас есть реальная практика применения, реальные пользователи и реальные задачи, начинаются уже попытки подпилить к этим всем фреймворкам правильную семантику, правильные ARIA-атрибуты, доступность и всё остальное, и тогда уже, получается, практика применения совсем меняет эти фреймворки, если они вообще позволяют это делать. Наверное, нужно меньше писать фреймворков и больше собственного кода, наверное, стоит смотреть на практику, а не просто подключать jquery-плагины, вот в этом, наверное, есть выход какой-то. Тот же самый eBay на неделе опубликовал [MIND](http://ianmcburnie.github.io/mindpatterns/) — библиотеку доступных элементов интерфейса, такой сборник паттернов, я бы сказал. И они рассказывают, как они используют всякие карусели, кнопочки, они пишут, что стоит стоит делать, чего не стоит делать. Такая, не то, чтобы библиотека компонентов типа copy-paste — извини, средний разработчик, copy-paste не получиться — а просто такой подход на котором, собственно, растёт всё остальное.

**Лёша.**
Кстати, у них и правда очень хороший инструмент, но я хотел бы немножко вернуться назад — вот, я сказал про фреймворки, но я хотел бы и долю оптимизма какую-то внести, потому что, например, возьмём тот же самый React. React вам никак не помогает ни с семантикой, ни с доступностью.

**Вадим.**
А он мешает?

**Лёша.**
Ну, а ты посмотри на любой сайт, в котором одни дивы и классы. Как ты считаешь?

**Вадим.**
Нет, подожди, а React мешает?

**Лёша.**
Он ничего не делает. Вообще. Но, когда тебе дают другой инструмент ты как бы думаешь, что ты совсем в другой плоскости и не думаешь уже о каких-то привычных вещах. Ну, потому что у тебя там фокусы у элементов делаются другим способом, какое-то наведение на элементы делается другим способом, media-выражения… Ну, как бы, какие media-выражения? То есть, каких-то привычных вещей у тебя вообще нет, поэтому ты думаешь об этой штуке, как о чём-то вообще в принципе другом, и забываешь про семантику. Но, я к чему? Если React такой, то это не значит, что с ним нельзя сделать доступный сайт, потому что — посмотрите в код Facebook. Он весь утыкан aria-атрибутами. Он весь утыкан какими-то штуками доступными, там теги используются по назначению. Просто зайдите в Facebook, откройте код и посмотрите, как они это делают. Видимо, нужно больше тратить время на то, чтобы проект был хорошим? Но вот со временем-то у всех и проблемы.

**Оля.**
На самом деле, проблема вот этого вот отсутствия семантики, она ещё чуть глубже лежит, на мой вкус, потому что у нас сейчас в вебе есть разница между приложениями и документами. Разметка нужна документу, приложению разметка не нужна, потому что оно не работает без всех вспомогательных технологий. То есть, надо всегда разработчикам думать, есть ли в их сайте документ? Документ должен быть размечен, потому что такова конвенция и так будет лучше всем. А вот остальные — это большой вопрос пока, как их делать.

**Вадим.**
Ну, у нас именно для этого есть такая штука, которая называется WAI-ARIA — это огромный набор атрибутов (собственно, aria), которые сделаны для того, чтобы описывать состояния веб-приложений. Когда у нас есть какие-то документы, у которых есть — знаете, старинное такое — белый лист, чёрный заголовок, синие ссылки. Вот это вот старинный способ оформления документа — у нас есть заголовки, подзаголовки, параграфы, цитаты — в интерфейсах приложений это не нужно. В интерфейсах приложений главное — сделать элемент и взаимодействия между ними описать. Так вот, эти атрибуты описывают вот эти взаимоотношения между элементами, aria-атрибуты. И они специально были сделаны для того, чтобы описать вот это всё в ситуации, когда нам не хватает привычной нам семантики. И их можно и нужно использовать, и есть статьи, есть сборники паттернов, которые используются для разметки, вот это вот, aria-атрибутов для веб-приложений, для доступности. Но, ничто не мешает в твоём интерфейсе приложения использовать правильную систему заголовков, чтобы человек с какой-нибудь assistive technology мог бы передвигаться по твоему сайту — от заголовка к заголовку — и понимать, на каком уровне вложенности он находится. Ведь у всех есть какая-то иерархия интерфейсов — есть главный блок, шапка, сайдбар, есть какие-то вложенные блоки в нём — это всё можно описать html-элементами, которые когда-то были придуманы для документов. Они, в принципе, до сих пор подходят для описания интерфейсов приложений.

**Лёша** Я думаю, что, всё-таки, не хватает хорошей информации про семантику и про доступность, и не просто хорошей информации, удобочитаемой, с хорошими примерами, а чтобы… Мне кажется, до конца не определена проблематика, почему я должен это делать. Вот, она не заложена каждому в голову. Помнишь, мы в прошлом выпуске говорили о том, как заложили в голову людям о том, что таблицы — это плохо. Вот, сейчас про семантику и доступность эту мысль не заложили в голову. Вот, она вот где-то рядом витает, что это важно, кто-то постоянно ходит, постоянно говорит, что нужно-нужно-нужно, но она как-то не заходит в голову, потому что непонятно, почему важно. Вот ты говоришь — вот поэтому и поэтому, но она как-то вот не остаётся. Не знаю, почему. Мне кажется, что нужно как-то в это поле приложить больше усилий, и показывать, и объяснять, почему это важно.

**Вадим.**
Я продолжаю это делать и буду продолжать. Может быть, когда-нибудь я попаду в цель. У меня получается рассказывать какие-то вещи, которые там застревают. Может быть, получится в один день рассказать про доступность так же понятно, чтобы люди запомнили.

**Лёша.**
Давайте тогда вернёмся к eBay, потому что у них сайтик с компонентами, которые должны быть доступными, и вот мне интересно, я всё время пользуюсь Safari, а у него, знаете, такая проблема, что у него не каждый элемент табается.

**Вадим.**
Это можно настроить на уровне системы в Mac.

**Лёша.**
Да, но я не понимаю, почему это по умолчанию не так. И каждый раз меня это немножко парит, потому что, ну, вот, я хочу перейти на какую-то кнопку, которая не совсем кнопка но у которой там всякие роли прописаны, и фокусы есть, и tab-index, но она вот никак не табается. А вот у них, например, в тех же самых кнопках показывано, и даже в Safari, который вроде как не должен фокусировать элемент, он переходит по нему табом.

**Вадим.**
Мне ещё очень нравится у них там есть маленький такой паттерн и в принципе это довольно важная штука для доступности интерфейсов, как поимка фокуса. Ведь что такое фокус таба? Допустим, вы в каком-то поле ввода, вы нажали таб, он перешёл, допустим, на кнопку (если там всё в порядке с кнопкой). Нажимаете дальше — он проходит там через какие-то ссылки на странице, а потом возвращается адресную строку вашего браузера. Ну, обычно так всё происходит. А там есть техника, которая позволяет заблокировать, закольцевать, грубо говоря, поведение переход этого таба внутри какого-нибудь интерфейсного элемента. Объясню. Допустим, у вас на сайте какое-то очень важное модульное окно, которое подгружает вообще что-нибудь другое, совсем, замыкающее пользователя на этом элементе; и вы можете сделать так, чтобы у вас фокус замкнулся внутри этого окна, потому что довольно часто я вижу интерфейсе, когда я пытаюсь табать по этому окну, у меня фокус уходит под вот это вот затемнение на страницу, большую, которая лежит под этим модальным окном. И мне в итоге приходится кликать мышкой ещё раз, возвращаться туда и так далее. А можно замкнуть фокус внутри и таким образом вы из поля ввода перейдёте на кнопку закрытия, а потом снова в поле ввода. Довольно хороший паттерн, главное им, опять же, правильно пользоваться, чтобы не дай бог не забывать его откручивать и прикручивать вовремя.

**Лёша.**
Оль, ты как-то раз рассказывала о том, что ты пишешь лэндинги, делаешь их много, с удовольствием. А вы там как-то заботитесь о доступности? Про семантику я понял, что иногда это не требуется — ты сама сказала, а про доступность?

**Оля.**
Нет, нету у нас такой задачи. То есть, все наши приложения, которые мы рекламируем, они не подготовлены, поэтому нет ни возможности, ни задачи тратить время на подготовку доступности. Я понимаю, что это плохо, но пока вот так.

**Вадим.**
А есть ли у вас какая-то базовая структура заголовков? Вот так вот скажу: `<h1>` на странице есть?

**Оля.**
Есть, конечно. Семантика HTML, в каком-то виде, она, естественно, присутствует на наших страницах, по крайней мере, на тех, которые совсем с нуля делала я. Наш новостной сайт, он тоже нормально свёрстан, не одними `<div>` с классами. А вот с приложениями всё немножко сложнее.

**Вадим.**
Вот ты, Лёша, задаёшь мне провокационные вопросы, я тоже задам тебе провокационный вопрос. Вот ты тут говорил: «А зачем? А кому это нужно?», ну, я понимаю, что ты играл в человека, который про семантику ни разу не слышал. А я у тебя другое спрошу: а зачем вы учите своих ребят семантике на курсах «HTML Академии»? То есть, у вас всё так серьёзно, что на первом этапе вёрстки сайта у вас студенты исключительно HTML верстают, и только потом им разрешают дотронуться до CSS?

**Лёша.**
Поменялись ролями, да? Почему мы так делаем? Ну, потому что мы считаем, что это правильный подход, потому что мы тут типа большие профессионалы уже и знаем, что это хорошо, это помогает… Мы просто поменялись ролями, и я рассказываю всё тоже самое, что ты говорил. Потому что это хорошо и для роботов, и для читалок, и для всего чего угодно. Документ — это важная штука, которая должна быть размечена правильно. Часто говорят, что на это нужно тратить дополнительное время. Проблема в том, что если вы знаете сразу же об этом, то не нужно тратить дополнительное время, если вы сразу же делаете хорошо — будет хорошо. Нормально делай — нормально будет. Вот поэтому для новичков… Мы специально их изолируем в ту систему, где у них в принципе нет ничего, кроме разметки. Почему мы так делаем? Если вы им всё сразу же будете рассказывать, вы их соблазняете забыть о разметке, о чём-то таком, а когда они ничего другого не знают — они учатся, делают. Если бы мы всё сразу рассказали, они бы забили на это. И вот когда такой процесс обучения выстроен, в каком-то замкнутом мире, то получается хорошо и хорошо все справляются. Вы просто подумайте: новички, которые в первый раз встречаются с вёрсткой, размечают документы семантически вернее, чем вы.

**Вадим.**
Вы как хорошие родители — вы говорите им: «Сначала доешьте овощи, потом будет десерт.» — в виде CSS, анимаций и прочего.

**Лёша.**
Да, так и есть. Про прогрессивное улучшение рассказываем, то есть наши новички умеют верстать сайты без JS — это вообще магия.

## 29:40 CSS для новичков

**Вадим.**
На этой неделе были хорошие статьи как раз для новичков, или, может быть, даже не для новичков, но по крайней мере, для людей которые открыты к обучению. Мы нашли перевод [Магия CSS](https://webref.ru/layout/magic-of-css) — учебника Адама Шварца, в котором он рассказывает про блочную модель, про какую-то вёрстку макетов базовую, про переходы, анимации и так далее. То есть, довольно хорошее интро перевели на русский язык, поэтому если вы хотите освежить свои знания или просто порекомендовать кому-то такой базовый учебник… Ну, видимо, не совсем с нуля, но хороший, поэтому на русском языке, наверное, будет проще. И Бен Фрейн опуибликовал статью [Отладка CSS](https://benfrain.com/debugging-css/) — её, по-моему, пока ещё не перевели, но, мне кажется, такая вещь долго не залежится. Или, по крайней мере, прочитайте её в оригинале, там довольно интересно. Он, собственно, проходит через базовые понятия того, как вообще CSS работает, и, если что-то пошло не так, что с этим делать. Вот, Оля мне рассказывала вчера смешно, что этот учебник она порекомендовала своим программистам.

**Оля.**
Ну да, потому что иногда возникает какой-то вопрос, почему вот так вот происходит, или что тут вообще происходит? Я говорю — посмотрите тут, а это вот происходит потому, и слышу в ответ: «о, боже, это ужасное колдунство, что за CSS, не хочу ничего об этом знать!». Да, отладка CSS, на самом деле, это немножко странная вещь и в этой статье достаточно логично описано, как к ней подходить и почему оно всё так.

**Вадим.**
Все мы занимались отладкой CSS, и большинство в начале, и до сих пор включают-выключают свойства и добиваются нужных результатов методом тыка. И, наверное, хорошо бы из этого сделать систему, и как раз Бен Фрейн пишет об этом. Не то, чтобы там какие-то пошаговые руководства как решить все проблемы, но, по крайней мере оно организует немножко всё это дело. Я помню, как Юра Артюхов формулировал вот эту идею отсечения CSS: когда что-то жуткое происходит, ты удаляешь половину исходника, проверяешь — баг на месте? OK — на месте, удаляешь вторую половину оставшейся половины, и так далее. Это был один из первых методов с научным описанием, который я применял в отладке CSS, когда только начал. Это было довольно интересно, что разные люди независимо к этому пришли без особых книг, без всего. Просто практика подсказывает, что, наверное, так нужно делать.

## 32:09 Контроль версий и клиенты

**Лёша.**
У нас тут на повестке дня (неразборчиво) кажется, пора уже отойти немножко от семантики и доступности. Мы с вами хотели немножко поговорить про то, как кто работает с Git, какой workflow использует и так далее, потому что… Ну, я надеюсь, все ведь работают с системами контроля версий?

**Вадим.**
Ну, дизайнеры через dropbox работают, и ничего.

**Лёша.**
Вот, у нас сейчас продвинутый интенсив стартует, и там у меня первая лекция про Git как раз. И, вот ты говоришь: «дизайнеры работают через Dropbox». Просто это очень показательный момент, и я именно на нём показываю, почему работать с Git удобнее. У меня там в примерах два дизайнера, которые друг другу макеты отправляют. И это просто шикарнейший, это лучший пример, который можно найти и на котором можно легко объяснить, почему Git — это хорошо.

**Вадим.**
Ну расскажи немножко.

**Лёша.**
А что рассказывать? Ты же видел папочку дизайнера, в которой есть 'maket.psd'. Потом 'maket-1.psd', потом '2', '3', потом появляется, после всех финальных правок, конечно же 'maket-6-final.psd'. Потом, конечно же, приходится ещё немножко внести правок, поэтому появляется 'final-final', 'final-final-final'… Потом у тебя такая гигантская папка из этих psd-макетов. Ну что тут рассказывать? Вот так вот.

**Вадим.**
Нет, ну смотри, в dropbox, насколько я знаю… Я небольшой фанат dropbox, по-моему, это медленная сволочь. Так вот, у них же есть история версий. Соответственно, вы можете сохранить одно и то же имя, а потом возвращаться к предыдущим версиям.

**Лёша.**
Это совсем неудобно, поэтому так пользуется мало людей. Тебе нужно видеть все версии прямо, потому что… Дизайнеру же нужно как? Он, например, удалил какой-то блок в какой-то из версий, а теперь в 'final-final' версии понял, что, наверное, поспешил и надо всё-таки этот блок вернуть. И что ему делать? Ему через этот ужасный механизм dropbox как-то там возвращаться-возвращаться, открывать этот psd, забирать этот слой, копировать его в свой новый макет… Ну это, как бы, ад.

**Вадим.**
На самом деле, никто всерьёз не придумал ещё, как дизайны держать в контроле версий. То есть, вот ребята из того же самого Protein, Zeppelin и прочих пытаются в эту сторону двигаться, но я видел интересную цитату в одном докладе, что код — это один из немногих важных инструментов, который дизайнеры ещё не освоили. И я с этим согласен, может быть, когда дизайнеры будут больше верстать, у них получится и с контролем версий лучше работать, потому что в dropbox ведь не напишешь комментарий, почему этот блок убрал, ты же какой-нибудь патч не вернёшь из предыдущего коммита, чтобы там что-нибудь доделать в новом дизайне используя элементы старого. В общем, почемы мы вообще заговорили об этом? На этой неделе вышел клиент [GitKraken](https://www.gitkraken.com/) — это такая штука, написанная на Electron со всеми его детскими болезнями в виде корявеньких интерфейсов, которые ты больше ожидаешь увидеть в вебе, чем на десктопе. В общем-то, альтернативный клиент, у которого есть тёмная и светлая темы. И, собственно, я решил поговорить об этом просто потому, что я чувствую явный конфликт между любителями консольного Git и интерфейсных программ, которые позволяют немножко по другому работать. Вот вы, ребята, как работаете с Git?

**Оля.**
Я работаю через консоль. Не знаю, зачем нужны все эти интерфейсы… Наверное, для какой-нибудь сложной работы, но так как мне надо обычно сделать ветку — смёржить ветку, сделать ветку — смёржить ветку, я не заморачиваюсь.

**Лёша.**
А я практически всегда работаю через консоль, и единственное, что я делаю не через консоль — это когда я работаю с проектом в Atom, я просто отправляю коммиты из Atom, чтобы не переключаться на другой интерфейс. Но, тем не менее, потом я перейду в консоль, и сделаю там всё, что мне нужно ещё.

**Вадим.**
А мне очень всегда нравились программы с интерфейсами для Git просто по одной причине: консоль модальная. То есть в один момент в консоли вы вызываете одну команду, и она вам показывает результат. Вы можете вызвать вторую команду, и, если у вас достаточно большое окно, вы увидите результат предыдущей команды и текующей. Два, скорее всего, ну, максимум, три — если у вас огроменный экран, вы увидите пять. И чтобы сделать что-то следующее, вы просто убираете все эти штуки с экрана, потому что они прокручиваются наверх. В интерфейсе клиентов типа [Tower](https://www.git-tower.com/), [GitHub Desktop](https://desktop.github.com/), [GitBox](http://gitboxapp.com/), [GitUp](http://gitup.co/) и так далее, кроме умных вещей, которые позволяют вам делать меньше, писать меньше и как-то иначе смотреть на историю веток, коммитов и так далее, там нет модальности. Вы можете кликнуть на какой-нибудь… Я на примере [Tower](https://www.git-tower.com/) говорю — это клиент для Mac. Вы можете кликнуть на какую-нибудь вкладку history и увидеть все свои двадцать пять коммитов, которые влезут в один экран, быстренько пробежаться по ним глазами и выбрать нужный, кликнуть на него и у вас сразу появится и diff, и автор коммита, и что именно изменилось, в каком месте изменилось, и что произошло, какая хэш-сумма и так далее. Вы тут же получаете одним кликом информацию обо всём. Вам не нужно решать, что вы хотите сейчас увидеть: хэш коммита, или diff, или ещё что-то; у вас не откроется никакой vim во время мёржа, у вас во время мёржа откроется какой-нибудь внешний редактор, или встроенная мёржилка.

**Лёша.**
Ну, это ты просто настраивать не умеешь, потому что можно, чтобы у тебя и редактор открывался из консоли.

**Вадим.**
Нет, я верю, есть всякие Git Dev Tool, Merge Tool и так далее.

**Лёша.**
Не-не-не, это вообще базовый функционал: где писать тебе merge — в vim или в редакторе — определяешь сам, прямо в дефолте.

**Вадим.**
Я имею в виду, что большинство-то не настраивают, большинство-то просто работают с консолью. И вот этот вот момент модальности… Ладно, я готов принять любые другие аргументы, но вопрос модальности, что вы можете сделать только одну вещь, и увидеть только одну вещь, одну выбранную информацию, скорее всего, в не очень удобном виде — вот это для меня определяюще. Я могу легко искать по коммитам в нормальном интерфейсе, а не в какой-то адской консоли, которую кто-то раскрасил как новогоднюю ёлку. Я могу делать обзор коммитов и смотреть, насколько нормально дерево строится. Мой клиент периодически сам фетчит что-то с сервера, я могу посмотреть, когда появилась какая-то ветка на удалённом remote, я могу понять, что пришёл какой-то pull request. То есть, мне не нужно думать: «пойду проверю, не появилась ли какая-то ветка». Он мне сам это делает. Очень много вещей автоматизируется, поэтому я знаю как пользоваться консольным Git, иногда бывают ситуации, когда я и так уже в консоли, и я что-нибудь там стэшу, добавляю к коммиту или ещё что-нибудь, или какой-нибудь commit message пишу — бывает. Но в большинстве случаев я предпочитаю открыть интерфейс и там всё натыкать.

**Лёша.**
Знаешь, как я говорю нашим ученикам на базовом и продвинутом интенсивах? На базовом интенсиве все они работают с gui.

**Вадим.**
У вас там [GitHub Desktop](https://desktop.github.com/) рекомендуется, да?

**Лёша.**
Да, потому что это Github-клиент, мы на Github работаем, чтобы проще было. Можно использовать любой, но смысл в том, что мы не даём им использовать консоль вообще ‒ там задача не в этом. То есть, там Git ‒ это просто средство. Раньше там был ftp, теперь там Git. Там совсем не до этого. А вот на продвинутом ‒ там нет никаких gui, там только консоль, потому что любой разработчик должен понимать, как это работает. Вот ты сказал, что ты пользуешься gui, потому что… Ну, ты понимаешь, как работает это всё, понимаешь, как консоль работает, но пользуешься gui, потому что тебе так удобнее. Это, в принципе, нормально, но есть другой случаей и он более подавляющее число, чем ты. Это когда люди берут этот клиент, потому что… Ну, они не понимают, как работает Git. И для них нужно, чтобы программа за них делала магию. Это такой чёрный ящик, в котором они не понимают, что происходит. Ты говоришь ‒ «я тыкаю на коммит, и у меня всё показывается.» Но человек абсолютно не понимает, что произошло.

**Вадим.**
Я не думаю, что средний разработчик понимает, как Git вообще всё это делает. Git очень много магии делает. Он резолвит всякие мёржи, конфликты… Очень много автоматики, в отличие от SVN, он делает.

**Лёша.**
Да, смотри, а ты тут ещё больше магию наворачиваешь за счёт того, что используешь gui-клиент, и ты становишься рабом этого клиента, потому что… Ну, Git можно пользоваться по-разному. А вот в каждых gui заложен какой-то… Ну, чаще всего, один механизм. То есть, они считают, что тебе нужно работать с твоими репозиториями вот так вот. И ты работаешь именно вот так, ну потому что это GUI. Ты заложник этого. Если вдруг этот клиент решит как-то перестроить твой процесс ‒ тебе придётся перестраиваться. Если этот клиент не поддерживает какую-то фичу ‒ у тебя этой фичи нету. Если вдруг у тебя обновится версия Git… Хотя, скорее всего, этого не произойдёт, но мало ли, ты вдруг обновляешь консольные утилиты. Клиент не научится работать с какими-нибудь штуками которые сильно поменялись в самом Git, у тебя сломается твой клиент. То есть, gui это хорошо конечно, но тут всегда компромисс между удобством и поддерживаемостью.

**Вадим.**
Оль, а ты не пробовала gui-клиент? Просто интересно.

**Оля.**
Нет. Просто не за чем. Я не знаю, что они мне могут дать, у меня есть весь нужный мне функционал в консоли. Когда мне нужно что-нибудь… Очень редко бывает, когда мне нужно посмотреть историю ‒ я иду в веб-интерфейс и там смотрю.

**Вадим.**
А у тебя бывали сложные мёржи, допустим? Что ты используешь для мёржа?

**Оля.**
Команду `merge`. Если там есть конфликт, я открываю редактор и всё правлю, в чём проблема-то?

**Лёша.**
Я точно так же ‒ ты открываешь редактор и правишь конфликт, просто…

**Вадим.**
В редакторе все эти ёлочки, то есть ты видишь, где там конфликт?

**Оля.**
Да.

**Лёша.**
Вадим просто говорит о том, что ему нужен инструмент, который ему это красиво покажет и он кликом будет говорить, что он этот кусочек коммита хочет.

**Вадим.**
Ну да.

**Оля.**
Ну, это какое-то сибаритство.

**Вадим.**
Ну, не знаю. Я просто люблю чтобы было удобно, не смейте меня в этом обвинять!

**Лёша.**
Не-не-не, это лень, это нормально. Все разработчики ленивы. Это, в принципе, нормально. Но при этом нужно понимать, что это всё-таки лень, продиктовано ленью.

**Вадим.**
Ну нет, пожалуйста…

**Оля.**
Честно говоря, я тоже могу сказать, что у меня это лень, потому что я не хочу изучать никакие там новые клиенты. Я как привыкла с консолью работать ещё с каких-то чудовищных систем контроля версий, которые сейчас даже не помню как называются, так и продолжаю. Может быть мне бы принесли что-нибудь новое эти десктопные клиенты, но как-то вот не срастается.

**Вадим.**
Есть два типа клиентов, которые мне нравятся ‒ я периодически пробую разные клиенты для Git. Одни клиенты ничего не добавляют к логике, которая есть в обычной консоли: ты просто ставишь галочку ‒ ты добавляешь какой-то файл, потом пишешь комментарий и нажимаешь коммит, и он тебе показывет историю ‒ всё. А слева список репозиториев. Я люблю такие базовые клиенты без кучи кнопок, без кучи всякой ерунды. Вот таким клиентом был [GitBox](http://gitboxapp.com/), но, к сожалению, автор… По-моему, последняя версия выходила в 2012 году, и автор совершенно забросил его. А я когда-то был большим фанатом. А с другой стороны, есть клиенты, которые пытаются сделать что-то альтернативное. Показать тебе твои ветки в новом интерфейсе, показать тебе какие-то интересные переплетения, взаимодействия внутри твоего репозитория. И вот такой клиент, [GitUp](http://gitup.co/) называется (он, по-моему, только для Mac есть, но не уверен до конца). Вот он как раз интересен тем, что он помогает тебе по-другому посмотреть на твой репозиторий. Поэтому, если вы не пробовали, если вы хотите попробовать что-то такое, посмотрите на GitUp ‒ он довольно интересный. Вот именно [GitHub Desktop](https://desktop.github.com/) мне не нравится тем, что он упрощает всё настолько, как будто у тебя GitHub, а не Git. И вот он, по-моему, немножко ломает типичную модель взаимодействия с коммитами. Там есть такая вещь, как синхронизация. То есть, ты не пушишь и пулишь, ты синхронизируешь. И вот это, по-моему, вредная штука.

**Лёша.**
Я согласен. `sync` это на самом деле `pull`, `push`. Это, наверное, вредно, но опять же, смотри, какая у тебя задача: ты новичку не сможешь объяснить вот эти концепции сразу же.

**Вадим.**
Ну да, да.

**Лёша.**
Не сможешь, и всё. А команда `sync`, она вообще-то более человечная.

**Вадим.**
У меня как-то Брюс Лоусон спросил: «А почему на GitHub нет кнопки типа „синхронизироваться с форком“»? Вернее, синхронизироваться с оригинальным репозиторием. Ты форкнул что-то, ты месяц его не трогал. Была бы кнопочка «синхронизировать мой форк», которая берёт и пулит из родного репозитория что-то и обновляет твой форк. По-моему, на GitHub до сих пор нет такой кнопки, и для этого нужно зайти в консоль, сделать `checkout`, потом сделать пул из какого-то ориджина оригинального.

**Лёша.**
(шёпотом) Апстрима, апстрима.

**Вадим.**
Апстрима, да. Кстати, вот у нас сейчас [твой пулреквест](https://github.com/web-standards-ru/dictionary/issues/234) в словаре терминов по фронтенду про Git-термины. В общем, скоро мы опубликуем те термины, которые ребята из «Академии» используют в своём обучении, так что, может быть, вам самим будет немножко проще говорить на одном языке вместе с нами.

## 45:51 JS-модули в Edge!

**Лёша.**
Я предлагаю ещё немножко поговорить про ECMAScript, потому что на этой неделе наконец-то сдвинулась самая большая проблема ‒ ES-модули. И в блоге Edge (Microsoft тут хочет застолбить за собой право первооткрывателей) [рассказали](https://blogs.windows.com/msedgedev/2016/05/17/es6-modules-and-beyond/), что в последней сборки Edge они добавили такую экспериментальную реализацию ECMAScript-модулей. Мне даже удалось перед подкастом установить этот новый Edge, посмотреть, поиграться немножко, и я вам скажу ‒ это и правда работает. То есть, импорты и экспорты работают в Edge. И более того, работает `<script type="module">`. То есть… Расскажу немножко подробнее, как это происходит. Во-первых, если вы хотите использовать импорты и экспорты в любом скрипте, то этот скрипт обязательно должен быть подключен в HTML с атрибутом `type="module"`. То есть, в обычном скрипте импорты и экспорты просто выключены, они работать никак не будут. Вместе с `type="module"` у вас появляются конструкции `import` и `export`, и вы можете из них прямо подключать какие-то дополнительные файлы. То есть, в примере… Кстати, знаете, что смешно? В примере, который в блоге Edge показан, там вообще ошибка.

**Вадим.**
Там есть… Скрипт подключается html'ный, а комментарий JavaScript'овый, да?

**Лёша.**
Не, не, скрипт подключается html'ный, но не закрывается.

**Вадим.**
А, да-да. Я как раз, когда пишу новость, я иногда копирую код из блогов каких-нибудь, вставляю в Atom и делаю скриншот для картинки. Так вот, я помню, что я скопировал, а там незакрытый тег, я его закрывал руками.

**Лёша.**
Вот. А я сначала тоже не заметил. В первую очередь, чтобы попробовать, скопировал пример, посмотрел, но при этом вставил ещё скрипты сверху и снизу, чтобы посмотреть, как оно работает, когда что показывается. И ничего не работало. Я думаю, что за фигня, может, у меня Edge кривой? А потом смотрю ‒ реально, ошибка.

**Вадим.**
Внимание, авторы статей и докладов. Пожалуйста, убедитесь, что ваши фрагменты кода работают без ошибок, что у вас там прямые кавычки, теги закрыты и так далее, потому что иногда примеры хочется скопировать и попробовать.

**Лёша.**
Ну, вот да, именно так и произошло. Ну, что я скажу? Что штука работает; она, конечно, за флагом, за экспериментальным флагом, но работает такая базовая концепция. Она, конечно, кривоватая: у меня она там падает туда-сюда, но, в принципе, у меня получилось завести пример. То есть, если у вас есть ряд скриптов, то все скрипты подключаются друг за другом, и скрипты с `type="module"` тоже подключаются друг за другом, а вот всё, что дальше, оно подключается асинхронно, то есть если у вас есть два тега `<script type="module">` и просто `<script>`, оба они будут подключаться асинхронно друг с другом. И внутри, если вы подключаете что-то из импорта, оно тоже в каком-то отдельном процессе, оно асинхронно от всех остальных скриптов на HTML-странице, но при этом оно подключается и выполняется когда загрузится. То есть, вроде как, всё работает, как мы хотим. Но, опять же, это только первая реализация, в ней ещё много чего не работает: например, динамически вы не можете подключать модули, то есть всё только статически, вы объявляете декларативно наверху все импорты, которые вам нужны и они все подключаются. Сделать так, чтобы при каком-то условии импорт подключался, пока нельзя. Ну, они говорят, что они над этим работают. Ну, и спецификация лоадеров, она тоже ещё не закончена, ещё будет работа над ней. В общем, Edge попытался застолбить за собой право первых, вроде как у него получилось, по крайней мере, формально. Но, тут смешно про Firefox было, ты рассказывал мне, Вадим.

**Вадим.**
Да, [Firefox попытался застолбить](https://twitter.com/jlongster/status/732645925978550272) за собой право вторых. Обычно так это делают ребята из Webkit. Они такие приходят и говорят: «А кстати, а у нас это уже давно есть, просто мы не рассказывали». Ребята из Firefox тоже прибежали, говорят: «А вы знаете, знаете, а мы тоже уже реализовали модули, просто ещё никому не показали. И вот вам скриншоты». Они показали скриншоты работающих модулей в сборке Firefox, которая запущена на компьютере какого-то разработчика, но пока никому не доступна. То есть, есть. Давайте, просто поверим, что где-то модули работают во втором движке, кроме Edge.

**Лёша.**
Ну, и вообще, это замечательно: наверное, к концу года мы будем иметь такую реализацию во всех браузерах. Я вот только очень бы хотел, чтобы в Safari, который, скорее всего, выйдет осенью с новой операционной системой, чтобы они как-то постарались подумать над модулями, иначе нам придётся ждать ещё год, а этого бы не хотелось.

**Вадим.**
А модули не полифилятся в итоге никак. Вот, чтобы они работали прямо так, как они должны работать.

**Лёша.**
Не-не, вообще не полифилятся, то есть тебе придётся бандлить всё, а это значит бандлить и во всех других движках, где можно было бы работать. То есть, нет вариантов. Это такая, системная штука.

**Вадим.**
Она просто меняет поведение JS, поэтому это всё не отполифилить. Тоже самое, как с проектом «Houdini»: там слишком много слишком сложных вещей, поэтому css-свойства не отполифилить, для этого нужно забираться глубже.

**Лёша.**
Кстати, если оно к концу года появится, то это будет даже хорошо, потому что HTTP/2 уже, наверное, можно будет использовать, и вот вместе оно, по-моему, очень гармонично будет смотреться. Я вот, например, эту фичу очень жду, и если меня спросят в конце года ‒ самая ожидаемая фича, которую я ждал, я, наверное, расскажу как раз про модули.

## 51:42 Google I/O

**Вадим.**
Ещё есть событие ‒ мы обычно о событиях говорим вначале выпуска, но тут есть событие, о котором решили поговорить в конце. На этой неделе прошла большая конференция [Google I/O 2016](https://events.google.com/io2016/). Это такая конференция, типа WWDC от Apple, она длилась три дня, на которой Google рассказывает обо всём новом, что у них есть. Они представили какую-то новую железку для управления умным домом, они показали одну, другую вещь ‒ но, в общем, это всё ерунда. Главная новость этого Google I/O в том, что Google всё больше [говорит про веб](https://www.youtube.com/playlist?list=PLNYkxOF6rcIDz1TzmmMRBC-kd8zPRTQIP). И продолжает говорить про веб очень много и очень серьёзно. Меня это страшно радует. Смотрите, мы как компания Opera ‒ кстати, сегодня мы ещё не упоминали про компанию Opera, удивительно ‒ так вот, мы как компания Opera поставили на движок Chromium, потому что он сильно ориентирован на веб, который нам всегда нравился. И когда я слежу за новостями с Google I/O, я вижу, что веб в большом приоритете у компании Google, и мне становится немножко спокойнее, потому что когда я слежу за новостями с WWDC от Apple, я вижу железки, софт, AppStore и у нас что-то новое и очень крутое, но ни слова про веб обычно. Так вот, что же было интересного в Маунтин-Вью 18-20 мая? Очень много докладов было, и мы потихоньку начали публиковать уже все доклады в наших новостях. Но если резюмировать вообще то, о чём говорит Google на Google I/O, можно назвать две ключевых вещи, две аббревиатуры: [PWA](https://developers.google.com/web/progressive-web-apps/) и [AMP](https://www.ampproject.org/). PWA ‒ это не клей, это Progressive Web Apps, те, кто слышали наши предыдущие выпуски, давно уже об этом знают, некоторым, наверное, уже надоело. Но суть в том, что это способ сделать из страниц приложения, которые можно устанавливать в операционные системы, они работают с оффлайном, со всеми браузерными API, у них есть описание их поведения, иконок, загрузки и так далее, у них есть Service Worker, который по умному работает с сетью, у них есть уведомления, у них есть пуш, в общем, всё на свете, чего нам не хватает, чтобы делать из сайтов веб-приложения, чтобы они чувствовались, как нативные. Так вот, Progressive Web Apps решают эту проблему. А AMP решает другую проблему: он решает проблему скорости загрузки страниц. На PiterCSS во вторник будет доклад про AMP. Это Accelerated Mobile Pages, это такая штука, такое подмножество современных веб-технологий, сильно ограниченное. Если зайти на типичную страницу сейчас в интернете, то она грузится-грузится-грузится, о, соединение потерялось ‒ чёрт, ладно, на следующей станции метро догружу. AMP загружается мгновенно. Почему? Потому что там не исполняется внешний JavaScript, там ограничены доступы к каким-то разным технологиям, там есть чёткая спека, которая описывает, как валидные технологии (там в основе, конечно, HTML) должны быть исполнены, а если страница не валидная ‒ браузер показывает вам, что страница не валидная, как было с XHTML. И у Facebook, и у других ребят есть [Instant Articles](https://instantarticles.fb.com/) ‒ особый формат, который работает на основе RSS, примерно. В общем, крупные компании пытаются сделать страницы, которые будут работать очень быстро, невероятно быстро, которые даже не загружаются ‒ они уже там, когда вы их запросили. Так вот, с одной стороны, Google пытается двинуть страницы, чтобы они работали нативно, с другой стороны он пытается двинуть, чтобы обычные веб-странички грузились мгновенно, прям моментально и без тормозов. Такие, две немножко противоречащие, прям очень разные штуки, но это два ключевых термина с конференции Google I/O. Естественно, там ещё много говорят про оффлайн, про всякие HTTPS, и, наверное, ещё большой новостью стало то, что Google не просто активно продвигает API для платежей в вебе, а они собираются их до сезона осенних праздников и распродаж внедрить в браузер. На этой неделе была интересная [статья про автозаполнение](http://blog.cloudfour.com/autofill-what-web-devs-should-know-but-dont/), в которой прошлись по всем методам, которые существуют для автозаполнения форм браузера, и как они реализованы, и в чём вообще разница между реализациями. Выяснилось, что всё довольно плохо. Так вот, одним из способов решить проблему с автозаполнением в браузере будет новый API для платежей в вебе. И этому посвящён отдельный доклад; мы, конечно, на неделе дадим ссылку на него, поэтому внимательно посмотрите ‒ это поменяет то, как пользователи заполняют ваши формы. Лёша, а ты видел что-нибудь интересное на этом Google I/O, слышал о чём-то?

**Лёша.**
Я за Google I/O следил, я почему-то больше всего видел штук не про веб, а про всякие железки, как раз-таки наоборот. И, вот ты, кстати, сравнивал Apple и Google. Мне кажется, что Google уделяет так много внимания вебу, потому что они зарабатывают через веб, они не научились ещё зарабатывать не через веб. И тут тоже самое с Apple ‒ у них ровно наоборот, они зарабатывают не через веб, а через свои железки, и поэтому всё достаточно логично ‒ каждая компания делает то, что приносит ей больше прибыли. И в этом смысле для Opera и правда хорошо быть рядом с Google, потому что для них веб важен. Но, вот ты спросил меня, что я видел ‒ я видел очень много железок. То есть, во-первых ‒ железки, во-вторых ‒ приложения, это всякие чатики, чат-боты, это управление домами и так далее. То есть, Google всё-таки пытается в железки уйти. Поэтому, я бы на вашем месте не был бы так уверен в том, что веб будет всегда для Google первоочередным, но, по крайней мере, очень-очень долгое время, наверное, так и будет.

**Вадим.**
Я тоже понимаю, что много всего анонсировали софтверного и железного Google, я конечно, слежу за вебом, но я имею в виду, что не возникает ощущения, что веб ‒ это одна из платформ, это прям одна из ключевых. Даже приложения, которые чисто софтверные получили очень интересный поворот в стиле веба. Там ведь Google сделал так, что приложения из PlayStore можно будет устанавливать просто кликнув по ссылке. То есть, вы кликаете по ссылке ‒ и приложение запускается. Оно не ставится в вашу систему, оно не загружает 500 метров, оно не просит разных разрешений ‒ вы просто кликнули, произошёл какой-то редирект, и оно запустилось. И там очень сильно имитируется модель работы веба в этот момент, хотя никакого веба как такового нет. Может быть там веб-протоколы используются, но не более того, веб-технологий там нет особо.

**Лёша.**
Да, это, кстати, было интересно, недавно ещё показали, что будет подгрузка контента в приложениях. То есть, если тебе нужен кусок кода для твоего приложения, который используется не в основной части, а чуть-чуть позже, он не будет грузиться сразу же, а подгрузится позже. Ну да, это было интересно. Но мы совсем сейчас не про веб.

**Вадим.**
Каждый третий в моей англоязычной Твиттер-ленте опубликовал ссылку на [комикс xkcd](https://xkcd.com/1367/), про то, как я сделал это, сделал это ‒ ой, я кажется переизобрёл веб. В общем, мы тоже дадим ссылку, посмейтесь вместе с нами.

**Лёша.**
С вами был семнадцатый выпуск подкаста «Веб-стандарты» и его постоянные ведущие: Вадим Макеев из «Opera», Ольга Алексашенко, верстальщик руками из «Exante».

**Вадим.**
И Алексей Симоненко из «HTML Академии».

**Лёша.**
Услышимся.

**Оля.**
Всем пока!

**Вадим.**
Пока!
