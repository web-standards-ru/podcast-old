# Выпуск №6. 9 марта 2016

Флексбоксы, CSSO, `preload` и `prefetch`, HTTP/2, SVG, БЭМ и шаблонизация.

- Вадим Макеев
- Слава Олиянчук
- Алексей Симоненко

[Слушайте на SoundCloud](https://soundcloud.com/web-standards/episode-6), [обсуждайте в Слаке](https://web-standards.slack.com/messages/podcast/).

## 00:53 События

- [PiterCSS №2](https://pitercss.timepad.ru/event/298243/) 22 марта

## 01:02 Флексбокс — кандидат в рекомендации

- [Флексбоксы готовы!](http://css-live.ru/vecssti-s-polej/fleksboksy-gotovy.html)
- [Полифил Flexibility](https://github.com/jonathantneal/flexibility)
- [Будущее механизмов раскладки](https://youtu.be/ZEd7bEqe6iI)

## 06:19 Определение `<article>`

- [Rewrite of the article element definition](http://stevefaulkner.github.io/article/)

## 09:12 Висячая пунктуация

- [Висячая пунктуация в WebKit](https://twitter.com/grorgwork/status/705546895528034305)
- [Gosh Hang It!](https://github.com/liamdanger/gosh-hang-it)
- [Типограф Муравьёва](http://mdash.ru/)

## 13:47 Обновился CSSO

- [CSSO 1.6.0 release](https://github.com/css/csso/releases/tag/v1.6.0)

## 18:37 Быстродействие

- [Preload: What Is It Good For?](https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/)

## 26:17 HTTP/2

- [HTTP/2: готовимся к переходу](https://habrahabr.ru/company/selectel/blog/278167/)
- [Не гзипом единым, видео с Я.Субботника](https://youtu.be/n3gtj7veL3I?t=17670)
- [Твиттер Frontend Performance](https://twitter.com/perfception)

## 32:37 Блютус в вебе

- [An introduction to the Web Bluetooth API](https://dev.opera.com/articles/web-bluetooth-intro/)

## 34:18 Про SVG по-русски

- [SVG в вебе. Практическое руководство](https://svgontheweb.com/ru/)

## 37:26 БЭМ и шаблонизация

## 48:22 Про шаблонизатор BEM-XJST

- [Видео доклада про BEM-XJST](https://youtu.be/n3gtj7veL3I?t=21268)
- [Репозиторий проекта](https://github.com/bem/bem-xjst)

## 1:00:20 Завершение: ваши предложения

---

**Вадим.**
Привет!
С вам шестой выпуск подкаста «Веб-стандарты» и его постоянные ведущие Алексей Симоненко из HtmlAcademy…

**Лёша.**
Вадим Макеев из Opera…

**Вадим.**
И сегодня с нами вместо Ольги верстальщика руками Слава Олиянчук из Яндекса.

**Слава.**
Привет всем!
Добрый день!
Здравуствуйте!

**Вадим.**
Слава работал в Авто и Недвижимости.
Сейчас разрабатывает SERP.
Кстати, кто-нибудь из тех, кто не работает в Яндексе и не занимается SEO, знает, что такое SERP?

**Лёша.**
Ну я, к сожалению, был в какой-то момент немножко связан с SEO, поэтому я знаю.

**Вадим.**
Окей!
Оказалось, что SERP — это не то, чем жнут.
Это Search Engine Results Page, грубо говоря — страница выдачи.
В Яндексе очень много забавных аббревиатур, поэтому у нас для вас мини-конкурс: что значит «вышел из ПК», «иду в КР» и «увидимся в ДД»?
Отвечайте в комментариях, если вы не работаете в Яндексе, понятное дело.

[_Расшифровка аббревиатур_](#Расшифровка-аббревиатур)

## 00:53 События

**Вадим.**
Мы традиционно начнём с новостей.
Событий новых особо на этой неделе не было.
Впереди у нас [PiterCSS](https://pitercss.timepad.ru/event/298243/) 22 марта.
А так в общем-то всё ровно.

## 01:02 Флексбокс — кандидат в рекомендации

**Лёша.**
На этой неделе произошло замечательное событие.
Спецификация флексбоксов [перешла](http://css-live.ru/vecssti-s-polej/fleksboksy-gotovy.html "Флексбоксы готовы!") наконец-то в статус кандидата в рекомендации.
Это произошло 1 марта.
И теперь у нас есть утверждённая W3C спека.
Что там произошло интересного — сейчас пока сложно сказать.
Они поменяли многие моменты из-за которых происходили ошибки в браузерах, а какие-то ошибки, баги спецификации решили утвердить в качестве фич и оставить их до того момента, как выйдет какой-нибудь Flexbox level 2.
Пока что сложно сказать, как это всё будет работать, как это повлияет на флексбоксы, потому что нужно конечно подождать реализации в браузерах.
Как, вы вообще рады, воодушевлены тем, что флексбоксы наконец-то в рекомендации и больше не осталось никаких поводов не использовать их?

**Вадим.**
Ну, судьба спеки была довольно мучительная всю дорогу.
Сначала там была девятая версия, потом одиннадцатого года, потом двенадцатого года спецификации.
И вот наконец-то я очень рад, что мы можем успокоиться и поставить эту книгу с флексбоксом на полочку и просто начать его использовать.
Я пару лет назад делал доклад про флексбоксы.
Уже тогда в принципе это всё можно было использовать для мобильников.
Сейчас это вполне реальность на десктопе.
Всё прекрасно фолбечится и нормально работает.
Ну, если у вас какой-нибудь старый Internet Explorer, то конечно нет.
Но всё равно с этим можно как-то справляться.
Даже есть [полифил](https://github.com/jonathantneal/flexibility "Flexibility") джаваскриптовый, который флексбокс реализует.
Он немножко странный, но на сколько я знаю он работает.
Вы, я слышал, в своей новой Академии лэндинги для интенсивов на флексбоксе верстали?

**Лёша.**
Да, мы верстаем на флексбоксах.
Вообще вся новая версия сайта очень хорошо использует флексбоксы.
Но она к сожалению ещё не до конца выкачена в продакшен.
У нас есть возможность отказаться от старых Internet Explorer, поэтому почему бы и нет.
Кстати, ты сказал, что есть полифил, но я хотел сказать, что я бы к полифилу очень и очень с осторожностью подходил.
Если вам нужно поддерживать старые браузеры, а это видимо IE9 и старше — вы вообще представьте, в какой ситуации у людей стоит IE9.
Скорее всего у них там не очень компьютер, не очень всё быстро.
И может быть не стоит использовать флексбоксы для них особенно в полифиле?
У них и так всё плохо.
Оставьте вы им их `inline-block` или `float`.
Потерпите.

**Вадим.**
Ну, зависит от ваших задач.
Есть сервисы, которые рассчитаны на гиков, и там естественно можно использовать чуть ли не Grid Layout.
А есть сервисы рассчитанные на более массовую аудиторию.
С другой стороны, та же почта яндексовая по заверениям Ромы Комарова вполне себе использует флексбоксы.
У них аудитория не гиковская совершенно, у них широкая аудитория, с разными компьютерами и браузерами, но они видимо позволили себе это дело.
Поэтому может не так всё плохо.

**Лёша.**
А ты думаешь они используют полифил, а не просто деградируют свою вёрстку на какие-то фолбеки?

**Вадим.**
Нет, я думаю они используют деградацию может быть на `float` или ещё что-то.
Я просто имею в виду, что можно попробовать полифил, если он позволит вам сделать не то чтобы главный лэйаут страницы, но какие-нибудь лучше выглядящие штуки.
Я не думаю, что это так сильно нагрузит браузер.

**Слава.**
Я тут вспомнил, что внезапно я дожил до того момента, как прошло лет пять с моего доклада-исследования про будущее механизмов раскладки.
До сих пор не везде я могу использовать флексбокс, потому что как раз то, что вы сказали — IE9 и IE8.
У нас, например, на недвижимости это было таким стоппером.
Но многое из того, что я исследовал и о чём я говорил пять лет назад, — оно сделано.
И я очень рад, что в принципе ещё года полтора и можно будет забыть про старые IE, и флексбокс будет повсеместно, смело, не в каких-то внутренних интерфейсах, а в продакшене, в бою.

**Вадим.**
Это действительно очень древний доклад.
Я даже не помню его названия честно говоря.

**Слава.**
«CSS3. Будущее механизмов раскладки».

**Вадим.**
Да, точно.
У нас есть [видео этого доклада](https://youtu.be/ZEd7bEqe6iI "Будущее механизмов раскладки") из Москвы и из Питера по-моему.
Один из первых WSD, которые мы записывали на видео, может быть даже транслировали видео.
Доклад такой про Grid Layout, когда его ещё Алекс Магилевский писал сто лет назад.

**Слава.**
Да, и про Template Layout, где можно ASCII-графикой лейаут рисовать.

**Лёша.**
Это, кстати, забавная была спека про ASCII-графику.
Вы представляете себе, что вот сейчас верстальщики верстали бы с помощью ASCII-графики?
По-моему это было бы такое весёлое безумие.

**Вадим.**
Ну, сейчас ещё в Grid Layout остались элементы ASCII-графики.
Там можно указывать, как будут располагаться разные части макета именно с помощью псевдо-графики.
То есть, какая-то часть этого Template Layout осталась в гридах.

## 06:19 Определение `<article>`

**Лёша.**
На этой неделе ещё было интересное предложение в спецификацию.
Стив Фолкнер [предложил изменения](http://stevefaulkner.github.io/article/ "Rewrite of the article element definition") для элемента `<article>` в HTML.
Это такой достаточно противоречивый элемент.
Вообще, там всего лишь два-три абзаца и в текущей спецификации, и том, что предложил Стив Фолкнер.
Но что можно заметить?
Стив Фолкнер явно указал то, что в элементе `<article>` должны быть заголовки.
Причём он явно указал, что заголовки должны начинаться со второго уровня.
То есть он не подразумевает, что в `<article>` могут быть `<h1>`.
Так же раньше в элементе `<article>` в текущей спецификации было сказано о том, что `<article>` можно использовать внутри друг друга, а Стив Фолкнер решил это убрать.
Не знаю, к чему это приведёт, потому что там нет явного запрета, но и явного разрешения тоже нет.

**Вадим.**
Раньше спецификация рекомендовала, мол если у вас есть статья, то основное тело статьи — `<article>`, если к ней есть комментарии, то каждый комментарий — это по сути `<article>`.
Там был пример, как `<article>` вложен друг в друга.
Это немножко запутывало, потому что казалось, что отдельный комментарий и всё тело статьи — это не равновесные вещи.
Ну в общем, если вам интересно заниматься семантикой и разбираться в том, как работают элементы в HTML5, рекомендуем ознакомиться с предложением Стива Фолкнера.
Но если вы считаете это абсолютно бесполезным, то хотя бы используйте элемент `<main>`, он обозначает главное содержимое на странице, заворачивайте основную навигацию на сайте в элемент `<nav>`, и так далее.
Чтобы у средств доступности были шансы разобраться в вашем коде, даже если они его не видят.

**Лёша.**
Кстати, по поводу `<main>` тоже интересно.
В спецификации был такой пункт, что если у вас `<article>` — это вообще весь документ, который вы показываете, то нужно использовать не `<article>`, а `<main>`.
Ну, так вот Стив Фолкнер решил убрать из спецификации этот пункт про `<main>` в качестве `<article>`.
Я не знаю, с одной стороны у него текст читается лучше, более понятно про `<article>`, способы его применения стали понятнее, но некоторые такие моменты, которые вроде бы как важные, убраны.

**Вадим.**
Мне кажется, тут вопрос исключительно в том, что когда ты будешь читать только новую версию, ты в общем-то не будешь сомневаться.
Она, мне кажется, чище и понятнее.
И этого не хватает описаниям многих семантических элементов в HTML5.
Люди по прежнему спорят, а поскольку в споре не получается явных победителей, в общем-то все опускают руки и верстают `<div>`, `<div>`, `<div>`.

## 09:12 Висячая пунктуация

**Вадим.**
Самой интересной новостью на этой неделе лично для меня была поддержка [висячей пунктуации в WebKit](https://twitter.com/grorgwork/status/705546895528034305).
Я знаю, есть разные полярные мнения на тему того, что такое висячая пунктуация и нужна она или нет.
Но вот, какие-нибудь ребята вроде «Бюро Горбунова», и другие увлечённые любители типографики сейчас руками реализуют все эти свисающие кавычки, запятые и так далее.
А теперь появилась первая реализация висячей пунктуации в браузере.
Потому что спецификация CSS Text Module Level 3 подразумевает много разных интересных свойств.
И один из вариантов свойство [`hanging-punctuation`](https://www.w3.org/TR/css-text-3/#hanging-punctuation).
Там можно указывать, где оно будет свисать: в начале строки, в конце строки, насильно в начале строки, насильно в конце строки — в общем все вариации.
Это, с одной стороны, вещь, которая приближает нас к бумажной типографике, к таким самым-самым хорошим её образцам.
С другой стороны — кажется лишней.
Поэтому всё зависит исключительно от вашего вкуса.
Но на мой взгляд, если вы готовы озаботиться прямо вот хорошими текстами — мы в прошый раз говорили про типографику, что для веба было бы хорошо заниматься типографикой больше — вот если вы типографикой увлекаетесь, то теперь вам не придётся крутить всякие хаки скриптовые или просто вёрсточные для того, чтобы вытаскивать эти несчастные кавычки.
Кстати, список того, что можно вытащить за пределы абзаца, так называемой полосы набора, описан в спецификации.
Там есть специальная заметочка, что если авторы браузеров собираются добавлять новые элементы, можно или нужно свешивать их, пусть они свяжутся с авторами спецификации и внесут, потому что не хотим сюрпризов.
Указывать, что именно свешивать нельзя.
Список зашит, и он зашит на основе правил типографики.

**Слава.**
Тут интересно посмотреть, как это работает с разными языками.
Мне кажется, я профан в этом деле, но мне известно, что в разных языках разные символы и вообще разные правила существуют.

**Вадим.**
Я бегло проверил — на первый взгляд вроде всё в порядке.
Свешиваются не только английские лапки, но ещё и французские, кириллические ёлочки.
Тире не свешивается, потому что нет таких правил для свешиваний тире.
В общем, у ребят из W3C обычно всё в порядке с локализацией и поддержкой языков кроме латиницы.
Раньше конечно всё было сложновато, но сейчас гораздо лучше.
Поэтому я думаю они учли многие системы письменности.

**Слава.**
И второе, что я хотел узнать — ты не смотрел, как это аффектит производительность отрисовки страницы.
Потому что может быть они сделали очень крутое дело, но твоя страница начинает дико тормозить из-за этого.
Нужно просто удостовериться, что всё окей.

**Вадим.**
Надо естественно тестировать, причём на больших текстах с кучей кавычек и знаков препинания.
Я тоже открыл инспектор и посмотрел, как там всё рисуется — на первый взгляд вроде бы не заметно никаких проблем и тормозов.
Ну естественно нужно ещё проверять.
И это только в ночных сборках WebKit.
Естественно это всё дойдёт до Safari я думаю к осени, может быть когда выйдут новые версии macOS и iOS.
Но выглядит неплохо.
И опять же, можно любыми CSS-свойствами убить любую страницу, если хорошенько их накрутить.
Но если вы знаете, что вы делаете, и если вы понимаете, что вы можете пожертвовать какими-то там милли- или нано-секундами отрисовки, но у вас будет всё красиво свешено — почему бы нет.
Опять же это всё можно делать для врезок, для каких-то вступительных абзацев.
Не обязательно это делать вообще для всего текста на всех страницах.

**Лёша.**
Кстати, если вы хотите прямо сейчас использовать висячую пунктуацию без этих замечательных свойств, вы можете воспользоваться например замечательным [Типографом Муравьёва](http://mdash.ru/).
Он умеет автоматом все эти кавычки выносить.

**Вадим.**
Ну да, а есть ещё полифил [Gosh Hang It!](https://github.com/liamdanger/gosh-hang-it), который вышел одновременно с реализацией в WebKit.
Автор по этому поводу пошутил очень забавно.
Тоже есть возможность всё это свешивать прямо сейчас.
Так что если вам это нравится и вы любите делать красиво и интересно, то в общем-то вперёд, пробуйте — полифилы есть.

## 13:47 Обновился CSSO

**Вадим.**
Другая новость на прошедшей неделе, которая меня порадовала — вышел новый релиз оптимизатора CSS — [CSS-Optimizer 1.6.0](https://github.com/css/csso/releases/tag/v1.6.0).
В этом релизе оптимизатор поддерживает карты кода, чтобы можно было понять где у вас в сжатом коде что за какой селектор отвечает, чтобы всё прокидывало правильно.
В общем, карты кода — это полезно для разработки.
А ещё оптимизатор ускорился от 1.5 до 2 раз.
То есть довольно сильное ускорение.
Что интересно, CSSO сейчас разрабатывает Рома Дворнов из Avito, а появился он когда-то в Яндексе.
Слава когда-то разработал такой инструмент, как CSS-Comb, и в общем-то должен знать историю этого парсера CSSO из Яндекса.
Расскажешь?

**Слава.**
Да, я могу немножко сказать.
На сколько мне известно, Серёжа разрабатывал CSSO, как некий базовый парсер CSS, чтобы на выходе был AST, чтобы можно было этот AST подавать на другие инструменты — такая была изначальная задумка.
Потом как-то это плавно переросло в то, что вроде бы сам по себе просто парсинг в AST никому не нужен, и начали делать оптимизацию — это собственно первая задача, которая стояла — так появился CSSO.
И в какой-то момент это всё появилось в OpenSource.
Потом, я так понимаю, Рома, добрый человек, пришёл, подхватил это дело и начал реализовывать свои идеи.

**Вадим.**
Ну, это не совсем так.
Рома не просто оказался добрым человеком.
Они в Avito у себя искали способ, не просто сжимать CSS, а делать с ним что-то дополнительное, поскольку собственно в CSSO был правильный AST, то с помощью него можно было что-то сделать.
В какой-то момент ребятам стало жать, и они начали дописывать какие-то свои вещи в него.
Затем это всё вернули в оригинальный репозиторий.
А потом получилось, что без каких-то мажорных изменений ничего с ним не сделать, и Рома попросился мэйнтейнить.
И сейчас он активно развивает CSSO.
У них миллион загрузок в месяц.
Почти в шесть раз всё выросло из плавной грустной кривой.
Сейчас большой пик и CSSO снова становится популярным.
Не знаю как вы, но я свои проекты снова вернул на CSSO.
Когда-то я его использовал, как оптимизатор, потому что он умел делать структурную оптимизацию, и это давало интересный выигрыш.
Структурная оптимизация отличается от обычной тем, что CSSO не просто убирает пробелы и точки с запятаой, а если он находит те свойства, которые можно безопасно сгруппировать, переставить местами и так далее — он делает это.
Там не хилый алгоритм за этим всем стоит.
Но благодаря структурной оптимизации это всё становится ещё лучше.
Поэтому CSSO я снова вернул в свои проекты.

**Лёша.**
Это вот, кстати, интересно.
Я пробовал его очень давно, когда им ещё занимались в Яндексе.
И напоролся на несколько очень критичных ошибок — он как-то линейные градиенты для меня не правильно уменьшал и в общем ломал мне вёрстку.
После этого, так как не было времени в этом всём разбираться, CSSO меня потерял.
Потому что все минификаторы плюс-минус несколько байт делают одно и тоже, ну и какой смысл было с ним работать.
Сейчас я вижу, что CSSO правда возобновил свою активную деятельность.
Я смотрел [доклад Ромы Дворнова про CSSO](https://youtu.be/KgF0gGW_Bk0), это было на Web Standards Day в Москве.
И сейчас я всё больше и больше склоняюсь к тому, что может быть попробовать.
Но это как с Internet Explorer — этот старый бэкграунд как-то заставляет пока чуть-чуть подождать.
Но ребята развиваются, это очень здорово, и наверно правда стоит попробовать.

**Вадим.**
Когда ещё им мало кто занимался, он у меня самого в коде поломал `@keyframes`, `animation`, градиенты тоже какие-то.
Я посмотрел, что оно не чинится и перешёл на другой.
Это урок для OpenSource-проектов: если вы что-то ломаете, то очень легко потерять пользователей.
Я очень рад, что к хорошему оптимизатору пришёл хороший разработчик.
Так что будет всё хорошо, судя по всему.

## 18:37 Быстродействие

**Лёша.**
На этой неделе ещё было несколько новостей, которые меня привлекли.
Во-первых, на SmashingMagazine [вышла статья](https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/ "Preload: What Is It Good For?") про новый тип линков — `preload`.
Это такая достаточно интересная штука.
У нас уже до этого была похожая вещь — это `prefetch`.
И ещё один, я не помню, как он называется.
`Prefetch` нам позволял просто сделать запрос к DNS и с ним уже чуть поработать, чтобы при следующем запросе к этому домену у нас всё было быстрее.
А `preload` делает очень крутую штуку, он позволяет вам определить ресурсы, которые вы хотите загрузить на свой сайт, но позже, асинхронно в принципе.
Ребят, вы вообще смотрели, читали эту статью?
Как вам примеры, которые были показаны?

**Вадим.**
Я прочитал статью.
Про этот `preload` ещё раньше говорил Джейк Арчибальд на предыдущих неделях.
Мне больше всего понравилось, что не просто даётся ресурс, который предзагрузится, а упоминается в какой роли этот ресурс загрузится.
Можно указать, что мол «предзагружаем это, как…»
Там есть атрибут `as`, и написано, допустим, `as="script"`, `as="font"` и другие варианты.
То есть можно указать, каким образом ресурс обработается.
В принципе примеры довольно хорошие, они помогают лучше контролировать модульность.
Не просто бабахнуть всё в один скрипт или файл стилей, а разбить загрузку на этапы.
И другая интересная особенность — то, что подобное поведение можно указывать не только с помощью `<link>` в `<head>` HTML-документа или в `<body>`, в зависимости от того, какое вам поведение нужно, а ещё можно указывать заголовки, и в скриптах тоже самое делать.
Довольно гибкий механизм, который меняет немножко подход к модульности.

**Лёша.**
Мне понравилось два чертовски хитрых примера.
Это работа со шрифтами, когда мы можем указать `<link rel="preload">`, там ссылку на ваш шрифт в woff2, например, сказать ему, что это шрифт — `as="font"` и использовать такую штуку, которую раньше в тегах `<link>` нельзя было использовать — использовать у него взаимодействие с событиями.
То есть можно указать `onload` прямо в теге и что-то сделать, когда этот ресурс загрузится.
Со шрифтом можно было что сделать?
Например, вы описали какие-то ваши внешние шрифты, допустим это будет шрифт с названием Muller.
Вы можете в `<body>` у себя указать, что `font-family` вы используете `Arial`.
А если у вас есть какой-то класс у `<body>`, вы можете переопределить этот `font-family` на `Muller, Arial`.
И этот класс можно легко добавить в этом атрибуте `onload`.
Можно в `onload` найти `<body>` и добавить ему `class="muller"`.
Таким образом вот эти все способы асинхронной загрузки шрифтов с помощью JS переходят в один этот тег.
Это всё равно выглядит как хак, потому что лучше всего использовать свойство `font-display`, когда оно появится.
Но тем не менее это такой прикольный хак.

А ещё очень классный хак, который я увидел, который можно использовать с помощью этого `preload` — это добавлять какие-то стилевые файлы асинхронно.
И вставлять их на страницу, когда они загрузятся.
То есть, можно с помощью `<link rel="preload">` указать какой-то стилевой файл, например для подвала или какой-нибудь галереи, которая у вас позже подгружается, например `/galery.css`.
Сказать ему, что это стиль, то есть `as="style"`.
И в `onload` сделать вообще очень магическую вещь — можно сказать `this.rel=stylesheet`.
То есть мы у этого тега подменяем его `rel` вместо `preload` на `stylesheet`, и этот стиль автоматически применится к странице.
Таким образом мы с помощью одного тега можем сделать асинхронную загрузку стилей.

**Вадим.**
То есть, если мы допустим в шаблоне тут же вместе с компонентом галереи какой-нибудь вставим эту штуку, то она в общем-то сработает там где мы её вставим.

**Лёша.**
Причём она не заблокирует загрузку.
То, что мы говорили про статью Арчибальда про то, что они меняют поведение атрибутов `<link>` в `<body>`, то оно блокировало отрисовку всего контента после этого тега.
А в этом случае оно вообще не блокирует отрисовку контента.

**Вадим.**
Это конечно круто.
И в общем-то это всё можно ожидать в вечно-зелёных браузерах на основе Chromium, поэтому это всё в общем-то достаточно скоро появится в ваших руках.

**Слава.**
Можно я попробую поругать эту фичу?
Представим себе ситуацию, что вы писали такой `onload` и написали, что вы ждёте загрузки какого-то шрифта.
Получается, что помимо `onload` вам нужно написать ещё некий обработчик `onerror`.
Потому что, если ресурс не загрузился, то возможно нужно тоже как-то отреагировать, а вы ждёте.
Мы живём не в идеальном мире, и возможно интернет-соединение на столько медленное, что вы просто не дождётесь.
Либо этот ресурс удалённый — третья сторона — просто не ответил.
То есть, тут возможны какие-то варианты.
Мне кажется, это довольно опасная техника с `onload`.

**Вадим.**
Было бы конечно интересно понять, как этот `onload` работает, как он связан с глобальным `onload` для документа, или это собственный `onload` непосредственно `<link>`.
Скорее всего второе.
Есть ли там `onerror`.
Да, не всё так однозначно.

**Лёша.**
А мне кажется, что это классический, идеальный пример прогрессивного улучшения.
Как я сказал, у нас уже есть дефолтный шрифт для нашей страницы.
И если не загрузится этот замечательный кастомный шрифт — ничего страшного, весь контент доступен.

**Слава.**
На самом деле, ты можешь получить какую-то JavaScript-ошибку, если что-то пойдёт не так, и произойдёт не загрузка файла шрифта, а просто ошибка 404 или ещё что-то не то.

**Лёша.**
Ну, это надо смотреть конечно же, как это будет реализовано.
Но мне кажется, что там должно быть всё более-менее.
Ведь на самом деле когда в JS ты используешь какой-нибудь `newImage`, указываешь ему `src` и потом ловишь его в `onload`, у тебя в `onload` не попадает событие, если что-то с картинкой случилось в момент загрузки.

**Слава.**
Ну это опять в идеальном мире, если сервер тебе ответил действительно кодом 404.
А если вдруг что-то пошло не так и сервер ответил 200, но там не то, что ты ожидаешь…
В общем, я хотел сказать, что из всей этой истории полезно вынести хороший урок, что когда ты ждёшь асинхронной загрузки чего-то, то нужно всегда обрабатывать как успех, так и не успех.
И как только у вас есть `onload`, у вас как у разработчиков должен возникать звоночек небольшой о том, а что будет когда `onerror`.
Это должно идти просто рука об руку, сразу.
Это очень хорошая практика.

**Вадим.**
Ну, как вы поняли, у нас сегодня Слава играет роль практика.
Мы тут с Лёшей мечтатели по новым спецификациям.
А Слава нас очень хорошо приземляет.

**Лёша.**
Нежно так приземляет.

**Слава.**
Я просто пытаюсь создать какой-то диалог.

## 26:17 HTTP/2

**Лёша.**
Потихонечку можно перейти к следующей новости.
На Хабре была [статья](https://habrahabr.ru/company/selectel/blog/278167/ "HTTP/2: готовимся к переходу") в блоге компании Selectel про HTTP/2.
То что ты сказал, Вадим, мы часто собираем все стили в один файл, скрипты в один файл, только потому что мы работаем с HTTP/1.1, который быстрее и лучше всего работает именно так.
Но явно в этом году, я не думаю, что все, но кто-то, кто быстрее всех адаптируется, кто early adopter, потихонечку будут перелезать на HTTP/2, потому что всё для этого в принципе готово.
Браузеров все последние версии работают с HTTP/2.
Сервера все самые популярные — это Apache, NginX — они тоже уже поддерживают HTTP/2.
То есть, потихонечку всё готовится к такому переходу.
Но самое важное, что нужно подготовить, если вы хотите работать по HTTP/2, вам нужно перевести свой сайт на HTTPS.
Это на самом деле самая большая и сложная операция в этом переходе.
У нас сайт HtmlAcademy уже давно на HTTPS, но свои личные сайты я до сих пор не перевёл на HTTPS.
А вы как?
Ну, я знаю, что Яндекс то наверняка на HTTPS работает, правильно же?
А ваши личные сайтики вы уже переводили на HTTPS?

**Вадим.**
У меня пока руки не дошли переводить на HTTPS какие-то свои проекты.
У меня большинство собственных сайтов на DreamHost.
На сколько я понимаю, у них можно всё это сделать.
Но нужно немножко повозиться.
В общем грубо говоря, это забота не столько верстальщиков или фронтендеров, сколько сисадминов.
Но верстальщики должны их пинать.
У проектов «Веб-стандартов» сисадмин Миша Баранов.
И он с большим удовольствием перевёл какие-то наши сайты на HTTPS, используя Let’s Encrypt.
А мои собственные проекты — надо конечно озаботиться, потому что как минимум это модно, ребят.

**Лёша.**
Ну и вроде как чуть-чуть безопасно.
Хотя что там на личном сайтике.

Что ещё можно сказать про HTTP/2?
Если у вас сайт уже готов, если он уже работает по HTTPS, то переход на самом деле достаточно простой — вы просто в своём конфиге чуть-чуть меняете то, как отдаётся ваш сайт.
Ну, это конечно не для фронтендеров.
А для фронтендеров что важно?
Важно то, что у нас появился способ отдавать куски статики по чуть-чуть.
То есть не делать бандлы из стилей, не делать бандлы из JS, а подгружать те куски, которые нужны этой странице.
А то, знаете, часто у нас индексная — главная страница, и на неё приезжает большой стилевой файл, на котором куча-куча всего того, что не используется на этой странице.
Вот от этого можно будет потихонечку отходить, потому что HTTP/2 очень хорошо работает с большим количеством ресурсов.

Так же стоит сказать о том, что если HTTP/2 позволяет работать с большим количеством маленькой статики и быстро её загружать — это не значит, что вы откажетесь от своих привычных способов сборки.
Один из примеров — это спрайт какой-нибудь.
Вот у вас есть сайт, который подменяет картинки при наведении.
Пускай это даже HTTP/2.
Если вы положите эти две картинки, как обычные ресурсы, и при `:hover` будете их менять, то пользователь увидит этот не очень красивый эффект, когда вы наводитесь на иконку, а с ней ничего не произошло, или она наоборот пропала, и там белое пустое место пока загружается другая иконка.
Такие вещи HTTP/2 нам конечно не помогает решить, и вам всё равно скорее всего нужны будут спрайты или что-то похожее.
Но с HTTP/2 точно, и с этими всеми прелоадами, с этими всеми изменениями линков в `<body>` вы точно сможете совсем по другому взглянуть на компонентность вашей страницы.

**Вадим.**
Я по-прежнему большой любитель того, что всё должно просто работать.
То есть, вы верстаете, как хотите, а браузеры или протоколы делают за вас всю работу и делают так, чтобы сайт загружался максимально эффективно.
Но, если вам где-то начинает жать, и вы понимаете, что вы можете сделать быстрее и лучше, тогда вам стоит узнать, как работает протокол сайта, которого вы разрабатываете, как работают браузеры и так далее.
Я не рекомендую вам заниматься преждевременными оптимизациями — вот суть моей мысли.
А если вы знаете, как и что вы делаете, то вперёд, изучать все эти подробности.
Современный верстальщик пожалуй должен понимать, как работают протоколы, и какие особенности его вёрстки можно оптимизировать, или какие особенности оптимизировать не стоит, потому что за него это сделает новый протокол или браузеры сами уже умеют это делать.

**Слава.**
В эту тему можно добавить то, что на прошедшем недавно Я.Субботнике был [доклад](https://youtu.be/n3gtj7veL3I?t=17670 "Не гзипом единым, видео с Я.Субботника") Григория Мостоловицы.
Он назывался «Не гзипом единым».
Там как раз рассматривались алгоритмы сжатия веб-данных.
И если вам интересна эта тема, то думаю вам будет интересно посмотреть этот доклад.

**Вадим.**
Григорий не просто рассказал доклад на Я.Субботнике.
Он сейчас ведёт [Твиттер Frontend Performance](https://twitter.com/perfception).
Довольно интересный дайджест всего самого интересного, что происходит по быстродействию, перформансу в основном конечно в англоязычной сфере, но ещё и в русскоязычной тоже.
Он специализируется на этом деле в Яндексе, поэтому я бы рекомендовал подписаться.

## 32:37 Блютус в вебе

**Вадим.**
Так же на этой неделе мой коллега Шветанк Диксит опубликовал [статью про Web Bluetooth](https://dev.opera.com/articles/web-bluetooth-intro/ "An introduction to the Web Bluetooth API").
Это новое API, которое позволяет вам прямо из JavaScript, прямо из браузера связываться с устройствами, которые поддерживают соединения по Bluetooth, отправлять на них сообщения, в общем связываться и управлять ими.
У нас был стенд на выставке Mobile World Congress в Барселоне недавно.
Там ребята со специальной сборкой Opera для Android сделали пульт, который управляет смешным блютусным роботом BB-8 из последних «Звёздных войн», который ездил там по стенду, и на котором можно было лампочки переключать прямо из браузера, прямо из обычного веб-приложения.
Это что-то новое.
У меня самого ещё руки не доходили поиграть именно с железным представлением веба.
Есть всякие фреймворки, которые позволяют программировать на Node.js для всяких кофеварок, пылесосов и других маленьких компьютеров типа Arduino и так далее.
А это немножко другая история, когда у вас есть уже знакомое JavaScript-API, которое работает прямо в браузере, не обязательно это Node.js, и вы можете достучаться до живых устройств.

**Лёша.**
Кстати, я посмотрел статью на портале DevOpera.
Важный момент — эта штука, эта спецификация работает по HTTPS.
Это просто важное замечание к предыдущей новости.
То есть, ребята, переводите сайты на HTTPS скорее.

## 34:18 Про SVG по-русски

**Вадим.**
В июне прошлого года Джейк Гилсофф опубликовал интересное руководство SVG в вебе, больше напоминающее книгу, такую длинную-длинную портянку с красивыми картинками обо всём, что вам нужно знать про SVG.
И для верстальщиков и для дизайнеров не плохо подходит.
Мы писали об этом новость.
А вот совсем недавно Дима Лебедев и Катя Турапина для HtmlAcademy [перевели это всё на русский язык](https://svgontheweb.com/ru/ "SVG в вебе. Практическое руководство").
И теперь всё стало гораздо проще и понятнее для русскоязычной аудитории.
Лёша, расскажи про этот перевод.

**Лёша.**
Мы вообще любим вносить какой-то вклад в сообщество и SVG on the Web — это как раз такой пример.
Всегда, когда видим какие-то хорошие руководства, или интерактивные штуки, которые лежат в OpenSource, которые можно форкнуть и улучшить или перевести — мы стараемся это делать.
Почти всегда это мы делаем не своими силами.
У нас есть большое количество наставников, которые работают с нами на интенсивах.
Мы всегда им открыто рассказываем о том, что — ребята, вот крутая штука, никто не хочет перевести или как-то посодействовать?
Когда вот это руководство появилось, я в июле, а может быть даже и в июне, говорил — ребята, никто не хочет это перевести?
И тогда Дима Лебедев вызвался — да, давай я буду.
На перевод понадобилось по сути полгода.
Ну, на самом деле не на сам перевод.
Перевод длился в течении двух-трёх дней.
Но, так как у всех работа, свои жизненные штуки — в итоге перевод появился только совсем недавно.
Ему помогала в этом Катя Турапина, она у нас учится сейчас на интенсиве продвинутом.
Ребята проделали просто гигантскую работу, потому что руководство и правда большое.
Нас тут в социальных сетях упрекнули, типа я почитал это руководство и что-то не увидел никаких новых знаний для себя.
Да, это и правда руководство для начинающих.
Оно не очень глубокое про SVG, но оно раскрывает все-все-все особенности SVG в разном использовании, как оно выглядит и где.
То есть, если вы только встретились с SVG или может быть вы всегда работали с SVG по типу обычных картинок, вроде JPEG и PNG — типа это картинка, я отрываю её в Photoshop или Illustrator, что-то с ней делаю, экспортирую, и вот он есть.
Если вы работаете с SVG именно так, а я знаю, что большинство веб-разработчиков работает с SVG именно так, то почитайте это руководство, вам станет на много понятнее.
И вообще, SVG это круто.
Его надо как-то продвигать что ли.
Раскрывать его с более человеческих сторон, что вообще-то это не просто картинки, вы можете кодить SVG — это нормально.

## 37:26 БЭМ и шаблонизация

**Вадим.**
У нас в подкасте было маловато PostCSS и БЭМ — самых горячих топиков этого сезона, и предыдущих на самом деле тоже.
Мы в этот эфир позвали Славу Олиянчука, который на Я.Субботнике недавно рассказал доклад про шаблонизатор BEM-XJST.
И решили поговорить немножко собственно про БЭМ, про шаблонизацию и вот это всё.

**Лёша.**
Я сегодня поиграю в роли такого простого новичка, который только увидел БЭМ допустим, который верстает сайтики на заказ.
И вроде как все говорят вокруг: БЭМ, БЭМ, БЭМ.
Вроде все профессионалы говорят, как это круто.
И вот я такой новичок, я слушаю всех профессионалов и тоже хочу понять, но ничего не понимаю.
В итоге я скорее всего прийду к тому, что БЭМ для меня — это просто нейминг в CSS.

**Слава.**
Я могу рассказать недавний случай.
Что-то меня чёрт занёс на сайт React, где выложено видео на разных языках.
Я обнаружил одно единственное видео на русском языке, в котором в секции вопросов докладчику задают вопрос из зала о том, пробовали ли вы методологию БЭМ.
До этого человек 40 минут рассказывал про React, и у меня не вызывало никаких смущений, что он действительно в этом разбирается.
Но на вопрос про БЭМ он сказал, что он пробовал эту методологию, но она больше про CSS, поэтому она дескать не подходит.

Вот на этом месте я нажал «Стоп» и фактически выпал вообще.
Это огромный такой бич, который преследует БЭМ.
И тут уже даже не важно, откуда родился этот стереотип.
Важно, что с этим делать в настоящее время.
Да, действительно именование классов по БЭМу со всеми этими чёрточками и подчёркиваниями — это отличная точка для входа.
Но это не конец и ни в коем случае не исчерпывающая характеристика БЭМа.
Это просто начальная точка, с которой очень хорошо новичку понять, что же делать, чтобы прикоснуться к БЭМу, условно говоря.
Да, вы можете открыть новый файлик common.css и начать писать там свои стили с таким неймингом.
Потом, когда вашего кода становится очень много, вы можете это разнести по разным файлам в файловой системе и затем собирать это чем угодно, хоть Grunt, хоть Gulp.
Но это только в рамках слоя про CSS, про то, как ваши штучки будут выглядеть.
А есть ещё слои про то, что это за штучки — то есть данные.
И есть ещё слои про то, как ваши штучки будут себя вести — это про клиентский JavaScript.
И собственно вся методология масштабируется на разные вот эти слои.
Есть уровень данных.
Допустим типичный какой-нибудь проект.
Лёша, когда вы делаете в HtmlAcademy, у вас есть же какой-то финальный экзамен или что-то?
Вы в качестве задачи что используете?

**Лёша.**
На интенсивах у нас финальным проектом является полностью свёрстанный макет.

**Слава.**
А макет чего?
Это интернет-магазин?
Или это просто какой-то сайт визитка?

**Лёша.**
Разные макеты.
Самый смешной называется Barbershop Borodinsky — это сайт салона этих-самых, которые бороды бреют.

**Слава.**
То есть, это просто сайт некой компании?

**Лёша.**
Ну, да.

**Слава.**
Чтобы сделать такой сайт, в данном случае вы используете вёрстку.
Для вёрстки у вас есть как минимум два слоя.
Слой, как ваш сайт будет выглядеть — это скорее всего большой упор на стили.
И возможно есть какое-то поведение.
Возможно есть какая-то форма заказа.
Возможно есть какие-то снипеты интерактивные, которые можно положить в корзину и пойти дальше выбирать что-то.
Возможно есть там какая-то форма авторизации.
Ну, то есть, какая-то бизнес-логика.
А есть ещё слой про данные — это собственно та информация, которая будет отображена на странице.
Если убрать всю эту мишуру про то, как она выглядит и как она себя ведёт, то данные всё равно есть.

БЭМ предлагает такой метод работы со всеми этими вещами, со всеми этими слоями в едином стиле.
А стиль собственно говоря очень простой и заключается в том что вы изолируете какую-то вещь, какой-то блок, какую-то вашу штучку.
И изолированно от остального контекста она существует, работает, её можно тестировать, она предсказуемо свёрстана, она предсказуемо себя ведёт и отображается вот так, как она отображается.
Собственно про это БЭМ.
Поэтому очень долгое вот это мусоление про стили оно наверное нанесло такой негативный отпечаток.

**Лёша.**
Это всё и правда выглядит интересным.
Но я вот продолжу со стороны фрилансеров и веб-студий смотреть на БЭМ.
В одно время БЭМ очень пушили на рынок, он нужен всем и так далее.
Ну, возможно сообщение было и не такое, но получилось именно так.
Конечно же все хотели, потому что всегда, когда рассказывают о какой-то технологии, стараются показать её хорошие стороны.
У БЭМа и правда есть огромное количество хороших сторон.

И вот, я такой новичок делаю сайты на поток.
Смотрю на БЭМ и хочу попробовать.
Беру его в свой проект.
А дальше я наталкиваюсь на огромное количество мне не понятных слов: BEMTREE, BEMHTML, ENB.

**Вадим.**
Подождите-подождите, а как же уровни переопределения?
Мой любимый базворд бэмовский.

**Слава.**
Мне кажется, что всё нужно постепенно делать.
Всё так же, как у вас строятся курсы в HtmlAcademy.
Сначала есть какой-то базовый уровень,
С чем человек может столкнуться прямо на входе — это то, как свои сущности в вёрстке поименовать.
Если вы уже прошли этот этап, то дальше начинаются просто другие этапы, которые немножечко раскрывают другие аспекты.
Я начал бы с того, что сказал, что есть как минимум два важных аспекта.
Первый аспект — это то, что если вы чётко уверены в том, что у вас есть макет и макет никак не изменится, то имея какой-то опыт вёрстки скорее всего вы сталкиваетесь с типичными задачами сделать примерно одно и то же, но чуть-чуть по-другому это раскрасить.
В данном случае вам может пригодиться такая вещь, как библиотека.
То, что говорит Вадим — уровни переопределения.
Ничего в этом такого страшного нет.
Просто вы подключаете какую-то общую библиотеку, которая уже реализует для вас какие-то готовые вещи.
Точно так же как вы подключаете Bootstrap и потом его правите возможно даже прямо по живому, а возможно где-то в своём файле после него.
Так вот это — примерно такие же самые уровни переопределения.
У вас есть Bootstrap, как базовый уровень, и у вас есть что-то, что вы пишите своими руками — это проектный уровень.
Мне кажется, ничего в этом термине страшного нет.

**Лёша.**
Ну, смотри.
С бутстрапом действительно хороший пример.
Потому что я беру этот огромный CSS-файл, кладу его к себе в проект.
И, допустим, кладу ещё один CSS-файл, в котором что-то переопределяю.
А может быть переопределяю прямо в Bootstrap, если я такой бесстрашный.
И всё.
Это очень привычно тому, что верстальщики делают каждый день.
А поднять окружение, чтобы БЭМ работал полностью, то есть с шаблонизацией и прочим, — это вообще-то на самом деле не тривиальная задача.
Она конечно же посильна.
И те, кто познают дзен в этом, наверно чувствуют себя очень крутыми.
И это действительно очень круто.

**Слава.**
Погоди.
Сейчас может создаться впечатление, что у нас такая бинарная ситуация: либо у тебя CSS-именование, либо у тебя прямо вот полный стек БЭМ-технологий.
Но на самом деле это не так.
В этом вся и фишка, что ты можешь использовать любые модули отдельно.
И в общем-то на практике так и получается.
Как правило, тебе очень повезло, если ты пишешь проект с нуля.
Но по факту, скорее всего у тебя уже есть какой-то код.
И ты находишься в ситуации, когда ты хочешь его привести в порядок, либо доделать, или привести в порядок, а потом доделать.
То есть, ты уже работаешь с существующей кодовой базой.
И чтобы двигаться дальше и не вязнуть.

Есть такое понятие _технологический долг_.
Когда ты долго бежишь вперёд, у тебя нарастает технологический долг.
Тебе нужно решить какие-то вопросы, которые ты оставлял без внимания в угоду своей работе.
И в один прекрасный момент наступает такая ситуация, когда ты просто начинаешь прибираться в своём собственном проекте.
Это признак того, что ты сильно задолжал.

А мы сейчас говорим про то, что ты можешь потихонечку переписывая части своего проекта, пускай она даже небольшой, пробуя либо шаблонизатор отдельно, либо раскладывая свой CSS по файликам и папочкам, наводить там порядок.
От этого ты получишь мало того, что чистоту в одном проекте, так ещё и побочные профиты.
Как то, что ты можешь общие части отделить и потом просто забыть про это.
То есть, не делать второй раз одну и ту же работу.

## 48:22 Про шаблонизатор BEM-XJST

**Вадим.**
Слава, а расскажи немного про одну из частей фулстека БЭМа.
Там есть всякие i-BEM, BEMJSON, BEMHTML.
А есть ещё BEM-XJST.
Собственно ты про него [рассказывал доклад](https://youtu.be/n3gtj7veL3I?t=21268 "Видео доклада про BEM-XJST").
Это на сколько я понимаю шаблонизатор, который можно использовать отдельно, если у тебя Node.js.

**Слава.**
Это шаблонизатор, который [написан на чистом JS](https://github.com/bem/bem-xjst "Репозиторий проекта BEM-XJST"), и можно его использовать не только на фронтенде, где у тебя Node.js, но и в браузере.
То есть, ты пишешь шаблоны на JS и получаешь результат.
Есть одна особенность этого шаблонизатора, о которой мне кажется я в докладе не успел рассказать, но в качестве такого бонус-трека мне бы хотелось рассказать.
Если вы что-то прототипируете, то как правило вам приходится верстать прямо на живую.
Вам приходится эмулировать какие-то фейковые данные, и при этом писать шаблоны.
Допустим, вы хотите показать заказчику результат вашей страницы во всех состояниях.
Бывает же такое?
Довольно часто.
У вас есть какой-то блок какого-нибудь товара, который _заказан_ и _не заказан_, сейчас _есть на складе_ или _отсутствует_, но _доступен для заказа_.
Есть некая вариативность состояний ваших каких-то блоков, отдельных частей страницы.
И вам нужно разверстать вот эту статику во всех состояниях и показать заказчику.
Заказчик согласится и дальше это пойдёт какому-то программисту, который прикрутит это на движок.

Так вот, с помощью BEM-XJST это очень удобно делать, потому что, как это не странно, меняя данные на вход вы можете получать разные состояния вашего макета.
Допустим, у вас есть один шаблон, написанный на товар, который _новинка_, и другой шаблон, который на _обычный товар_.
И просто написав вот эти два утверждения отдельно и положив в шаблоны, вы можете подавать данные на вход и видеть все состояния своего макета, добавлять какие-то разные юзернеймы, разные длинные или короткие названия товара.
И видеть, что какую-то вариативность вы ещё не покрыли — вот здесь требуется шаблон.
Мне кажется, что это очень удобная штука для прототипирования, тем более, что это можно делать прямо в браузере.

**Вадим.**
А как так получилось, что все всякие JavaScript-шаблонизаторы типа Mustache и Handlebars оперируют HTML-элементами и всякими угловыми скобочками, а у вас JSON на JSON c JSON?

**Слава.**
Вот!
Это наша ключевая фишка.
Тут нужно подробнее про эту историю поговорить.
Представьте себе технику интлайновых стилей.
Все знают, что это не очень хорошо, но иногда кто-нибудь да где-нибудь это пишет.
Чем это плохо, если явно проговорить?
Тем, что каждый раз, когда у вас встречается этот элемент и стили заинлайнены, эти заинлайненые стили придётся повторить.
Теперь давайте представим себе типичный шаблон для какого-нибудь поста в блоге.
У вас там захардкоржен `<h2>` скорее всего, и туда выводится заголовок поста.
И захардкоржен какой-нибудь `<p>`, куда выводится первое предложение от поста.
А вот эти теги `<h2>` и `<p>` на манер того заинлайненого CSS просто заинлайнены.
Если вдруг вы захотите вывести примерно такой же снипет поста, но где-нибудь в другом месте и просто изменить вот этот тег — он у вас уже захардкоржен.
Это где может пригодиться?
Например, у вас есть основные посты и дополнительные посты от других тем.
Или у вас есть основной список товаров, и есть товары из соседнего региона.
То есть, снипеты примерно одинаковые, но разметочка должна отличаться где-то там каким-то маленьким кусочком.

**Вадим.**
Ну, обычно современные верстальщики решают эту проблему тем, что они используют только `<div>`.

**Слава.**
Конечно можно и так, да.
Но, уж коль скоро мы в подкасте «Веб-стандартов» говорим, то наверно какой тег у вас стоит в каком месте — это очень важно.
Кроме того, дело не только в имени тега, а дело в том, что вам могут понадобиться разные наборы HTML-атрибуты.
Например, здесь нужно написать `role-banner`, а там не нужно.
Здесь нужно какой-то `id` поставить в качестве якоря, а там не нужно.
Суть в том, что как только у вас появляется какая-то задача изменить отдельную часть HTML, не меняя всего остального, вы сталкиваетесь с тем, что HTML захардкоржен, точно так же, как были бы заинлайнены стили.
И тут BEM-XJST помогает вам решить этот вопрос, потому что вы имеете шаблон не на всю вот эту конструкцию, а отдельно, точечно можно изменять имя тега, отдельно можно примиксовывать какие-то классы в HTML, отдельно можно добавлять какие-то атрибуты или не добавлять по какому-то условию.
Сам шаблон выглядит, как набор точек для расширения.
Если вы захотите туда подключиться и что-то там изменить — это возможно

**Вадим.**
Ну, то есть, по сути, как у нас у блока или у элемента есть модификатор так же можно любой из существующих шаблонов модифицировать, не создавая принципиально новый.

**Слава.**
Да, да.
Его можно как доопределить, так и полностью переопределить.
Это на ваш вкус.
Точек расширения в BEM-XJST гораздо больше, чем в обычном шаблонизаторе, в котором фактически всё захардкоржено, и вы можете пользоваться только терминами _mixin_ и _include_.

**Вадим.**
Ну, это вообще не новая история, этот BEM-XJST.
Он уже вроде давно разрабатывается.
Расскажи немножко про сам проект.

**Слава.**
Да, проект не новый.
Я сейчас точно не знаю, сколько он лежит в OpenSource.
Но проекту мне кажется, по меньшей мере 5 лет.
Сначала там был не JS-синтаксис.
От этого отказались.
То есть, там был такой DSL, который придуманный язык.
И эта идея не очень хорошо была встречена разработчиками — учить что-то дополнительное было в тягость.
Поэтому от этого отказались и сейчас там просто шаблон на чистом JS.
Фактически можно писать всё, что угодно, объявлять функции, переменные.

**Лёша.**
Вы планируете использование этого шаблонизатора с какими-нибудь популярными фреймворками типа Express, Koa, и так далее?
Ну, чтобы совсем вход в это всё был проще.

**Слава.**
На счёт Express, Вова Гриненко уже делал такой небольшой [project stab](https://github.com/bem/bem-express), где как раз Express, шаблонизатор BEM-XJST.
Такие связки реализованы как раз в целях, чтобы показать, как это достаточно просто.
Там буквально 5-10 строк на связку популярного Express с вашим шаблонизатором.

**Лёша.**
Ты думаешь, вот эта штука нужна любому проекту?
Просто знаешь, у меня есть сомнения по поводу обычных фрилансерских фронтендеров-верстальщиков, которые на выход заказчику отдают просто вёрстку.
Ну, то есть, они отдают HTML-файлы, отдают css-файл.
Я понял твой поинт о том, что такой фрилансер может у себя собрать свою собственную библиотеку компонентов, от которой может наследоваться и видоизменять её.
Но ведь, чтобы ему это сделать, ему тоже нужно потратить большое количество времени.
А это же фрилансер, ему нужно скорее-скорее клепать ещё больше заказов.

**Слава.**
Тут такой вопрос каждый должен решать для себя.
Он хочет час потерять и потом за пять минут долететь, или он готов каждый раз терять этот час, снова и снова.
Тут ведь важный момент в том, что обычно, когда вы используете Bootstrap, вам приходится копипастить HTML.
CSS у вас уже подключаемый, а к примеру HTML, который вы должны написать, вы его всё равно где-то должны взять.
А в случае с BEM-XJST такая библиотека блоков будет включать и шаблон, и стили, и возможно какие-то ваши примеры того, как это может быть.
Тут нужно понимать, что это не уровень CSS, а уровень чуть-чуть шире.
Речь идёт не о том, чтобы избавиться от копипаста в CSS, а о том, чтобы избавиться от повторения рутинной работы снова и снова.

**Вадим.**
Ну и времена меняются, Лёша.
Если раньше заказчик требовал от тебя один index.html и одну папочку с CSS на флешке.
И какой ещё проект на GitHub, и какая ещё система контроля версий, что ты мне всякую фигню несёшь, дай мне сайт, я его на FTP залью.
То сегодня, если у тебя процесс сборки у проекта, если какая-то оптимизация по ходу происходит, если используешь какие-то фреймворки, то в принципе заказчики, будь то конкретные люди или конторы, готовы к тому, что ты даёшь им не просто готовый результат, а систему по разработке и поддержанию всего этого дела.

**Лёша.**
Я, кстати, согласен.
Но согласись тоже, что скорее всего таких разработчиков, которые отдают сразу же систему, у них уже используется какой-нибудь шаблонизатор или какое-нибудь своё решение.
Ведь они не будут ждать пока появится какое-нибудь замечательное средство в БЭМе.
Они уже с этим работают.
У них там Jade, Mustache, Handlebars и всё, что угодно.
Меня до сих пор немного пугает многословность синтаксиса, потому что там очень много скобочек.
Ну, это понятно, там JS, вы вызываете там функции, бла-бла-бла, но тем не менее.
Кстати, а вы не планируете сделать поверх этого что-то, что сделали в React с этим JSX?
То есть, просто какой-то другой набор этого синтаксиса более близкого к HTML, который в итоге прекомпилируется в вашу обычную JS-структуру.

**Слава.**
Ну вот это то как раз, о чём я говорил.
Мы сейчас это не планируем, потому что мы как раз от этого уходим.
Потому что у нас был такой синтаксис, который очень короткий или как ты говоришь немногословный.
Но как ни странно это вызывало на самом деле минимум два батхёрта.
Первый — это то, что никто не хочет учить дополнительно какой-то кастомный синтаксис, то есть как будто бы какой-то язык.
А второе — это то, что ты автоматически попадаешь на сборку.
А сборка — это не всегда быстрая вещь, и как только она вообще появляется, ты начинаешь тормозить в своей разработке.
Каждый раз, когда ты что-то изменяешь, тебе нужно запускать пересборку и ты подумываешь о том, чтобы настроить Watcher.
И потом у тебя возникают какие-нибудь сложности.
Ты через час очнулся, и вместо того чтобы верстать, ты понимаешь, что ты боролся со сборкой.
А сейчас не нужна никакая компиляция шаблонов.
Шаблоны на JS — это значит, что ты можешь натравить на любой jsHint, jsLint, precommit-hooks.
То есть, тебе сразу же будет сказано, что не так.

## 1:00:20 Завершение: ваши предложения

**Вадим.**
На этом мы завершаем шестой выпуск подкаста «Веб-стандарты».
Сегодня у нас кроме новостей была большая тема про шаблонизацию, БЭМ и BEM-XJST.
Мы собственно позвали славу для этого.
Если вы чего-то не поняли из нашего сегодняшнего диалога про шаблонизацию и про БЭМ, посмотрите доклад Славы.

Если у вас есть идеи, какие темы можем обсудить помимо новостей на прошедшей неделе, пожалуйста пишите нам в комментариях на SoundCloud, в соцсетях, где угодно.

На следующей неделе к нам вернётся Ольга Алексашенко, верстальщик руками.
Мы будем звать других гостей от случая к случаю.
Поэтому ждём ваших предложений и идей.

Это был подкаст «Веб-стандарты» и его постоянные ведущие Алексей Симоненко из HtmlAcademy…

**Лёша.**
Вадим Макеев из Opera…

**Вадим.**
И Вячеслав Олиянчук из Яндекса.
Услышимся на следующей неделе.
Счастливо!

**Слава.**
Пока!

**Лёша.**
Пока!

## Расшифровка аббревиатур

 - **ПК** — станция метро «Парк культуры»
 - **КР** — бизнес-центр «Красная роза»
 - **ДД** — бар «Джон Донн»