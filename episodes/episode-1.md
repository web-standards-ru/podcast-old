# Выпуск №1

Chrome 48, Firefox 44, Sass вместе с PostCSS, минимально необходимые шрифты, HTTPS, коты во фронтенде.

[Слушайте на SoundCloud](https://soundcloud.com/web-standards/pilot-1), [обсуждайте в Слаке](https://web-standards.slack.com/messages/podcast/).

00:50 Новинки браузеров

- [Chrome 48](https://youtu.be/TebeVxw95RI)
- [Firefox 44](http://tanalin.com/blog/2016/01/firefox-44/)

08:06 PhantomJS 2.1

- [PhantomJS 2.1](https://raw.githubusercontent.com/ariya/phantomjs/master/ChangeLog)

11:04 Переменные в CSS

- [Переменные как основа архитектуры CSS при работе с препроцессорами](http://prgssr.ru/development/peremennye-osnova-arhitektury-css.html)

21:17 Sass с PostCSS

- [Extending Sass with PostCSS](http://ashleynolan.co.uk/blog/extend-sass-with-postcss)

26:54 Загрузка шрифтов

- [Минимально необходимые шрифты](http://css-live.ru/articles/minimalno-neobxodimye-shrifty.html)

35:22 Спрайты

- [A Gulp-Based External SVG Symbol Sprite Icon System](https://una.im/svg-icons/)

39:49 Адаптивные картинки

- [Responsive Image Breakpoints Generator](http://www.responsivebreakpoints.com/)

41:50 HTTPS

- [Почему до сих пор повсеместно не используется HTTPS?](https://habrahabr.ru/post/275539/)

48:12 Парадоксы HTML и CSS

- [WTF, HTML & CSS?](http://wtfhtmlcss.com/)

52:05 Коты JS-фреймворки

- [Which cat is your JavaScript framework?](http://whichcatisyourjavascriptframework.com/)

---

**Вадим.** Привет, меня зовут Вадим, мы записываем пилотный выпуск подкаста Веб-стандарты и будем обсуждать новости и просто общаться с вами на темы фронтенда. Представлю наших гостей.

**Ольга.** Добрый день, меня зовут Ольга Алексашенко, я верстаю руками в течение 10 лет и в этом подкасте я буду представлять практическую сторону разработки.

**Алексей.** Привет, меня зовут Леша Симоненко, я большую часть времени общаюсь с сообществом и занимаюсь образованием в HTML Академии.

**Вадим.** Ок, да. А я Вадим, я работаю на браузерную компанию Опера, тоже занимаюсь образованием, организовываю конференции и прочее, прочее, прочее.

**Алексей.** Ну что, к темам?

## 00:50 Chrome 48

**Вадим.** Давайте начнем с самого такого дежурного, у нас очередные вещи обновили версию, мы обсуждали релиз, когда готовились к передаче, Chrome 48 и никто не смог вспомнить, что ж там нового. Действительно, вот эта вот версионность новая, которая появилась в Chrome, в Opera, в Firefox и во многих других, она, конечно, немножко до сих пор смущает людей, все такие "Ой, Firefox 44, я помню десятка выходила, и что там нового, по сравнению с 43-м Firefox?", еще что-то такое…

**Алексей.** Но знаешь, кстати, с другой стороны я бы очень хотел, чтобы то же самое произошло со всеми браузерами, и, например, от Safari хочется такого ожидать, и тогда было бы пофиг, что они называются 48, 49, 67, главное — что они просто релизится часто и поддерживают больше штук быстрее.

**Вадим.** У Safari сейчас начинает такое происходить, они раньше только в мажорных версиях добавляли или исправляли что-то новое, меняли WebKit WebView, вернее UI WebKit и, собственно, встроенный браузер тоже обновлялся мажорными версиями, а сейчас в минорных версиях уже начинают появляться какие-то изменения, соответственно, сейчас уже разработчикам доступны беты Mac OS следующей версии, и там следующей версии iOS и там уже серьезные обновления, типа там поддержка `<picture>` там всякие…

**Алексей.** Да, да, да… Там переменные, например CSS будут, это Safari 9.1 будет, вот ждем его

## 02:30 Firefox 44

**Вадим.** Например, в упомянутом Firefox 44 большая вещь, которую наконец-то вынули из флагов, это сервис-воркеры и пуш-уведомления, соответственно, вещь более важная, наверное, для мобильных браузеров, Firefox на мобильных не особо силен, но у них все-таки есть версия Firefox для андроида с собственным движком, но поддержка, альтернативная поддержка какой-то спецификации и технологий — это всегда очень важный шаг, до этого сервис-воркеры работали только в движке Chromium, соответственно Chrome, Opera, Yandex browser и так далее. Сейчас у нас появилась альтернативная реализация, то же самое было с pointer-events, то же самое было с элементом <picture> и так далее. То есть, альтернативная реализация как-бы говорит разработчикам: все, это в серьез, давайте использовать, вот точно давайте использовать. И самые простые примеры, которые сейчас появляются с поддержкой сервис воркеров — это оффлайновые страницы, опять же, мало кто понимает зачем это делается. У вас есть какой-нибудь опыт, собственно, вы хоть раз трогали сервис-воркеры и вообще, понимаете как это работает, как это делается?

**Ольга.** Нет, мне не приходилось работать с сервис-воркерами, потому что я все-таки больше верстальщик, чем JS программист, но выход новых фич в Firefox — это очень хорошо, потому что сейчас для меня Firefox — это такой новый IE: везде все хорошо — в Firefox обязательно что-нибудь не работает или что-нибудь поехало, в общем — удивительный браузер, раньше я очень-очень его любила и пользовалась только им, но вот уже года два — увы… Так что я рада выходу новых фич.

**Алексей.** Я самими сервис-воркерами не пользовался, но я пользовался предыдущей реинкарнацией — это Application Cache, это было очень давно… Ну как, три года, наверное, да?

**Вадим.** Это очень давно, три года во фронтенде, я уж не помню…

**Алексей.** Ну да, я тогда делал какой-то калькулятор подсчета стоимости разработки сайтов, такой развесистый весь, со всякими разными шутками и хотелось чтобы он работал всегда: есть интернет, нет интернета и так далее. И Application Cache это, конечно… Все тогда очень радовались: "Круто, круто, и правда — в оффлайне! Смотри, я выключаю интернет, выключаю WiFi, а оно работает", это здорово. Но проблем мы огребли, конечно, огромное количество: это и невозможность что-то обновить, и… Да вообще, работа с Application Cache была ужасной… Кстати, вот я заметил, что в 44-м Firefox Application Cache-то еще поддерживается, но уже выводит предупреждение о том, что это устаревший метод и его, наверное, уже использовать нельзя. Но это ладно, это о старом, а вот о сервис-воркерах: я вот пока себе вижу использование его не совсем по прямому назначению, то есть не для оффлайновых страниц, а скорее для кэша, и вот эта идея мне понравилась.

**Вадим.** Ну, там на самом деле он настолько низкоуровневый сервис-воркер, что прямого назначения у него, как такового, нет. Это просто API, который позволяет решать ваши задачи, а одна из задач — которую очень просто сделать — сделать так, чтобы ваш сайт "застревал" в браузере, даже когда сайт, собственно, закрыт, и имел возможность показать что-нибудь когда интернета нет. Не просто голую страницу с динозавриком, или какой у вас там браузер, а именно что-то полезное. На сайте Guardian кроссворд сделали, мы с коллегами на Dev.Opera думаем сделать архив последних пяти статей, чтобы можно было даже в оффлайне почитать их со всеми ресурсами и так далее. Естественно, нужно думать о кэше, особенно на мобильных устройствах, чтобы как бы не занять слишком много. Но, опять же, можно картинки не класть, можно с помощью сервис-воркеров подменять картинки на какие-нибудь заглушки, прямо на лету, именно их класть в кэш. То есть штука слишком мощная, чтобы не знать — не пользоваться. Опять же, это скорее не для верстальщиков, но переломить у себя в голове идею того, что оффлайн — это тоже место, где мы можем что-то делать — это очень, очень, очень интересно, очень интересная вещь, которой точно стоит заниматься.

**Алексей.** Ну, кстати это не совсем всем понятно, потому что… На этой неделе были тоже статьи про работу сервис-воркеров, вот как раз то, что ты рассказал про оффлайновую страницу на веб-стандартах, и там были очень показательные комментарии ВКонтакте, вроде "А вообще нафига это надо?"

**Ольга.** Очень хороший пример, например, это почта: у тебя нет интернета, но ты хочешь в Google Mail посмотреть свой архив писем — это очень, очень нужная фича и мне ее очень не хватает.

**Вадим.** Ну, насколько я понимаю, до сих пор ни Google Inbox, ни Google Mail не могут показать тебе список писем, если у тебя нет интернета, то есть даже Google, который изо всех сил продвигает использование оффлайн сервис-воркеров, кэша и так далее, даже они еще не перевели свои крупные приложения на полноценную работу.

## 08:06 PhantomJS 2.1

**Алексей.** На этой неделе еще знаете что вышло? PhantomJS! Наконец-то разродился версией, какая она там… 2.1, да. Это не совсем браузер, но что-то близкое, это оторванный движок от браузера и, честно говоря, у нас для Phantom альтернативы нет… Вы же пользуетесь Phantom?

**Вадим.** Я пользуюсь Phantom для тестирования, то есть я прогоняю какие-то функциональные тесты для парочки своих проектов, соответственно, пользуюсь в автоматическом режиме, естественно.

**Алексей.** А мы вот Phantom-то очень сильно используем, но у нас нет альтернативы и я с радостью принял бы, если бы ребята из Google для Blink выпустили что-то похожее, или даже пускай Edge выпустит, ой, Microsoft выпустит движок свой в таком виде, потому что эта безальтернативность, она, конечно, не очень хороша и я поясню почему. Дело в том, что год назад зарелизилась версия 2.0, ровно двадцать третьего января 2015 года и сейчас версия 2.1, минорная версия зарелизилась спустя год, при этом при релизе 2.0 у них было огромное количество багов, которые никуда не девались течение всего года. Это, на самом деле, очень печально, если вы используете его постоянно.

**Вадим.** То есть, одно дело — когда тебе всего лишь нужно прогнать тест, какой-то там джаваскриптик, особенно какой-нибудь юнит-тест простой, джаваскриптовый выполнить — это понятно, но когда тебе нужно отрендерить картинку, чтобы оно работало еще и так же, как работает в других браузерах, в живых браузерах, и так далее, и так далее — это, конечно, большая проблема. А не пробовали ли вы использовать Electron для этого? Есть, дай бог памяти как он называется, то ли Nightmare, то ли еще как-то…

**Алексей.** Nightmare — это да, это тестовый фреймворк

**Вадим.** Да, да, это тестовый фреймворк, вроде Phantom, который использует Electron, на котором, собственно, написан Atom, Slack написан и так далее. Грубо говоря, обертка вокруг Chromium, который позволяет через API обращаться к браузеру и запускать его "безголовым".

**Алексей.** Ага, потому что я что-то раньше его видел, но тогда он каким-то API сверху отличался, конечно, но это был тот же самый Phantom, как мне кажется, поэтому мы его никогда и не использовали, но если он работает с Electron — это хорошая идея, и я думаю мы посмотрим. Ну, хорошо, я думаю мы достаточно обсудили релизы, которые вышли на этой неделе, давайте может быть тогда обсудим статьи по препроцессорам?

## 11:04 Переменные как основа архитектуры CSS

**Алексей.** На этой неделе были хорошие статьи:например, был перевод на Прогрессоре. Я считаю, что то, как используют препроцессоры это не очень хорошо, потому что препроцессоры — это такая штука, которая была введена в CSS, то есть она была добавлена для людей, которые пишут CSS, чаще всего они не программисты, но при этом препроцессоры — это внос какого-то немножко "мира программирования" в CSS, и основная проблема, как мне кажется, с препроцессорами в том, что добавили некую… Некое программирование в CSS для людей, которые с программированием вообще никак не связаны и из-за этого почти все проблемы. Ну например, знаешь, какие основные проблемы? Есть в каждом препроцессоре такая штука, как… Они делают кусочек слова и через амперсанд ставят слово-родитель, название класса, например, ".page", а там следующий класс — это амперсанд…

**Вадим.** Конструируют селектор

**Алексей.** Да, и это, я считаю, ужасно. То есть когда ты работаешь в одном проекте — это, наверное, замечательно, ты бог этого проекта и ты все знаешь, но как только ты отдаешь его другому человеку… Вот он нашел этот класс у себя там где-то в верстке и пытается — у тебя, конечно же, CSS громадный — и пытается его найти… Ну как мы ищем — поиском наверное, да? — в редакторе… И эту штуку найти невозможно…

**Вадим.** Нет, ну если мы используем компонентный подход, и если у нас один модуль на один файл, соответственно, мы все быстро сможем найти

**Алексей.** Ну подожди, это в идеале, когда у тебя совсем маленький файл, очень маленькие модули, но чаще в практике встречается… Ну, вот я просто.. другое. Мы, когда обучаем ребят и видим, как наши наставники, например, пишут код и предлагают писать код, это все разбивается. На практике все происходит по-другому, там просто ужас происходит, ты ничего найти не можешь. Да, там бьется все на файлы, но эти файлы тоже большие, в них тоже ничего не найти. А главное — в чем преимущество-то? В том, что ты быстрее набираешь? Быстрее набираешь текст?

**Вадим.** Можно переименовывать блоки быстрее таким образом, не ковыряясь, можно скопировать внутренности одного блока в другой блок без переименования всех селекторов, и так далее… Плюсы есть, я иногда легко копирую внутренности какого-то блока с медиа-выражениями, с какими-то там миксинами, еще с чем-то в другой блок. Конечно, стоит абстрагировать такие вещи, но иногда удобнее и проще скопировать, и тебе не нужно переименовывать вещи, то есть код более реиспользуемый становится из-за этого, как минимум для меня.

**Алексей.** Ну, а Оля, кстати… Оль, ты используешь препроцессоры?

**Ольга.** Да, использую.

**Алексей.** А ты там прям все-все используешь?

**Ольга.** Ну, я не уверена, что я знаю о них все, потому что в моей голове нет справочника, но пользуюсь достаточно широким набором возможностей: миксинами, амперсандами — но немножко не так, как вы тут осудили: переменными, всякими калькуляциями, экстендами, в общем, это очень удобно, на мой вкус.

**Алексей.** Ну, мне, еще почему кажется что это не очень хорошо — я вообще считаю, что препроцессоры, в целом, это хорошо, потому что это дает толчок развитию самой спецификации CSS, потому что многое она заимствует оттуда. Но то, как их используют, еще раз повторюсь, это не очень хорошо. Мне кажется, самое хорошее, что есть в препроцессорах и что следует использовать всегда, это конечно импорты: разделение на много файлов это замечательная штука, это вложенность, когда у тебя нет никаких холиваров на проектах по поводу вложенности… Есть люди, которые неистово за то, чтобы вложенности вообще каскада никакого не было. Если таких людей нет на проекте, то тут тоже все удобно. В какой-то мере это вычисления, хотя сейчас `calc` уже поддерживается, по-моему, достаточно хорошо… И, в какой-то мере, переменные — но вот с переменными, как по большей мере эта статья на прогрессоре, она о переменных, и я тут с автором немного не согласен, потому что автор выступает за то, чтобы у тебя все переменные были в одном файле. То есть, такой глобальный файл, со всеми переменными… Он, конечно, говорит, что "Не надо создавать много переменных, делайте по уму", но это тоже не очень хороший подход, потому что это больше похоже не на переменные — если мы берем какие-то классические языки программирования — это не переменные, а константы. Вот тогда да, это похоже, когда мы выносим их в какой-то конфиг и они у нас в конфиге, а переменные — это все-таки штука локального назначения. То есть у тебя какой-то модуль и ему, для его работы, было бы удобнее иметь какую-то переменную. Вот в этом смысле — это удобно. Например, у нас слайдер есть какой-нибудь, мы его описываем и он у нас не динамический, а мы меняем количество слайдов в CSS, и тут, конечно, удобно через переменную задать этих количество слайдов и делить ширину, высоту, все что нужно в зависимости от этой переменной. Мы заходим, у нас количество слайдов поменялось, мы меняем эту переменную — все замечательно, но зачем задавать — если вы, конечно, не пишете фреймворк — но зачем задавать цвета, размеры шрифтов в переменные — вот для меня это загадка.

**Ольга.** Ну, это как раз использование переменных в качестве констант. Ты очень правильно сказал про файл с константами, это действительно очень полезно: например, я пользуюсь такими вещами для создания цветовых схем. У меня есть приложение, в котором есть дневная схема и ночная схема, и я все цвета храню в переменных, это очень-очень удобно, а так же там хранятся всякие константы типа семейств шрифтов… Ну, удобно просто не прописывать огромную строчку десять тысяч раз со всем перечислением шрифтов: например, тебе тут нужен Sans, тут тебе нужен Serif, Serif Caption… Удобно пользоваться глобальными переменными. То же самое про line-height и, в общем, по-моему это очень удобно.

**Вадим.** Ну, лично у меня тоже на всех проектах, которые я делаю, есть файл defaults, SCSS в моем случае, где я храню базовые вещи, включая маленькие функции, которые я использую, всякие миксины. Но он обычно, не больше сотни строк, включая комментарии и прочее, и прочее. Твой праведный гнев скорее относится к тому, что это действительно константы, а не переменные как таковые. Не думаю, что на уровне языка и препроцессоров стоит разделять константы от переменных, но поговорить с разработчиком и понять разработчикам, что такие вещи стоит разделять — да, пожалуй, стоит, потому что есть пример совершенно из другой области: я свой gulp-файл в какой-то момент начал разделять на отдельные вещи, складывать в папочку таски и так далее.В руководстве, которое помогало мне это делать, было написано, что "выносите все пути в config.js и используйте пути". И я, конечно, все, как молодец, пошел по инструкции и вынес в конфиг, и я понял, что некоторые вещи у меня упомянуты в конфиге и использованы один раз, то есть такая переменная, которая используется один раз — это не переменная, как мы все знаем, это так, на будущее скорее. Поэтому, я настолько «законфигал» весь свой Gulp, разбитый по файлам, что мне стало не удобно в нем ориентироваться. Такой же ерунды можно наделать в своем CSS, так что да.

**Алексей.** Тут хочется какой-то видимости всего, то есть все-таки с этой штукой должны работать, а не для кого-то она должна быть удобной. А чтобы с ней работать — все должны быть в контексте, но если человек приходит в проект — это очень тяжело.

**Ольга.** Ну смотрите, здесь есть плюс еще и в том, что подобные возможности условного языка приучают людей к абстрагированию. Для верстальщиков это очень важно как переход к модульности, переход к абстрагированию каких-то вещей — это все очень сильно облегчает код и это полезно.

**Алексей.** Я не уверен в этом, мне кажется, с препроцессорами, и с любовью всех перетаскивать в конкретные простые проекты подходов написания фреймворков — это все слишком добавляет большую абстракцию в конкретный проект. В конкретном проекте должен быть минимум абстракций, он же конкретный, вот у тебя дизайн и он должен быть таким, ты же не фреймворк пишешь… И когда он, в моем понимании, если он конкретный — то вся эта абстракция — она нафиг никому не нужна. Почему так происходит? Потому что ни у кого нет в голове мысли о том, как правильно. Где посмотреть, как правильно? Давайте возьмем bootstrap, или foundation, еще какой-нибудь фреймворк и посмотрим. Но у них-то задача абсолютно другая.

## 21:17 Расширяем Sass с помощью PostCSS

**Вадим.** Давайте тогда еще буквально последнюю вещь про препроцессоры и прочее, просто чтобы сделать этот выпуск моднее: кто-нибудь PostCSS использует у себя в продакшене как таковой? Оля?

**Ольга.** Да, мы пользуемся PostCSS и мы заговорили об этом к слову о статье "Extending Sass with PostCSS", здесь у нас автору, видимо, задавали много раз вопрос, зачем он использует одновременно и Sass и PostCSS и почему это надо. Потому что это все дублирует, якобы, друг друга, но нет: у PostCSS есть прекрасные модули, которые могут ваш уже готовый код сделать еще лучше, например, инлайнеры, минификаторы, конечно, автопрефиксер — если кто-то еще не вынес автопрефиксер в модуль PostCSS, то уже очень пора сделать — всякая SVG-оптимизация, в общем очень-очень полезная вещь и в этой статье, в частности, есть много ссылок как можно улучшить свою разработку на Sass и SCSS при помощи PostCSS.

**Вадим.** Мой личный опыт показывает, что автопрефиксер — must have, они заставили меня перейти на PostCSS плагины — привет, Андрей! — вместо того, чтобы использовать gulp- или grunt- плагины с автопрефиксером непосредственно, но это ладно, имеют право, видимо. Но вот из такого, из полезного, мне больше всего нравится SVG-инлайнеры, которые знают, как нужно вставить SVG прямо в исходник, вернее, прямо в CSS файл, не конвертируя в base64, а экранируя всякие кавычечки, угловые скобки и так далее, чтобы один файл подгрузился — и весь SVG у тебя на месте, а не по запросу на каждый — вот один из самых полезных плагинов, которые существуют лично для меня.

**Алексей.** Я тут вам, наверное, буду ортагонален, но вот у нас сейчас последнее время новые страницы в академии верстают полностью на PostCSS, то есть там вообще нет никакого препроцессора, это, наверное, погреет душу Андрею, но нам это понравилось и мы вообще не чувствуем никак обделенными препроцессором, потому что все необходимое, что мы хотим, есть в PostCSS.

**Вадим.** А ты можешь перечислить фичи, которые вы используете? Те необходимые фичи, которые вы используете из препроцессоров? Которые вы набрали с помощью PostCSS плагинов?

**Алексей.** Ну, мы используем переменные, конечно

**Вадим.** То есть вот такие, с долларом, да? CSS-переменные?

**Алексей.** Моя любовь в этих всех технологиях в том, что я хочу, чтобы было все в итоге по спецификации, вот очень хочу, поэтому, например, Babel.js для JS мне нравится. Мне нравятся инструменты, которые делают в итоге то, к чему придет, то есть мы уже пишем и учимся так, как скоро будут все по умолчанию.

**Вадим.** Ну то есть вы просто подключили PostCSS… cssnext, точнее, в виде плагина, да?

**Алексей.** Ну, у нас, конечно, не все так просто: там cssnext не полностью, то есть некоторые вещи вырезаны из cssnext, а некоторые, которых нет просто в CSS, но которые нашему верстальщику очень-очень-очень понадобились, добавлены: это, например, вложенные с амперсандами верхними уровнями, и так далее.

**Вадим.** Ок, то есть вы набрали нужный комплект и, в общем-то, рады и багов особо не было, да?

**Алексей.** Нет, вообще не видим никаких багов… Нет, конечно когда мы весь этот процесс собирали, там багов было огромное количество, потому что в PostCSS есть некая дурацкая штука: там нужен определенный порядок всех плагинов, причем иначе они будут как-то криво работать или не работать, там нужно, если вы используете какой-то набор плагинов, типа cssnext и так далее, но используете не только его, а еще ряд плагинов, которые нужно воткнуть где-то в середину.

**Вадим.** Ага.

**Алексей.** Вот это тоже рождает проблемы и приходится из cssnext выключать какие-то плагины, брать их отдельно, кусками, подключать перед… Ну, в общем, настроить себе окружение для работы PostCSS — это то еще дело, но это вполне возможно и мы это сделали, закончили конфигурирование полгода назад и с тех пор вообще эту штуку не трогаем и она нас полностью устраивает.

**Вадим.** То есть после того, как намучились — мучиться перестали?

**Алексей.** Ну, как-то так, да.

## 26:54 Минимально необходимые шрифты Зака Лезермана

**Вадим.** Ок. Ладно, я предлагаю перейти к техникам: у нас есть несколько статей на тему шрифтов, SVG и элемента <picture> и прочее, что нового и интересного, какие техники предлагают. Вот я слышал, Оля, что тебе понравилась статья про минимально необходимые шрифты Зака Лезермана?

**Ольга.** Да, это довольно интересная и полезная статья: во-первых он описывает все четыре основных способа подключения веб-шрифтов с их недостатками, мы лично сейчас используем на своем главном проекте второй способ — это встраивание шрифтов с помощью data URI и подгрузки таблицы стилей асинхронно, но у него есть такой минус: это техника «засовывать шрифты в Local Storage», и, соответственно, браузер уже потом проверяет, нет ли шрифтов в Local Storage, и если вдруг вам в Local Storage попал какой-то побитый шрифт, вызывает много проблем у конечного пользователя. Собственно, способ, который описан в этой статье, предполагает уменьшение файла шрифта. Ну, во-первых его предлагается сохранить в формате WOFF2 и потом сконвертить в base64, насколько я поняла… В общем, суть этого метода в том, чтобы взять из нужного шрифта самые используемые глифы и на первом этапе загрузить только их, чтобы страница показалась как можно быстрее при минимальной загрузке, а потом уже в процессе догрузить все остальное. Шрифт мелькнет при этом, но уже будет красивее все.

**Алексей.** Наверное, стоит сказать и о других способах, потому что их всего было пять, ты сказала про второй и самый последний, пятый. Первый способ — это ничего не делать, это когда мы просто используем директиву "@font-face" и ждем милости от браузера, чтобы он все сам сделал, и это, по мнению автора, считается анти-паттерном уже, то есть это из всех возможных способов самый худший способ. Третий способ — это когда мы работаем с "динамическим классом", то есть у нас изначально шрифт не используется, мы подгружаем с помощью какой-нибудь js API для подгрузки шрифта, или встроенного в браузер, или отдельной библиотекой подгружаем этот шрифт и только когда мы уверены, что он подгрузился, мы добавляем класс к body, который добавляет этот шрифт в CSS. И четвертый принцип — это когда мы эту же технику делим на несколько маленьких шрифтов, то есть в предыдущей технике мы грузили все семейство шрифтов: и жирный, и наклонный, и так далее, шрифт, а в четвертой технике нам предлагают разделить шрифты на каждый кусочек и загружать отдельно каждое начертание с помощью JS и добавлять соответствующий класс для "<body>". Как по-вашему? Вадим, тебе какой способ нравится?

**Вадим.** Я делал в конце года прошлого редизайн WSD (Web Standards Days) конференции, и там я использовал следующий подход: прямое начертания я инлайнил в основной CSS, там используется, по-моему, Roboto шрифт, естественно, и латиница, и кириллица, но получается не так тяжело в формате WOFF — не WOFF2, потому что WOFF2 менее совместимый, а в формате WOFF — все равно получилось, по-моему, порядка 60 килобайтов, но зато в одном файле все проскакивает… Прямое начертание "инлайнится", а остальные начертания в "голове" на странице подгружаются уже асинхронно, тоже в виде CSS файлов, то есть вот подобный способ, он как бы не является в чистом виде ни одним из описанных, и, наверное, стоило бы добавить в это дело еще Local Storage и прочее, прочее, прочее, но вот подобный способ — самый простой — прямое начертание, а потом, асинхронно, все остальные, по-моему, лучше всего подходит, ну, скажем так, для базовой оптимизации подгрузки шрифтов.

**Алексей.** Если спросить меня, как мы использовали шрифт, то мы делали примерно то же самое, что делала Оля у себя на проекте: мы запихивали в CSS-файл base64-шрифт и этот CSS-файл подгружали JS, асинхронно, и, когда он подгружался, кидали его в Local Storage, но, честно вам скажу, это не очень хороший способ, потому что доходит до таких простых вещей, что Local Storage — если у вас нормальный шрифт, с нормальным количеством килобайт — у вас просто Local Storage может зависнуть и крашнуть ваш браузер легко. Он просто не может открыть такое количество текста, не знаю почему, вот даже сегодня я ставил Firefox 44, который новый, пытался открыть его — та же самая история, все падает. Техника хорошая, быстро работает, но вот за счет того, что идет работа с Local Storage, это не очень прикольно, ну и плюс нужно помнить, какое количество информации в Local Storage, и когда вы в следующий раз достаете ее из Local Storage, она очень сильно, во-первых, на мобильных очень потребляет вашу батарейку, а во-вторых очень сильно задерживает ваш процессор, поэтому это не самая хорошая техника, и вот сейчас, буквально на прошлой неделе, мы переделали все на вот этот способ с подгрузкой шрифта через js API, то есть у нас этот "@font-face on load" — хотелось бы использовать встроенный в браузере API, но там поддержка не очень хорошая — мы сейчас подгружаем шрифты через js, причем, каждое начертание — отдельным потоком, что позволяет браузеру, например, в четыре потока их грузить одновременно…

**Вадим.** А вы кодируете файл шрифта во что-нибудь, или он как есть?

**Алексей.** Нет, шрифт лежит как есть, это WOFF и WOFF2 форматы, в CSS из `<body>` выносится этот шрифт, у нас Muller используется, он выносится там, а в классе `.muller` на `<body>`, меняется `font-family`, и, когда мы в JS подгружаем все начертания, например, промисом, когда все четыре начертания к нам приходят, мы просто добавляем этот класс. Ну а дальше есть хитрая техника, когда мы первый раз их загрузили, мы кидаем в session storage какую-нибудь переменную, что шрифты были первый раз загружены у пользователя, и второй раз, когда он заходит, мы уже вообще ничего не трогаем, мы смотрим, что эта переменная у нас есть, значит браузер эти шрифты трогал, значит, если ваш сервер правильно настроен, они закэшированы браузером, и мы просто в этот момент добавляем класс к `<body>` и все происходит очень быстро.

**Вадим.** Возвращаясь к первой технике, которую Зак называет анти-паттерном, что не стоит сейчас браузеру просто отдавать шрифт с помощью `font-face`, вообще все шрифты, что у вас есть на проекте, чтобы он их кэшировал и т.д., на мой взгляд, так должно быть: подключаете — и оно работает, так должны работать все технологии в браузерах, а то, что мы сейчас делаем — мы пытаемся станцевать с бубном, чтобы оно заработало лучше, но на самом деле лучше оно должно работать с помощью API браузерных, с помощью просто встроенной браузерной магии.

**Алексей.** Ну да. В общем, ждем "font-display"… Мне тоже кажется, что этим должны заниматься браузеры, и тем более… Вообще странно, что изначально, когда добавили шрифты, никто не подумал про это.

**Вадим.** А их никто не использовал, потому что они слишком тяжелые были.

**Алексей.** Ну да, как обычно и получается: практика применения показала все проблемы — и вот оно решение…

## 35:22 Система символьных спрайтов Юны Кравец

**Вадим.** И немножечко еще про хаки: у нас все еще нет нормальной системы, пожалуй, использования иконок в браузерах, мы все еще пытаемся выяснить нормальный способ. Мне кажется, что еще куча людей сидит на иконочных шрифтах. Какой у вас опыт в этом смысле?

**Алексей.** Иконочными шрифтами мы почти сразу перестали пользоваться, как только поняли все его проблемы: то что не загружается, загружается криво, Opera Mini их вообще вырезает, и все остальное, с этим связанное. [35:58]
