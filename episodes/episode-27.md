# Выпуск №27

Видео в iOS, ChakraCore конкурент V8, доступные модальные окна, таблицы и формы, чехарда с цветовыми функциями CSS.

[Слушайте на SoundCloud](https://soundcloud.com/web-standards/episode-27), [обсуждайте в Слаке](https://web-standards.slack.com/messages/podcast/).

## 00:26 События

- [MoscowJS №32](https://events.yandex.ru/events/yagosti/28-july-2016/)
- [Черновик расписания WSD](https://wsd.events/#calendar)
- [Первый WSD в Яндексе](https://events.yandex.ru/events/yagosti/wsd-msk-nov-2012/)
- [FrontTalks](http://fronttalks.ru/) 17—18 сентября

## 04:57 Инлайновое видео в iOS

- [New `<video>` Policies for iOS](https://webkit.org/blog/6784/new-video-policies-for-ios/)

## 08:09 ChakraCore на Mac и Linux

- [Bringing ChakraCore to Linux and OS X](https://blogs.windows.com/msedgedev/2016/07/27/chakracore-on-linux-osx/)
- [Why ChakraCore matters](https://www.christianheilmann.com/2016/07/27/why-chakracore-matters/)
- [nodejs/vm](https://github.com/nodejs/vm)
- [mozilla/spidernode](https://github.com/mozilla/spidernode)

## 25:12 Модальные окна

- [Оформление модальных окон](http://prgssr.ru/development/oformlenie-modalnyh-okon.html)

## 32:43 Сложные таблицы

- [Lessons from building mobile-friendly, accessible data tables](https://medium.com/p/1e05c6924eaf)

## 37:13 Формы и доступность

- [Using the <fieldset> and legend elements](https://accessibility.blog.gov.uk/2016/07/22/using-the-<fieldset>-and-legend-elements/)
- [Totally Tooling Tips](https://www.youtube.com/watch?v=pBJZsp5LsOE&index=2&list=PLNYkxOF6rcIB3ci6nwNyLYNU6RDOU3YyL)
- [Accessible UI Components For The Web](https://medium.com/p/39e727101a67)

## 44:04 Чехарда с цветовыми функциями

- [Switch all the color functions to be space-separated](https://github.com/w3c/csswg-drafts/commit/a54f8b2089d16eca696690fe7ffc3c11d4db9861)
- [CSS Function Syntaxes (color and otherwise)](http://www.xanthir.com/b4iW0)
- [Incomplete List of Mistakes in the Design of CSS](https://wiki.csswg.org/ideas/mistakes)

---

**Вадим.** Привет, с вами 27-й выпуск подкаста «Веб-стандарты» и его постоянные ведущие: Алексей Симоненко из HTML Academy.

**Лёша.** И Вадим Макеев из Opera.

**Вадим.** А Оли нет, Оля в лесу, поэтому мы записываемся вдвоём. Мы никого не нашли на MoscowJS, и вообще, по сусекам поскребли, как-то никто не смог в эту субботу с нами записаться, ой чёрт, проговорился. Так вот, будем вдвоём сегодня.

## 00:26 События

**Вадим.** Ну как я и говорил, что вернулся с [MoscowJS №32](https://events.yandex.ru/events/yagosti/28-july-2016/) в Москве. Что-то я зачастил: третий раз подряд, было интересно. В этот раз проходил MoscowJS №32, по моему, в офисе Яндекса, и были доклады януксоидов и не януксоидов, даже рассказали про [TODO:] – довольно интересный доклад про то, что, мол, пишите на JS, платформа готова. Кроме прочего, они грозились на этом MoscowJS следующий сделать конференцией. Давно уже от MoscowJS возникает впечатление, что это конференция. Там, 200 человек набивается, если зал позволяет, а могут набить, наверное, больше. Куча JavaScript-разработчиков в Москве, востребованность всего этого дела очень высокая, и у ребят, в общем-то, и доклады на уровне. Поэтому, когда на митапе, на встрече, чем на самом деле и является MoscowJS, там звучат такие базовые доклады, или доклады людей, которые, не знаю, там, выступают первый раз, публика начинает как-то так кукситься, мол, да что это вы, на такой крутой конференции, и тут врубаются, что это на самом деле не конференция. По моему, было бы неплохо сделать MoscowJS площадкой, где может выступить любой, даже без опыта. Но вот ребята решили всё-таки пойти больше в сторону конференции, видимо, потому что им предложили большой зал и что-то большее сделать. Короче, в сентябре будет MoscowJS в Badoo, где будет пять докладов, каждый доклад будет получасовой, а не 20-и минутный, и, в общем, что-то будет большое и интересное, ну посмотрим.

Яндекс, который провёл MoscowJS в этот раз, помогает и нам в этом году. Мы раньше делали WSD силами Яндекса [Первый WSD в Яндексе](https://events.yandex.ru/events/yagosti/wsd-msk-nov-2012/) в Москве несколько раз, и, в общем-то, были одними из первых, кто открыл эту программу «Я.Гости», так называемую, когда Яндекс принимает сообщество у себя на площадке в Москве. И в этом году мы тоже будет делать с помощью Яндекса конференцию WSD в Минске, Москве и может быть даже в Киеве. Так что, в ближайшее время будем анонсировать даты, а вы помните, да, присылайте ваши доклады.

Ну и кроме городов, которые мы уже сказали: Питер, Минск, Киев и Москва, то, что мы планируем на эту осень, к нам ещё приходили ребята из Томска и Нижнего Новгорода, мол, давайте сделаем у нас конференции. Но так получается, что что-то многовато у нас всего, а делать больше одной конференции в месяц тяжело, на само деле, и для вас и для нас, поэтому мы подумали и решили, что, наверное, сделаем их весной. То есть, мне сказали, что зимой в Томске лучше не делать конференцию, потому что у всех уши отмёрзнут, а вот весной будет нормально. Так что, вот мы планируем на апрель-май, что-нибудь, в Томске и Нижнем Новгороде, ну, в общем, будем готовиться, будем держать вас в курсе [Черновик расписания WSD](https://wsd.events/#calendar).

Если вы слушаете этот подкаст, и ещё не купили билет на [FrontTalks](http://fronttalks.ru/) в Екатеринбурге, значит вы опоздали. Опоздали, потому что до этого они продавали за 2000 рублей, а с понедельника, 1 августа, когда мы выпустим этот выпуск, они будут стоять 3000 рублей. Но! Тут как раз цены поднялись и начали анонсировать звёзд. Рассказали про Илью Бирмана, и кого там ещё, Лёша?

**Лёша.** Про Алексея Любимова, ну не то, чтобы это звезда, но это очень крутой специалист про доступность, как раз. Он работает в институте коррекционной педагогики Российской академии образования, и это человек, который, в принципе, занимается тестированием доступности в сервисов Яндекс. Ну, если я не ошибаюсь, если что, меня ребята поправят. И он в своём докладе будет очень много рассказывать о доступности не в теоретическом плане, а прям в практическом плане. То есть он будет показывать сервисы Яндекса, видимо, как они плохо дружат с доступностью, и что они делали, чтобы исправить, чтобы было хорошо. По-моему, это очень круто, это можно именно поговорить с человеком по-русски, во-первых, а во-вторых, с человеком, который практически всё это делает. Мне кажется, это здорово. Я вот точно собираюсь ехать на [FrontTalks](http://fronttalks.ru/), даже не я один, а мы с Игорем поедем, который будет выступать. И может ещё кто-то с нами поедет. И наверняка и ты, Вадим, собираешься?

**Вадим.** Да, на самом деле я обещал Олегу прислать в понедельник, 1 августа, тезисы к своему докладу. В общем, как обычно, никому не говорите.

**Лёша.** Тсс.

## 04:57 Инлайновое видео в iOS

**Вадим.** На этой неделе всех удивили разработчики Webkit. Не тем, что они написали очередной пост [New `<video>` Policies for iOS](https://webkit.org/blog/6784/new-video-policies-for-ios/), они последнее время довольно открытые, а тем, что они начали пост со смешной гифки, и вообще, шутки, там была шутка из Стар Трек, в общем, все гики оценили. Но главное было не это, а то, что они решили немножечко смягчить суровые правила по вставке видео на мобильных платформах эппловских, то есть на IOS. В новой версии IOS 10, они разрешат воспроизводить видео без участия пользователя. То есть, если у вашего видео допустим не будет звуковой дорожки, или там будет стоять атрибут `muted`, то вы сможете запустить его с помощью метода `play` или с помощью атрибута `autoplay`. То есть, грубо говоря, можно, наконец-то, забить на гифки и пользоваться нормальными `<video>`. Они рассказывают историю, вообще, появления гифок в интернете, почему они появились, и насколько они не эффективны. Они по весу в два раза тяжелее, по энергоэффективности в десятки раз хуже. И наверное пришла пора нам снова те самые гифки сконвертированные из видео сконвертировать обратно в видео и вставлять на страницу с фолбеком на гиф. Они предлагают несколько хороших снипетов в посте, поэтому посмотрите внимательно и попробуйте сэкономить батарейку и трафик ваших пользователей, хватит уже гифки вставлять.

**Лёша.** Ну, и помимо этого, они ещё один атрибут добавили: они, наконец-то, разрешили проигрывать видео не в Full Screen, а прям инлайново на странице. Потому что сейчас, если вы на мобильном откроете страничку, где будет видео, и нажмёте на `play` этого видео, оно обязательно откроется у вас в режиме Full Screen. То есть, понятно, почему это было сделано, но это было совсем неудобно, особенно вот сейчас, когда любят делать сайты, когда на фон, который называется hero-картинка, куда иногда картинку кладут, а иногда туда видео запихивают. И `autoplay` у нас уже есть, но было бы круто, если бы оно прямо инлайново играло на странице. И они это сделали, добавили новый атрибут `playsinline`. То есть, по умолчанию, поведение видео останется, оно будет в Full Screen открываться, но если вы вставите этот атрибут, то видео будет играться хорошо, как вы и ожидаете, прямо на странице. По сути, так же, как и на десктопах.

**Вадим.** Ну, на айпадах видео уже играется инлайн, по-моему, по умолчанию, если вы сами не пустили его Full Screen. Но мы понимаем, что основной юзкейс – это мобильные, поэтому, да, очень классно, что, наконец, можно использовать видео инлайном. Потому что видео, это ведь не просто видео, которое вот только так можно смотреть. В видео можно закинуть, не знаю, какую-нибудь маленькую иконочку, которая лучше всего анимируется, как видео, и чтобы она инлайном в странице торчала. Ну как угодно, спиннер можно сделать видео, понимаете. Без сжатия какое-нибудь видео будет лучше и эффективнее играться, чем любая гифка.

## 08:09 ChakraCore на Mac и Linux

## 25:12 Модальные окна

**Вадим.** У нас на этой неделе много тем про доступность. Кто-то уже стонет, что мол сколько можно. Ну, до тех пор пока вы не поймёте, и я не буду видеть в интернете доступные сайты. Ладно, шучу. Просто действительно совпало много хороших статей на эту тему. И мне кажется, что это довольно важно.

Погранично с доступностью и вообще удобством был [хороший перевод](http://prgssr.ru/development/oformlenie-modalnyh-okon.html "Оформление модальных окон"). Крис Койер недавно на CSS-Tricks описал собственный опыт по работе с модальными окнами на страницах. Описал немного очевидные вещи, но которые на самом деле не очень-то очевидны рядовому разработчику: что модальные окна нужно фиксировать с `position: fixed`, что нужно делать их `max-width`, чтобы они не обрезались на экранах, и так далее.

Мой собственный опыт как пользователя интернета показывает, что регулярно я сталкиваюсь с тем, что я захожу на какой-нибудь сайт, он предлагает мне форму регистрации, и я не могу нормально проскроллить — оно зафиксировано и у `body` отключен какой-нибудь `overflow`, и в итоге оно ещё позиционируется c помощью JavaScript частенько. Получается очень плохо и очень страшно. И поскольку подобные вещи редко предусматриваются дизайнерами, ну то есть они вам рисуют модальное окно и говорят «поехали», — то вам приходится принимать очень много интерфейсных решений. Мне всегда казалось, что работа верстальщика довольно-таки интересная, потому что мы принимаем много интерфейсных решений.

Так вот Крис Койер советует, какие интерфейсные решения вам стоит принимать, когда вы работаете с модальными окнами. Он особо не притрагивается к теме доступности модальных окон, потому что там есть собственные какие-то нюансы, что фокус Таба должен быть пойман внутри этого модального окна, чтобы он не гулял по странице, что кнопку нужно всегда показывать видимой, чтобы из модального окна можно было выйти с клавиатуры. В общем, много есть нюансов. И если вы делаете модальные окна, или если у вас уже есть модальные окна, проверьте их по этому чеклисту, который предлагает Крис Койер, и возможно у вас найдётся повод что-то поправить в ваших модальных окнах.

**Лёша.** Я знаешь чего не обнаружил здесь. С одной стороны, это про доступность, но с другой стороны, мне всегда казалось, что это просто обязательная вещь. Я считаю, что нажимая клавишу Escape, ты должен закрывать то, что открывается. И для модальных окон это просто обязательная вещь в моём понимании. Мы привыкли в операционных системах, что всё, что у нас открывается, мы можем закрыть клавишей Escape, у нас есть всегда быстрая клавиша, которая нафиг всё закрывает, что всплыло.

И жалко, что в этой статье этого пункта нет, потому что я даже на «Базовом интенсиве» ребятам, когда рассказываю про JavaScript, я рассказываю, например, про этот элемент обязательно: ребята, мы закрыли по крестику, закрыли по вот этому оверлею кликом — это всё хорошо, но не забываем ещё закрыть по клавише Escape. Вроде такая банальная вещь, но делают её очень редко. А она ведь вносит такой положительный опыт работы с интерфейсами. То, что всплывает, оно чаще всего бесит, потому что чаще всего… Ну нет, не чаще всего конечно. Когда ты кликаешь на какой-то элемент, и у тебя всплывает формочка с вводом — это окей. Но иногда ведь модальные окна используют не так хорошо: в них открывают баннеры всплывающие и всё остальное. И вот в этом смысле их нужно срочно закрыть. Обязательно нужно, чтобы клавиша Escape работала.

**Вадим.** У меня с клавишей Escape связанна собственная боль. Кстати, escape — это убежать, escape — это выход. Поэтому не забывайте, что на этой клавише написано _то_, _что_ ваш пользователь скорее всего сделает, когда увидит ваше ненужное модальное окно.

Так вот личная боль связана с тем, что в браузерах Opera клавиша Escape выводит из полноэкранного режима. В какой-то момент это работало так и в Chrome, они потом это убрали. Но вот в Opera это поведение сохранилось. У меня частенько на ноутбуках маленькие экраны, потому что я их с собой вожу и так удобнее. И когда я пытаюсь закрыть модальное окно на сайте, а разработчики слушают Escape — всё происходит прекрасно, Escape закрывает окно. Но браузер ещё выходит из полноэкранного режима. А почему? Потому что вы, когда слушаете Escape, вы ловите его, выполняете ваш JavaScript, но не делаете `preventDefault()`. Браузер получает событие Escape и начинает обрабатывать его дополнительно. Вот это большая проблема, не только с Escape связанная. Частенько разработчики ещё слушают какие-то клавиши, Alt + [стрелочки] для навигации по странице и ещё что-нибудь такое, и не делают `preventDefault()`. Тогда это событие срабатывает и для вашего скрипта, и для браузера. А браузеры бывают разные, операционные системы бывают разные. Поэтому, если вы всё-таки сделали Escape — вы молодец, но не забудьте сделать `preventDefault()`, ведь Escape может использоваться самим браузером.

**Лёша.** Слушай, это прекрасный пример! У нас на курсе я всех заставляю делать `preventDefault()`, к слову. Но когда я рассказываю про это… То есть понятно, что мы в ссылке отменяем — действие по умолчанию, переход по ссылке — всё вроде как логично. Но в некоторых элементах, например в `<button>`, который ничего не делает, я тоже всегда ставлю `preventDefault()`, и меня спрашивают, почему. Вернее я у ребят спрашиваю, почему. И все гадают: как же, почему, что же может случиться. А я им всегда говорю: ну знаете, ребята, я параноик, я лучше лишний раз поставлю, в крайнем случае ничего не случится, вот прямо вообще ничего не случится; в другом случае, вы избежите всяких дурацких штук, потому что обычно JavaScript-разработчику должно быть пофиг на разметку. Откуда я знаю `<button>` там на самом деле или ссылка. Или сделал я скрипт, а прийдёт после меня какой-нибудь верстальщик и решит, что этот `<button>` нужно заменить на ссылку. И что, мой скрипт должен сломаться от этого. Нет конечно. И с Escape так же. Но вот этот пример про выход браузера из полноэкранного режима — это классный пример. Я теперь его буду рассказывать.

Ещё знаешь что мне понравилось в этой статье. Может быть я такой слоупок, но я до этой мысли как-то сам не дошёл, не знаю, не думал об этом. Про то, чтобы специальный класс делать для закрытия окна, и для открытия. По-моему гениальнейшая вещь. Я не знаю почему вообще такая простейшая вещь не вошла в мой мозг сама. Я совсем недавно как раз таки сталкивался с этой проблемой. Блин, я даже не додумался до этого, я не то чтобы долго думал, но тем не менее. Ровно та же проблема, которую он рассказывает. У нас блоку по умолчанию какой-то `display` задан, `display: block;` например. А сейчас часто из-за того, что есть флексы, может быть `flex`, а если это например список, то у него вообще отдельный есть `list-item`. И хорошо бы, когда вы `display: none;` делаете, ставить его обратно. Нужно вернуть же тот же самый `display`. И когда ты делаешь универсальный скрипт, такой toggler на всём сайте, например, с помощью data-атрибутов, то вам нужно как-то узнавать, про этот `display` и возвращать тот самый — и тут такие пляски с бубном получаются. А это же по-моему гениальнейшее решение: вы просто меняете их местами и у вас просто работает CSS. По моему это круто.

## 32:43 Сложные таблицы

**Вадим.** Ещё была одна статья про доступность, про доступность больших таблиц, даже не столько про доступность, сколько про то как их вообще сделать. Потому что мы как-бы получаем админки с огромными наборами данных и их как-то нужно показывать пользователям. И на десктопе мы более менее справлялись с этим, но когда приходят мобильные, нужно эти таблицы адаптировать. И на эту тему написано много всего интересного, и статей, и много разных фреймоворков, и библиотек, которые всё это реализуют. В общем много чего было сделано, но тут [высказался](https://medium.com/shopify-ux/lessons-from-building-mobile-friendly-accessible-data-tables-1e05c6924eaf#.90vszjhsr) Shopify — это такая система, которая делает удобные интернет-магазины. Допустим, A Book Apart, которая продаёт книги, использует её как интерфейс для продажи своих книг. Так вот Shopify (естественно у них там есть свои админки, где вы всё это анализируйте, есть какие-то большие данные) поделились своим опытом в серии постов про доступность как они сделали эти большие таблицы. Там есть очень много интересных советов, интересного опыта. Например, один из советов: не зацикливайтесь на прототипе. Когда вы поняли, как вы хотите, чтобы ваша таблица вела себя, сделав её на основе какой-то библиотечки, которую вы где-то откопали, не думайте, что вопрос решён, пойдём в продакшен, всё нормально. Подумайте о доступности вашего решения, подумайте насколько оно вообще оправдано, нужно ли вам грузить библиотеку и так далее. Shopify на своём опыте показал, что первый прототип, чтобы убедить дизайнеров и заказчиков как должен выглядеть интерфейс, был использован и успешно выброшен, а на его основе было написано компактное и доступное решение. В итоге оно оказалось гораздо лучше, чем тот самый прототип, потому что оно использовало таблицы для табличных данных (шок), а не дивы как это было в случае с прототипом. И более того проблему таблиц, которые становятся меньше на маленьких экранах, было решено сделать с помощью не одной таблицы, а — двух таблиц, и решение в итоге оказалось элегантным и интересным.

Вторая интересная мысль, которая озвучивается в этой статье, это то, что я уже говорил раньше — не предполагайте, если речь идёт о доступности, потому что когда мы пользуемся интерфейсами с помощью мышки и глаз, и в общем знакомых нам способов, мы не знаем как на самом деле будет работать средство доступности. В статье подробно рассматривается VoiceOver — это такой, встроенный в Mac и платформы Apple на iOS, помощник доступности, который читает ваши страницы. И в этот помощник, на самом деле, встроено много эвристики, которая пытается догадаться и помочь вам прочитывать ваши страницы доступным образом. Допустим есть момент, что VoiceOver не считает таблицу таблицей, если у рядов нет рамок — об этом есть отдельная статья от тех же авторов из Shopify. Но суть сводится к тому, что была ведь у нас эпоха, когда таблицы использовались для раскладок, и вот как наследие этой эпохи VoiceOver иногда считает вашу таблицу раскладочной. Поэтому, если вы просто сделали вашу таблицу таблицей, то вы уже молодцы. Но убедитесь, что VoiceOver правильно её понимает — может быть вам какие-то рамочки нужно добавить, чтобы всё было нормально.

То же самое с неожиданным моментом, что оказывается VoiceOver не считает дефис минусом. Приводится пример, у них в таблице было −90 $ и для того, чтобы сделать проще, чтобы пользователям было легче вводить и им тоже не париться, они использовали типографику для бедных, т.е. вместо нормального юникодного знака минуса, они взяли дефис, который совсем не предназначен для этого. И VoiceOver не читает `-90` как минус, потому что там дефис, и им в итоге пришлось использовать нормальный юникодный символ. В итоге, этот минус гораздо заметнее и понятнее тем, кто видит, и этот минус нормально прочитывается через VoiceOver. Поэтому оказывается нормальная типографика ещё и доступнее, чем типографика для бедных.

В общем, если вы делаете сложные таблицы, пробегитесь по этим рекомендациям, оцените опыт Shopify — они в общем-то серьёзные ребята. И эта не единственная статья в этой серии про доступность, очень рекомендую.

## 37:13 Формы и доступность

**Вадим.** Кроме сложного для исполнения интерфейса таблиц есть ещё сложный в исполнении интерфейс в виде форм. Формы мы все давно горячо ненавидим, потому что они немножко странные. Возможно из этого растёт проблема, что мы не очень знаем как формы верстать, используя семантическую разметку. Разработчики более менее научились пользоваться новыми элементами форм, типа `type="email"`, вариациями кнопочек, всеми вариациями чекбоксов, радиобаттонов и других новых интерфейсов. Но ещё не умеют нормально пользоваться элементами `<fieldset>` и `<legend>`. Лиони Уотсон написала [статью](https://accessibility.blog.gov.uk/2016/07/22/using-the-<fieldset>-and-legend-elements/ "Using the <fieldset> and legend elements") *(TODO: как лучше написать?)* {в блоге gov.uk} — это портал разработчиков британских правительственных сайтов. И рассказала про то, как правильно использовать `<fieldset>` и `<legend>`. Ну, казалось бы, _fieldset_ переводится как группа полей, и html-спецификация всегда рекомендовала группировать ваши поля в `<fieldset>`. Но в большинстве форм, которые я вижу, `<fieldset>` используют, как служебный элемент. Не всегда одинаковые поля группируются внутри одного `<fieldset>`. Иногда у вас одно поле, но вам по вёрстке нужна какая-то обёртка и вы используете тоже `<fieldset>`. Это всё не правильно, на самом деле. И Лиони приводит очень хороший пример. Представьте, что у вас есть поле, в котором написано: «У вас есть паспорт? Да. Нет.» Если вы нормальный разработчик, если вы умеете html писать, вы конечно используете `<label>` для вашего радиобаттона, а в `<label>` будет написано «Да», и он будет привязан к варианту с «Да», и «Нет» — к «Нет». И когда экранная читалка дойдёт до вашего `<label>` она увидит «Да» и «Нет», а какой вопрос — она не поймёт. Вы можете, конечно, в каждый `<label>` засунуть вопрос и ещё ответ туда же.

Для того, чтобы сгруппировать в таких ситуациях, используется как раз `<fieldset>`. То есть, вы заворачиваете ваши два `<input>` с `<label>` в `<fieldset>`, и этому `<fieldset>` задаёте элемент `<legend>` — легенда, описание этой группы полей. И там вы уже задаёте собственно вопрос на который отвечают эти два `<input>`. То же самое можно делать, когда у вас не просто два варианта, а много. И даже, когда они не чекбоксы, а радиобаттоны. Допустим вы спрашиваете адерес пользователя, и группируете все ответы: город, страна, индекс и прочее — всё это полезно группировать в одно поле, чтобы экранные читалки могли понять, что начались вопросы про адрес, и эти поля сгруппированы. Потому что иначе, если неожиданно откуда-то появится какое-то поле с непонятным `<label>`, не будет понятно к чему оно относится. Можно ведь так сформулировать содержание `<label>`, что не понятно, о чём идёт речь.

Продумывайте ваши формы, группируйте поля. Но если у вас всего одно поле, не группируйте, потому что экранные читалки специальным образом это обрабатывают и в итоге получается не удобно. Поэтому, если нечего группировать — группы нет.

**Лёша.** Вадим, у меня к тебе вот какой вопрос. Она в своей статье говорит о том, что можно было бы делать группировки внутри группировок, то есть вложенные `<fieldset>`. И нам спека ведь это не запрещает. По спецификации мы можем это делать, на сколько я помню. Но она при этом говорит, что лучше так не делать. С чем это связано?

**Вадим.** Спецификация разрешает это, потому что это кажется логичным, ведь в действительно сложной форме могут быть группы внутри групп. И я могу представить себе такое. Но наверно не стоит делать такие формы. А Лиони объясняет в чём дело. В современных экранных читалках нет возможности обозначить, когда группа закончилась. Поэтому, если у вас уже есть группа, и вы находитесь внутри неё, то следующая группа откроется, и не очень понятно, когда закроется, и когда начнётся следующая. Экранные читалки не умеют нормально демонстрировать иерархичность. И наверно даже её сложновато держать в уме пользователям, которые не видят интерфейс. Поэтому да, можно просто порекомендовать *(TODO: неразб.)* {выслушать/вы слушаете} рекомендацию от пользователя, который сам читает, а не видит ваши сайты, можно порекомендовать не вкладывать `<fieldset>` друг в друга, чтобы не усложнять чтение их.

**Лёша.** Мне понравилась концовка в этой статье. Она такая же лёгкая, как в твоём докладе «Жми сюда»: что выбрать, кнопку или ссылку. Тут точно так же: как определить, использовать `<fieldset>` с `<legend>` или нет. Очень простое решение — вы один раз его прочитаете и будете всегда знать, как это делать, прямо как с кнопкой и ссылкой. Использовать `<fieldset>` и `<legend>` нужно, когда у вас есть несколько ответов на вопрос, или когда у вас несколько полей объединены одним вопросом. Всё. Если у вас одиночное поле, которое отвечает на вопрос самостоятельно — вам не нужно использовать `<fieldset>` и `<legend>`. Это по-моему, простейшее правило, которое очень легко применять каждый день. Особо, кстати говоря, помня предыдущие подкасты, не тратя на это дополнительного времени.

**Вадим.** Если этот совет Лиони касается узкой темы, то на этой недел Эдди Османи написал ещё более расширенный пост. Они с Мэттом Гантом записывают такой *(TODO: неразб.)* {ситком}, как я называю. Называется [Totally Tooling Tips](https://www.youtube.com/watch?v=pBJZsp5LsOE&index=2&list=PLNYkxOF6rcIB3ci6nwNyLYNU6RDOU3YyL). Они сидят где-нибудь в кафешке калифорнийской, и разговаривают друг с другом на тему инструментов, любых инструментов. И из одного такого выпуска про инструменты доступности Эдди Османи, развернул целый [пост](https://medium.com/p/39e727101a67 "Accessible UI Components For The Web") на Medium про то, какие важные принципы есть для того, чтобы делать ваши интерфейсы и ваши сайты доступными. И если вы в какой-то момент решите (может быть после этого выпуска и значит моя задача выполнена) ваши интерфейсы сделать доступными не только для тех, у кого есть обе руки, мышка и глаза, а и для всех остальных людей, то эта статья — хорошее начало. Она объясняет базовые принципы, рекомендует инструменты, и в принципе говорит об этом довольно таки понятным языком. Я надеюсь кто-нибудь возьмётся и переведёт её, потому что это правда хорошее начало.

## 44:04 Чехарда с цветовыми функциями
